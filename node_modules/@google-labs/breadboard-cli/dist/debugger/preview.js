import { c as B, d as C, n as U, f as _, t as W, s as O, T as c, g as R, x as a, k as T, o as I, h as P, q as M } from "./index-GydqL_St.js";
import { c as S, B as F, a as L } from "./config-QQQDC_TM.js";
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var w = function(o, e, t, r) {
  var n = arguments.length, s = n < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, d;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(o, e, t, r);
  else
    for (var l = o.length - 1; l >= 0; l--)
      (d = o[l]) && (s = (n < 3 ? d(s) : n > 3 ? d(e, t, s) : d(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, y = function(o, e, t, r, n) {
  if (r === "m")
    throw new TypeError("Private method is not writable");
  if (r === "a" && !n)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? o !== e || !n : !e.has(o))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return r === "a" ? n.call(o, t) : n ? n.value = t : e.set(o, t), t;
}, i = function(o, e, t, r) {
  if (t === "a" && !r)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? o !== e || !r : !e.has(o))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return t === "m" ? r : t === "a" ? r.call(o) : r ? r.value : e.get(o);
}, u, b, p, m, v, g, h, $, z, E, j;
const q = async (o) => {
  const e = await F.load(o, { base: new URL(window.location.href) }), { title: t, description: r, version: n } = e;
  return { title: t, description: r, version: n };
};
B();
let f = class extends O {
  constructor() {
    super(), u.add(this), this.embed = !1, this.uiElement = c, this.showContinueButton = !1, this.boardInfo = null, b.set(this, null), p.set(this, null), m.set(this, !1), v.set(this, []), g.set(this, []), h.set(this, R());
    const e = new URL(window.location.href), t = e.searchParams.get("board"), r = e.searchParams.get("embed") !== null;
    if (!t) {
      console.warn("No Board URL provided - exiting");
      return;
    }
    this.embed = r, y(this, p, t, "f"), y(this, b, S(i(this, p, "f")), "f"), i(this, b, "f").diagnostics = !1, i(this, g, "f").length = 0, i(this, u, "m", E).call(this);
  }
  render() {
    if (!i(this, p, "f"))
      return c;
    const e = this.showContinueButton ? a`<button @click=${i(this, u, "m", j)} id="continue">Continue</button>` : c;
    return a`<main>
        <h1>${this.boardInfo?.title}</h1>
        <section class="ui">${this.uiElement} ${e}</section>
        <section class="outputs">${i(this, v, "f")}</section>
      </main>
      <footer>Made with Breadboard</footer>`;
  }
};
b = /* @__PURE__ */ new WeakMap();
p = /* @__PURE__ */ new WeakMap();
m = /* @__PURE__ */ new WeakMap();
v = /* @__PURE__ */ new WeakMap();
g = /* @__PURE__ */ new WeakMap();
h = /* @__PURE__ */ new WeakMap();
u = /* @__PURE__ */ new WeakSet();
$ = function(e) {
  const t = e.schema;
  return !t || !t.properties ? a`<bb-json-tree
        .json=${e}
        .autoExpand=${!0}
      ></bb-json-tree>` : a`${Object.entries(t.properties).map(([r, n]) => {
    const s = e[r];
    let d;
    if (n.format === "stream") {
      let l = "";
      const x = L(e[r]).pipeTo(new WritableStream({
        write(k) {
          l += k.chunk;
        }
      })).then(() => a`${l}`);
      d = a`${M(x, a`Loading...`)}`;
    } else
      d = typeof s == "object" ? a`<bb-json-tree
                  .json=${s}
                  .autoExpand=${!0}
                ></bb-json-tree>` : a`${s}`;
    return a`<section class="output-item">
          <h1 title="${n.description || "Undescribed property"}">
            ${n.title || "Untitled property"}
          </h1>
          <div>${d}</div>
        </section>`;
  })}`;
};
z = async function(e) {
  switch (this.showContinueButton = !1, e.type) {
    case "secret": {
      this.showContinueButton = !0;
      const t = [];
      this.uiElement = a`${t}`;
      const r = await Promise.all(e.data.keys.map((n) => new Promise((s) => {
        const d = n, l = {
          schema: {
            properties: {
              secret: {
                title: d,
                description: `Enter ${d}`,
                type: "string"
              }
            }
          }
        }, x = a`<bb-input
                id=${d}
                ${P(i(this, h, "f"))}
                .secret=${!0}
                .remember=${!0}
                .configuration=${l}
                @breadboardinputenter=${(k) => {
          s([n, k.data.secret]);
        }}
              ></bb-input>`;
        t.push(x);
      })));
      return this.uiElement = c, Object.fromEntries(r);
    }
    case "input":
      return this.showContinueButton = !0, new Promise((t) => {
        this.uiElement = a`<bb-input
            id="${e.data.node.id}"
            ${P(i(this, h, "f"))}
            .configuration=${e.data.inputArguments}
            @breadboardinputenter=${(r) => {
          this.uiElement = c, t(r.data);
        }}
          ></bb-input>`;
      });
    case "error":
      return typeof e.data.error == "string" ? this.uiElement = a`<div class="error">
            ðŸ˜© ${e.data.error}
          </div>` : this.uiElement = a`<div class="error">
            ðŸ˜© Error
            <bb-json-tree .json=${e.data.error.error}></bb-json-tree>
            in "${e.data.error.descriptor.id}"
          </div>`, Promise.resolve(void 0);
    case "output":
      return this.uiElement = c, y(this, m, !0, "f"), i(this, v, "f").unshift(i(this, u, "m", $).call(this, e.data.outputs)), this.requestUpdate(), Promise.resolve(void 0);
    case "graphstart":
    case "graphend":
    case "nodeend":
    case "skip":
      return Promise.resolve(void 0);
    case "end":
      return i(this, m, "f") ? this.uiElement = c : this.uiElement = a`<div class="output">All done!</div>`, Promise.resolve(void 0);
    case "nodestart":
      return i(this, g, "f").push(e), this.uiElement = a`<div class="working">
          <h1>Working...</h1>
          <div class="container">
            <ol>
              ${i(this, g, "f").map((t) => a`<li
                  class="${I({ [t.data.node.type]: !0 })}"
                >
                  ${t.data.node.id}
                </li>`)}
            </ol>
          </div>
        </div> `, Promise.resolve(void 0);
  }
};
E = async function() {
  if (!(!i(this, b, "f") || !i(this, p, "f"))) {
    this.boardInfo = await q(i(this, p, "f"));
    for await (const e of T(i(this, b, "f"))) {
      const t = await i(this, u, "m", z).call(this, e);
      this.showContinueButton = !1, t && await e.reply({ inputs: t });
    }
  }
};
j = function() {
  i(this, h, "f").value && i(this, h, "f").value.processInput();
};
f.styles = C`
    :host {
      display: block;
      margin: 0;
      padding: 0;
      font-family: var(--bb-font-family);
      height: 100%;
      width: 100%;
    }

    * {
      box-sizing: border-box;
    }

    :host {
      display: flex;
      flex-direction: column;
      background: #f4f7fc url(/images/pattern.png);
    }

    main {
      flex: 1 0 auto;
      display: flex;
      flex-direction: column;
    }

    #continue {
      border-radius: 32px;
      background: var(--bb-accent-color);
      border: none;
      padding: calc(var(--bb-grid-size) * 2) calc(var(--bb-grid-size) * 4);
      margin: 0 calc(var(--bb-grid-size) * 3) calc(var(--bb-grid-size) * 3) 0;
      position: relative;
      font-size: var(--bb-text-medium);
      color: #fff;
      align-self: flex-end;
    }

    h1 {
      font-size: 24px;
      margin: 0;
      padding: 42px calc(var(--bb-grid-size) * 2) 24px;
      font-weight: normal;
      text-align: center;
      text-transform: uppercase;
      color: var(--bb-accent-color);
    }

    footer {
      border-top: 1px solid rgba(0, 0, 0, 0.1);
      padding: 16px 36px;
      font-size: 0.75rem;
      text-transform: uppercase;
    }

    footer span {
      font-weight: bold;
    }

    @media (min-width: 600px) {
      h1 {
        padding: 32px calc(var(--bb-grid-size) * 2);
        font-size: 32px;
      }
    }

    @media (min-width: 900px) {
      h1 {
        padding: 40px calc(var(--bb-grid-size) * 2);
        font-size: 40px;
      }
    }

    .working,
    .error,
    .output {
      line-height: 1.5;
    }

    .working,
    .error {
      text-align: center;
    }

    .error bb-json-tree {
      text-align: left;
    }

    .error code {
      text-align: left;
    }

    .error {
      color: #cc0011;
    }

    .ui {
      padding: 0 32px;
      max-width: 960px;
      margin: 0 auto;
      width: 100%;
      display: flex;
      flex-direction: column;
    }

    .outputs {
      padding: 32px;
      flex: 1 0 auto;
      padding-bottom: 100px;
      overflow-y: scroll;
      mask-image: linear-gradient(
        rgba(0, 0, 0, 0),
        rgba(0, 0, 0, 1) 32px,
        rgba(0, 0, 0, 1) calc(100% - 32px),
        rgba(0, 0, 0, 0)
      );
      /* Set so we get the overflow scroll behavior */
      height: 0px;
    }

    .output-item {
      line-height: 1.5;
      font-size: var(--bb-text-medium);
      max-width: 960px;
      margin: 0 auto;
      margin-bottom: 32px;
      width: 100%;
    }

    .output-item h1 {
      padding: 0;
      margin: 0 0 8px;
      font-size: var(--bb-text-large);
      text-align: left;
    }

    .working {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0 auto;
      margin-bottom: 60px;
      position: relative;
      width: 60%;
      box-sizing: border-box;
      padding: 0 32px;

      --size: 16px;
    }

    .working h1 {
      font-size: var(--bb-text-default);
      margin: 0;
      padding: 0 0 16px 0;
    }

    .working .container {
      height: 80px;
      width: 100%;
      background: #fff;
      border-radius: 50px;
      box-shadow: 0 30px 32px rgba(0, 0, 0, 0.1), 0 10px 12px rgba(0, 0, 0, 0.1),
        0 2px 2px rgba(0, 0, 0, 0.1);
    }

    .working ol {
      list-style: none;
      padding: 0;
      margin: 20px 40px;
      overflow: hidden;
      font-size: var(--bb-text-pico);
      white-space: nowrap;
      display: flex;
      justify-content: flex-end;
      mask-image: linear-gradient(
        to right,
        rgba(0, 0, 0, 0),
        rgb(0, 0, 0) 40px
      );
    }

    .working ol li {
      display: inline-block;
      flex: 0 0 auto;
      position: relative;
      width: 20%;
      height: 42px;
      color: rgb(119, 119, 119);
      overflow-x: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      padding-top: 25px;
    }

    .working ol li:before {
      content: "";
      position: absolute;
      top: calc((var(--size) - 4px) * 0.5);
      left: 0;
      height: 4px;
      background: rgb(218, 218, 218);
      width: 100%;
    }

    .working ol li:last-of-type::before {
      width: 50%;
    }

    .working ol li:first-child:before {
      width: 50%;
      left: 50%;
    }

    .working ol li:only-child:before {
      display: none;
    }

    .working ol li:after {
      box-sizing: border-box;
      font-size: var(--bb-text-small);
      font-weight: bold;
      content: "";
      width: var(--size);
      height: var(--size);
      display: block;
      border-radius: 50%;
      position: absolute;
      left: 50%;
      top: 0;
      translate: -50% 0;
      border: 1px solid hsl(33.6, 100%, 52.5%);
      background: hsl(44.7, 100%, 80%);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.25);
    }

    .working ol li.error::after {
      background: #cc0000;
      border: 1px solid #cc0000;
    }

    .working ol li.result::after {
      background: #ffa500;
      border: 1px solid #ffa500;
    }

    .working ol li.input::after {
      background: #c9daf8ff;
      border: 1px solid #3c78d8;
    }

    .working ol li.secrets::after {
      background: #f4cccc;
      border: 1px solid #db4437;
    }

    .working ol li.output::after {
      background: #b6d7a8ff;
      border: 1px solid #38761d;
    }

    .working ol li.load::after,
    .working ol li.end::after {
      background: var(--bb-done-color);
      border: 1px solid var(--bb-done-color);
    }

    .working ol li:last-of-type::after {
      background: radial-gradient(
          var(--bb-progress-color) 0%,
          var(--bb-progress-color) 30%,
          var(--bb-progress-color-faded) 30%,
          var(--bb-progress-color-faded) 50%,
          transparent 50%,
          transparent 100%
        ),
        conic-gradient(transparent 0deg, var(--bb-progress-color) 360deg),
        linear-gradient(
          var(--bb-progress-color-faded),
          var(--bb-progress-color-faded)
        );

      box-shadow: none;
      border: none;
      animation: rotate 0.5s linear infinite;
    }

    @keyframes rotate {
      from {
        transform: rotate(0);
      }

      to {
        transform: rotate(360deg);
      }
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }
  `;
w([
  U({ reflect: !0 })
], f.prototype, "embed", void 0);
w([
  _()
], f.prototype, "uiElement", void 0);
w([
  _()
], f.prototype, "showContinueButton", void 0);
w([
  _()
], f.prototype, "boardInfo", void 0);
f = w([
  W("bb-preview")
], f);
