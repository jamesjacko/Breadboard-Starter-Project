/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class Rd {
  /**
   * Computes the missing inputs for a node. A missing input is an input that is
   * required by the node, but is not (yet) available in the current state.
   * @param heads All the edges that point to the node.
   * @param inputs The input values that will be passed to the node
   * @param current The node that is being visited.
   * @returns Array of missing input names.
   */
  static computeMissingInputs(e, r, n) {
    const s = [
      ...new Set(e.filter((a) => !!a.in && !a.optional).map((a) => a.in || ""))
    ], i = /* @__PURE__ */ new Set();
    return Object.keys(r).forEach((a) => i.add(a)), n.configuration && Object.keys(n.configuration).forEach((a) => i.add(a)), s.filter((a) => !i.has(a));
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class nu {
  state = /* @__PURE__ */ new Map();
  constants = /* @__PURE__ */ new Map();
  #e(e, r, n, s) {
    let i = e.get(r);
    i || (i = /* @__PURE__ */ new Map(), e.set(r, i));
    let a = i.get(n);
    a || (a = [], i.set(n, a)), a.push(s);
  }
  /**
   * Processes outputs by wiring them to the destinations according
   * to the supplied edges. Assumes that the outputs were generated by
   * the from node.
   *
   * @param opportunites {Edge[]} Edges to process
   * @param outputs {OutputValues} Outputs to wire
   */
  wireOutputs(e, r) {
    if (e.filter((n) => n.from != e[0].from).length !== 0)
      throw new Error("All opportunities must be from the same node");
    e.forEach((n) => {
      const s = n.to, i = n.out, a = n.constant ? this.constants : this.state;
      if (i) {
        if (i === "*")
          for (const o in r) {
            const c = r[o];
            c != null && c != null && this.#e(a, s, o, c);
          }
        else if (n.in) {
          const o = r[i];
          o != null && o != null && this.#e(a, s, n.in, o);
        }
      }
    });
  }
  /**
   * Returns the available inputs for a given node.
   *
   * @param nodeId {NodeIdentifier} The node to get the inputs for.
   * @returns {InputValues} The available inputs.
   */
  getAvailableInputs(e) {
    const r = {};
    for (const n of [
      this.constants.get(e),
      // Constants are overwritten by state.
      this.state.get(e)
    ])
      if (n)
        for (const [s, i] of n.entries())
          i.length !== 0 && (r[s] = i[0]);
    return r;
  }
  /**
   * Shifts inputs from the queues. Leaves constants as is.
   *
   * @param nodeId {NodeIdentifier} The node to shift the inputs for.
   * @param inputs {InputValues} The inputs that are used.
   */
  useInputs(e, r) {
    const n = this.state.get(e);
    if (n)
      for (const s in r) {
        const i = n.get(s);
        i && i.shift();
      }
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class ws {
  descriptor;
  inputs;
  missingInputs;
  opportunities;
  newOpportunities;
  state;
  outputsPromise;
  pendingOutputs;
  constructor(e, r, n, s, i, a, o) {
    this.descriptor = e, this.inputs = r, this.missingInputs = n, this.opportunities = s, this.newOpportunities = i, this.state = a, this.pendingOutputs = o;
  }
  /**
   * `true` if the machine decided that the node should be skipped, rather than
   * visited.
   */
  get skip() {
    return this.missingInputs.length > 0;
  }
  static fromObject(e) {
    const r = new nu();
    return r.constants = e.state.constants, r.state = e.state.state, new ws(e.descriptor, e.inputs, e.missingInputs, e.opportunities, e.newOpportunities, r, e.pendingOutputs);
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class _n {
  graph;
  #e;
  #t;
  constructor(e, r, n = !0) {
    this.graph = e, this.#e = r, this.#t = n;
  }
  static #r(e, r) {
    const { promiseId: n, outputs: s, newOpportunities: i } = r;
    e.pendingOutputs.delete(n);
    const a = s.$error ? i.filter((o) => o.out === "$error") : i;
    if (e.opportunities.push(...a), e.state.wireOutputs(a, s), s.$error) {
      if (a.length === 0)
        throw new Error("Uncaught exception in node handler. Catch by wiring up the $error output.", {
          cause: s.$error
        });
      globalThis.console.warn("Error in node handler, passing to the wired $error output.", s.$error, a);
    }
  }
  static async processAllPendingNodes(e) {
    return (await Promise.all(e.pendingOutputs.values())).forEach((n) => {
      _n.#r(e, n);
    }), e;
  }
  async next() {
    if (!this.#e.skip) {
      const { inputs: y, outputsPromise: S, newOpportunities: E, descriptor: M } = this.#e;
      this.#e.state.useInputs(M.id, this.#e.inputs);
      const A = Symbol(), $ = new Promise((x) => {
        (S || Promise.resolve({})).then((P) => {
          if (P.$error) {
            const U = P.$error;
            P.$error = {
              descriptor: M,
              ...U,
              inputs: { ...y, ...U.inputs }
            };
          }
          x({ promiseId: A, outputs: P, newOpportunities: E });
        }).catch((P) => {
          x({
            promiseId: A,
            outputs: {
              $error: {
                kind: "error",
                error: P,
                inputs: y,
                descriptor: M
              }
            },
            newOpportunities: E.filter((U) => U.out === "$error")
          });
        });
      });
      this.#e.pendingOutputs.set(A, $);
    }
    for (; (this.#e.opportunities.length === 0 || this.#t) && this.#e.pendingOutputs.size > 0; )
      _n.#r(this.#e, await Promise.race(this.#e.pendingOutputs.values()));
    if (this.#e.opportunities.length === 0)
      return { done: !0, value: null };
    const e = this.#e.opportunities.shift(), { heads: r, nodes: n, tails: s } = this.graph, i = e.to, a = n.get(i);
    if (!a)
      throw new Error(`No node found for id "${i}"`);
    const o = r.get(i) || [], c = this.#e.state.getAvailableInputs(i), l = Rd.computeMissingInputs(o, c, a), f = s.get(i) || [], h = {
      ...a.configuration,
      ...c
    };
    return this.#e = new ws(a, h, l, this.#e.opportunities, f, this.#e.state, this.#e.pendingOutputs), { done: !1, value: this.#e };
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class Dd {
  /**
   * Tails: a map of all outgoing edges, keyed by node id.
   */
  tails = /* @__PURE__ */ new Map();
  /**
   * Heads: a map of all incoming edges, keyed by node id.
   */
  heads = /* @__PURE__ */ new Map();
  /**
   * Nodes: a map of all nodes, keyed by node id.
   */
  nodes = /* @__PURE__ */ new Map();
  /**
   * Entries: a list of all nodes that have no incoming edges.
   */
  entries = [];
  constructor(e) {
    this.tails = e.edges.reduce((r, n) => {
      const s = n.from;
      return r.has(s) ? r.get(s)?.push(n) : r.set(s, [n]), r;
    }, /* @__PURE__ */ new Map()), this.heads = e.edges.reduce((r, n) => {
      const s = n.to;
      return r.has(s) ? r.get(s)?.push(n) : r.set(s, [n]), r;
    }, /* @__PURE__ */ new Map()), this.nodes = e.nodes.reduce((r, n) => (r.set(n.id, n), r), /* @__PURE__ */ new Map()), this.entries = Array.from(this.tails.keys()).filter((r) => !this.heads.has(r) || this.heads.get(r)?.length === 0);
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class su {
  graph;
  previousResult;
  constructor(e, r) {
    this.graph = new Dd(e), this.previousResult = r;
  }
  [Symbol.asyncIterator]() {
    return this.start();
  }
  start() {
    if (this.previousResult)
      return new _n(this.graph, this.previousResult);
    const { entries: e } = this.graph;
    if (e.length === 0)
      throw new Error("No entry node found in graph.");
    const r = e.map((s) => ({
      from: "$entry",
      to: s
    })), n = new ws({ id: "$empty", type: "$empty" }, {}, [], r, [], new nu(), /* @__PURE__ */ new Map());
    return new _n(this.graph, n);
  }
  static async prepareToSave(e) {
    return await _n.processAllPendingNodes(e);
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const xd = (t, e) => e instanceof Map ? { $type: "Map", value: Array.from(e.entries()) } : e, Md = (t, e) => {
  const { $type: r } = e || {};
  return r == "Map" && e.value ? new Map(e.value) : e;
}, iu = async (t, e) => {
  const r = await su.prepareToSave(e);
  return JSON.stringify({ state: r, type: t }, xd);
}, au = (t) => {
  const { state: e, type: r } = JSON.parse(t, Md);
  return { state: ws.fromObject(e), type: r };
};
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Dt = () => globalThis.performance.now();
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class _s {
  #e;
  #t;
  // TODO: Remove #state and rename this to #state
  #r;
  // TODO: Remove this once RunState machinery works
  #n;
  constructor(e, r, n, s) {
    this.#t = e, this.#e = r, this.#r = n, this.#n = s;
  }
  get invocationId() {
    return this.#n;
  }
  get type() {
    return this.#e;
  }
  get node() {
    return this.#t.descriptor;
  }
  get inputArguments() {
    return this.#t.inputs;
  }
  set inputs(e) {
    this.#t.outputsPromise = Promise.resolve(e);
  }
  get outputs() {
    return this.#t.inputs;
  }
  get state() {
    return this.#t;
  }
  async save() {
    return iu(this.#e, this.#t);
  }
  get runState() {
    return this.#r;
  }
  get timestamp() {
    return Dt();
  }
  isAtExitNode() {
    return this.#t.newOpportunities.length === 0 && this.#t.opportunities.length === 0 && this.#t.pendingOutputs.size === 0;
  }
  static load(e) {
    const { state: r, type: n } = au(e);
    return new _s(r, n, void 0, 0);
  }
}
class ou extends _s {
  constructor(e, r, n) {
    super(e, "input", r, n);
  }
  get outputs() {
    throw new Error('Outputs are not available in the "input" stage');
  }
}
class jd extends _s {
  constructor(e, r) {
    super(e, "output", void 0, r);
  }
  get inputArguments() {
    throw new Error('Input arguments are not available in the "output" stage');
  }
  set inputs(e) {
    throw new Error('Setting inputs is not available in the "output" stage');
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Ld = (t, e, r) => {
  const n = new URL(e, t), s = n.hash, i = n.href, a = n.protocol === "file:" ? decodeURIComponent(n.pathname) : void 0, o = t.href.replace(t.hash, ""), c = i.replace(s, "");
  if (o == c && s)
    return r.push({ type: "hash", location: s.substring(1), href: i }), !0;
  const l = a ? { type: "file", location: a, href: i } : i ? { type: "fetch", location: c, href: i } : { type: "unknown", location: "", href: i };
  return r.push(l), !s;
}, Ud = async (t) => {
  if (typeof globalThis.process > "u")
    throw new Error("Unable to use `path` when not running in node");
  let e;
  if (typeof require == "function") {
    const { readFile: r } = require("node:fs/promises");
    e = r;
  } else {
    const { readFile: r } = await import(
      /* vite-ignore */
      "./__vite-browser-external-jWVCDlBL.js"
    );
    e = r;
  }
  return JSON.parse(await e(t, "utf-8"));
}, Fd = async (t) => await (await fetch(t)).json();
class Vd {
  loaders;
  graphs;
  constructor(e) {
    this.loaders = {
      file: Ud,
      fetch: Fd,
      hash: async (r) => {
        if (!e)
          throw new Error("No sub-graphs to load from");
        return e[r];
      },
      unknown: async () => {
        throw new Error("Unable to determine Board loader type");
      }
    };
  }
  async load(e) {
    const r = await this.loaders[e.type](e.location);
    return r.url = e.href, r;
  }
}
class qd {
  #e;
  #t;
  constructor({ base: e, graphs: r }) {
    this.#e = e, this.#t = r;
  }
  async load(e) {
    const r = [];
    let n = this.#e;
    for (; !Ld(n, e, r); )
      n = new URL(r[r.length - 1].href);
    let s, i = this.#t, a = !0;
    for (const o of r)
      (o.type === "file" || o.type === "fetch") && (a = !1), s = await new Vd(i).load(o), i = s.graphs;
    if (!s)
      throw new Error("BoardLoader failed to load a graph. This error likely indicates a bug in the BoardLoader.");
    return { graph: s, isSubgraph: a };
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
ReadableStream.prototype[Symbol.asyncIterator] || // eslint-disable-next-line
// @ts-ignore
(ReadableStream.prototype[Symbol.asyncIterator] = async function* () {
  const t = this.getReader();
  try {
    for (; ; ) {
      const { done: e, value: r } = await t.read();
      if (e)
        return;
      yield r;
    }
  } finally {
    t.releaseLock();
  }
});
class Bd {
  writable;
  readable;
  controller = null;
  constructor() {
    this.writable = new WritableStream({
      write: (e) => this.write(e)
    }), this.readable = new ReadableStream({
      start: (e) => {
        this.controller = e;
      }
    });
  }
  write(e) {
    new TextDecoder().decode(e).split(`
`).map((s) => s.trim()).filter((s) => s.length > 0).forEach((s) => {
      try {
        if (s === "stop") {
          this.controller?.close();
          return;
        }
        const i = JSON.parse(s);
        this.controller?.enqueue(i);
      } catch (i) {
        console.error(i);
      }
    });
  }
}
const zd = async (t, e, r) => (await fetch(t, {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ inputs: e, state: r })
})).body?.pipeThrough(new Bd());
async function* Wd(t) {
  let e, r;
  for (; ; ) {
    const n = await zd(t, e, r);
    if (!n)
      break;
    for await (const s of n)
      r = JSON.stringify(s.state), yield s, e = s.inputs;
    if (!r)
      break;
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Hd = (t) => {
  if (t instanceof Function)
    return t;
  if (t.invoke)
    return t.invoke;
  throw new Error("Invalid handler");
}, En = async (t, e, r) => {
  const n = Hd(t);
  return new Promise((s) => {
    n(e, r).then(s).catch((i) => {
      s({ $error: { error: i } });
    });
  });
}, Ba = (t) => t.reduce((e, r) => ({ ...r.handlers, ...e }), {});
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Zd = (t, e) => `%%{init: 'themeVariables': { 'fontFamily': 'Fira Code, monospace' }}%%
graph ${e};
${t}
classDef default stroke:#ffab40,fill:#fff2ccff,color:#000
classDef input stroke:#3c78d8,fill:#c9daf8ff,color:#000
classDef output stroke:#38761d,fill:#b6d7a8ff,color:#000
classDef passthrough stroke:#a64d79,fill:#ead1dcff,color:#000
classDef slot stroke:#a64d79,fill:#ead1dcff,color:#000
classDef config stroke:#a64d79,fill:#ead1dcff,color:#000
classDef secrets stroke:#db4437,fill:#f4cccc,color:#000
classDef slotted stroke:#a64d79`, Kd = (t, e) => `graph ${e};
${t}`, Dr = (t) => t && t.replace(/-/g, ""), Yo = (t, e = "") => {
  if (!t)
    return "";
  const r = t.id, s = `${e ? `${Dr(e)}_` : ""}${Dr(r)}`, i = t.type, a = `"${i} <br> id='${r}'"`;
  switch (i) {
    case "include":
      return `${s}[[${a}]]:::include`;
    case "slot":
      return `${s}((${a})):::slot`;
    case "passthrough":
      return `${s}((${a})):::passthrough`;
    case "input":
      return `${s}[/${a}/]:::input`;
    case "secrets":
      return `${s}(${a}):::secrets`;
    case "output":
      return `${s}{{${a}}}:::output`;
    default:
      return `${s}[${a}]`;
  }
}, Gd = (t, e, r = "") => {
  const n = t.from, s = Yo(e.get(n), r), i = t.to, a = Yo(e.get(i), r), o = t.in, c = t.out, l = t.optional, f = t.constant;
  return c === "*" ? `${s} -- all --> ${a}` : c && o ? l ? `${s} -. "${c}->${o}" .-> ${a}` : f ? `${s} -- "${c}->${o}" --o ${a}` : `${s} -- "${c}->${o}" --> ${a}` : `${s} --> ${a}`;
};
class za {
  nodeMap;
  edges;
  nodes;
  idPrefix;
  subgraphs;
  constructor(e, r = "") {
    const { edges: n, nodes: s } = e;
    this.nodeMap = new Map(s.map((i) => [i.id, i])), this.edges = n, this.nodes = s, this.idPrefix = r, this.subgraphs = e.graphs || {};
  }
  handleSlotted(e, r) {
    const n = r ? `${Dr(r)}_` : "";
    if (e.type !== "include")
      return "";
    const i = e.configuration?.slotted;
    return i ? Object.entries(i).map(([o, c]) => this.describeSubgraph(c, o, "slotted", e, `${n}${e.id}`)).join(`
`) : "";
  }
  handleLambda(e, r) {
    const n = r ? `${Dr(r)}_` : "", s = e.configuration?.board;
    if (!s)
      return "";
    const i = s;
    if (i.kind !== "board")
      return "";
    const a = i.board;
    return this.describeSubgraph(a, e.id, "lamdba", e, `${n}${e.id}`);
  }
  describeSubgraphs(e, r = "") {
    const n = this.nodeMap.get(e.from);
    if (!n)
      return "";
    const s = this.handleLambda(n, r);
    return `${this.handleSlotted(n, r)}${s}`;
  }
  describeSubgraph(e, r, n, s, i) {
    const o = new za(e, i).describeGraph(), c = this.idPrefix ? `${Dr(this.idPrefix)}_` : "", l = n && s ? `sg_${Dr(r)}:::slotted -- "${n}->${n}" --o ${c}${Dr(s.id)}
` : "";
    return `
subgraph sg_${Dr(r)} [${r}]
${o}
end
${l}`;
  }
  describeGraph(e = !1) {
    const r = this.edges.map((s) => {
      const i = Gd(s, this.nodeMap, this.idPrefix), a = e ? "" : this.describeSubgraphs(s, this.idPrefix);
      return `${i}${a}`;
    }), n = e ? "" : Object.entries(this.subgraphs).map(([s, i]) => this.describeSubgraph(i, s, void 0, void 0, `${s}${this.idPrefix}`));
    return [...r, ...n].join(`
`);
  }
}
const Jd = (t, e = "TD", r = !1, n = !1) => {
  const i = new za(t).describeGraph(n);
  return r ? Kd(i, e) : Zd(i, e);
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Yd = (t) => t == null ? "null" : Array.isArray(t) ? "array" : typeof t;
class Et {
  additionalProperties = !1;
  required = [];
  properties = {};
  build() {
    const e = {
      type: "object",
      properties: this.properties,
      additionalProperties: this.additionalProperties
    };
    return this.required.length > 0 && (e.required = this.required), e;
  }
  setAdditionalProperties(e) {
    return e !== void 0 && (this.additionalProperties = e), this;
  }
  addInputs(e) {
    return e ? (Object.entries(e).forEach(([r, n]) => {
      this.addProperty(r, { type: Yd(n) });
    }), this) : this;
  }
  addProperty(e, r) {
    return this.properties[e] = r, this;
  }
  addProperties(e) {
    return Object.entries(e).forEach(([r, n]) => {
      this.addProperty(r, n);
    }), this;
  }
  addRequired(e) {
    return e ? (typeof e == "string" ? this.required = [...this.required, e] : Array.isArray(e) && e.length > 0 && (this.required = [...this.required, ...e]), this) : this;
  }
  static empty(e = !1) {
    return new Et().setAdditionalProperties(e).build();
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Xo = (t, e = {}, r) => {
  const n = e.title ?? e?.url;
  return `Missing ${r ? "required " : ""}input "${t}"${n ? ` for board "${n}".` : "."}`;
}, Xd = async (t, e, r, n) => {
  if (!e.requestInput)
    return;
  const s = await n.outputsPromise ?? {}, i = new ef(s, n.inputs);
  n.outputsPromise = i.read(Qd(t, e, r));
}, Qd = (t, e, r) => async (n, s, i) => {
  if (i)
    throw new Error(Xo(n, t, i));
  if (s.default !== void 0)
    return "type" in s && s.type !== "string" ? JSON.parse(s.default) : s.default;
  const a = await e.requestInput?.(n, s, r);
  if (a === void 0)
    throw new Error(Xo(n, t, i));
  return a;
};
class ef {
  #e;
  #t;
  constructor(e, r) {
    this.#e = e, this.#t = r;
  }
  async read(e) {
    if (!("schema" in this.#t))
      return this.#e;
    const r = this.#t.schema;
    if (!r.properties)
      return this.#e;
    const n = Object.entries(r.properties), s = {};
    for (const [i, a] of n) {
      if (i in this.#e) {
        s[i] = this.#e[i];
        continue;
      }
      const o = r.required?.includes(i) ?? !1, c = await e(i, a, o);
      s[i] = c;
    }
    return {
      ...this.#e,
      ...s
    };
  }
}
class tf {
  #e;
  #t = /* @__PURE__ */ new Map();
  constructor(e) {
    this.#e = e;
  }
  createHandler(e, r) {
    return async (n, s, i) => {
      const a = this.#t.get(n);
      if (a !== void 0)
        return a;
      const o = { id: i.id, type: i.type }, c = {
        ...r,
        descriptor: o,
        inputs: {
          schema: { type: "object", properties: { [n]: s } }
        }
      };
      await e(new ou(c, void 0, -1));
      const l = await c.outputsPromise;
      let f = l && l[n];
      return f === void 0 && (f = await this.#e.requestInput?.(n, s, o)), s.transient || this.#t.set(n, f), f;
    };
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Ki = () => {
};
class rf {
  #e = [];
  #t = Ki;
  #r;
  #n;
  abort = Ki;
  constructor() {
    this.#s();
  }
  #s() {
    this.#r = new Promise((e, r) => {
      this.#t = e, this.abort = r;
    });
  }
  #i(e) {
    this.#e.push(e), this.#e.length == 1 && (this.#t(), this.#s());
  }
  async write(e) {
    return new Promise((r) => {
      this.#i({ value: e, receipt: r });
    });
  }
  async read() {
    this.#n && this.#n(), this.#e.length === 0 && await this.#r;
    const e = this.#e.shift();
    if (!e)
      throw new Error("asyncGen queue should never be empty.");
    return this.#n = e.receipt, e.value ? { done: !1, value: e.value } : { done: !0, value: void 0 };
  }
  close() {
    this.#i({ value: void 0, receipt: Ki });
  }
}
class nf {
  #e;
  #t = !0;
  #r = new rf();
  constructor(e) {
    this.#e = e;
  }
  /**
   * Called by the callback to advance to the next value.
   * Roughly equivalent to "yield":
   * ```ts
   * yield value;
   * ```
   * same as
   * ```ts
   * await next(value);
   * ```
   * @param value
   */
  async #n(e) {
    return this.#r.write(e);
  }
  async next() {
    return this.#t && (this.#t = !1, this.#e(this.#n.bind(this)).then(() => {
      this.#r.close();
    }).catch((e) => {
      this.#r.abort(e);
    })), this.#r.read();
  }
}
const sf = (t) => ({
  [Symbol.asyncIterator]() {
    return new nf(t);
  }
});
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class af {
  #e;
  #t;
  constructor(e) {
    this.#e = structuredClone(e) || [];
  }
  onGraphStart() {
    this.#e.push({ graph: 0, node: 0 });
  }
  onNodeStart(e) {
    this.#e[this.#e.length - 1].node++, this.#t = e;
  }
  onNodeEnd() {
  }
  onGraphEnd() {
  }
  async state() {
    const e = structuredClone(this.#e);
    return this.#t && (e[e.length - 1].state = await iu("nodestart", this.#t)), e;
  }
}
const h$ = (t) => {
  const { state: e } = t[t.length - 1];
  return e ? au(e).state : void 0;
}, of = "https://json-schema.org/draft/2020-12/schema", cf = "https://raw.githubusercontent.com/breadboard-ai/breadboard/@google-labs/breadboard-schema@1.2.0/packages/schema/breadboard.schema.json", uf = "Breadboard", lf = "An executable program graph", df = {
  identifier: {
    type: "string",
    pattern: "^[a-zA-Z_][a-zA-Z0-9_-]*$"
  }
}, ff = "object", hf = [
  "nodes",
  "edges"
], pf = !1, mf = {
  $schema: {
    type: "string",
    format: "uri-reference"
  },
  title: {
    description: "A human-readable title for the graph",
    type: "string"
  },
  description: {
    description: "Description of the graph",
    type: "string"
  },
  version: {
    description: `Semantic version of the graph
See https://semver.org/`,
    type: "string",
    pattern: "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$"
  },
  nodes: {
    description: "All of the nodes in the graph",
    type: "array",
    items: {
      description: 'A "step" or "function" in the program which performs computation',
      type: "object",
      required: [
        "id",
        "type"
      ],
      additionalProperties: !1,
      properties: {
        id: {
          description: "Identifier for this node that is unique to this graph",
          $ref: "#/$defs/identifier"
        },
        type: {
          description: "The type of the node. Must be either a built-in type or a type provided by a kit.",
          $ref: "#/$defs/identifier"
        },
        configuration: {
          description: "Type-specific configuration of the node",
          type: "object",
          additionalProperties: !0
        }
      }
    }
  },
  edges: {
    description: "All of the edges in the graph",
    type: "array",
    items: {
      description: "A connection between two nodes through which data flows",
      type: "object",
      required: [
        "from",
        "to"
      ],
      additionalProperties: !1,
      properties: {
        from: {
          description: "The ID of the source node",
          $ref: "#/$defs/identifier"
        },
        to: {
          description: "The ID of the destination node",
          $ref: "#/$defs/identifier"
        },
        out: {
          description: 'The output port of the `from` node.\nIf "*", then all outputs of the `from` node are passed to the `to` node. In this case `in` must be empty string or undefined.\nIf undefined or empty string, then no data is passed, and the nodes are instead connected purely for yielding control flow. In this case `in` must be empty string or undefined.',
          type: "string"
        },
        in: {
          description: 'The input port of the `to` node.\nMust be empty string or undefined if and only if `out` is either "*" or itself empty string or undefined.',
          type: "string"
        },
        optional: {
          description: "If true, nodes connected to this edge won't wait for data to appear before proceding with execution.",
          type: "boolean"
        },
        constant: {
          description: "If true, the most recent data that passed through this edge will remain available indefinitely, instead of being destructively consumed.",
          type: "boolean"
        }
      },
      oneOf: [
        {
          required: [],
          properties: {
            out: {
              const: ""
            },
            in: {
              const: ""
            }
          }
        },
        {
          required: [
            "out"
          ],
          properties: {
            out: {
              const: "*"
            },
            in: {
              const: ""
            }
          }
        },
        {
          required: [
            "out",
            "in"
          ],
          properties: {
            out: {
              $ref: "#/$defs/identifier"
            },
            in: {
              $ref: "#/$defs/identifier"
            }
          }
        }
      ]
    }
  },
  kits: {
    description: "All of the kits this graph depends on",
    type: "array",
    items: {
      description: "A library that will be imported prior to execution for providing handlers for non built-in node types.",
      type: "object",
      required: [
        "url"
      ],
      additionalProperties: !1,
      properties: {
        url: {
          description: "Address of the kit",
          type: "string",
          format: "uri"
        }
      }
    }
  },
  graphs: {
    description: "Sub-graphs that can be referred to by nodes in the parent graph.",
    type: "object",
    additionalProperties: !1,
    patternProperties: {
      "^[a-zA-Z_][a-zA-Z0-9_-]*$": {
        $ref: "#"
      }
    }
  },
  args: {
    description: "Arguments that are passed to the graph, useful to bind values to lambdas.",
    type: "object",
    additionalProperties: !0
  }
}, Qo = {
  $schema: of,
  $id: cf,
  title: uf,
  description: lf,
  $defs: df,
  type: ff,
  required: hf,
  additionalProperties: pf,
  properties: mf
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class wt {
  // GraphDescriptor implementation.
  url;
  title;
  description;
  $schema;
  version;
  edges = [];
  nodes = [];
  kits = [];
  graphs;
  args;
  #e = {};
  #t = [];
  /**
   * The parent board, if this is board is a subgraph of a larger board.
   */
  #r;
  /**
   *
   * @param metadata - optional metadata for the board. Use this parameter
   * to provide title, description, version, and URL for the board.
   */
  constructor({ url: e, title: r, description: n, version: s, $schema: i } = {
    $schema: Qo.$id
  }) {
    Object.assign(this, {
      $schema: i ?? Qo.$id,
      url: e,
      title: r,
      description: n,
      version: s
    });
  }
  /**
   * Runs the board. This method is an async generator that
   * yields the results of each stage of the run.
   *
   * Conceptually, when we ask the board to run, it will occasionally pause
   * and give us a chance to interact with it.
   *
   * It's typically used like this:
   *
   * ```js
   * for await (const stop of board.run()) {
   * // do something with `stop`
   * }
   * ```
   *
   * The `stop` iterator result will be a `RunResult` and provide ability
   * to influence running of the board.
   *
   * The two key use cases are providing input and receiving output.
   *
   * If `stop.type` is `input`, the board is waiting for input values.
   * When that is the case, use `stop.inputs` to provide input values.
   *
   * If `stop.type` is `output`, the board is providing output values.
   * When that is the case, use `stop.outputs` to receive output values.
   *
   * See [Chapter 8: Continuous runs](https://github.com/breadboard-ai/breadboard/tree/main/packages/breadboard/docs/tutorial#chapter-8-continuous-runs) of Breadboard tutorial for an example of how to use this method.
   *
   * @param probe - an optional probe. If provided, the board will dispatch
   * events to it. See [Chapter 7: Probes](https://github.com/breadboard-ai/breadboard/tree/main/packages/breadboard/docs/tutorial#chapter-7-probes) of the Breadboard tutorial for more information.
   * @param slots - an optional map of slotted graphs. See [Chapter 6: Boards with slots](https://github.com/breadboard-ai/breadboard/tree/main/packages/breadboard/docs/tutorial#chapter-6-boards-with-slots) of the Breadboard tutorial for more information.
   * @param result - an optional result of a previous run. If provided, the
   * board will resume from the state of the previous run.
   * @param kits - an optional map of kits to use when running the board.
   */
  async *run(e = {}, r) {
    const n = e.base || new URL(this.url || "", import.meta.url);
    yield* sf(async (s) => {
      const { probe: i } = e, a = await wt.handlersFromBoard(this, e.kits), o = { ...this.#e, ...e.slots };
      this.#t.forEach((E) => E.addGraph(this));
      const c = new su(this, r?.state), l = new tf(e), f = e.invocationPath || [], h = new af(e.state);
      await i?.report?.({
        type: "graphstart",
        data: { metadata: this, path: f, timestamp: Dt() }
      });
      let y = 0;
      h.onGraphStart();
      const S = () => [...f, y];
      for await (const E of c) {
        y++;
        const { inputs: M, descriptor: A, missingInputs: $ } = E;
        if (E.skip) {
          await i?.report?.({
            type: "skip",
            data: {
              node: A,
              inputs: M,
              missingInputs: $,
              path: S(),
              timestamp: Dt()
            }
          });
          continue;
        }
        h.onNodeStart(E), await i?.report?.({
          type: "nodestart",
          data: {
            node: A,
            inputs: M,
            path: S(),
            timestamp: Dt()
          },
          state: await h.state()
        });
        let x;
        if (A.type === "input")
          await s(new ou(E, await h.state(), y)), await Xd(this, e, A, E), x = E.outputsPromise;
        else if (A.type === "output")
          await s(new jd(E, y)), x = E.outputsPromise;
        else {
          const P = a[A.type];
          if (!P)
            throw new Error(`No handler for node type "${A.type}"`);
          const U = {
            ...e,
            board: this,
            descriptor: A,
            outerGraph: this.#r || this,
            base: n,
            slots: o,
            kits: [...e.kits || [], ...this.kits],
            requestInput: l.createHandler(s, E),
            invocationPath: S(),
            state: await h.state()
          };
          x = En(P, M, U);
        }
        h.onNodeEnd(), await i?.report?.({
          type: "nodeend",
          data: {
            node: A,
            inputs: M,
            outputs: await x,
            validatorMetadata: this.#t.map((P) => P.getValidatorMetadata(A)),
            path: S(),
            timestamp: Dt()
          }
        }), E.outputsPromise = x;
      }
      h.onGraphEnd(), await i?.report?.({
        type: "graphend",
        data: { metadata: this, path: f, timestamp: Dt() }
      });
    });
  }
  get validators() {
    return this.#t;
  }
  /**
   * A simplified version of `run` that runs the board until the board provides
   * an output, and returns that output.
   *
   * This is useful for running boards that don't have multiple outputs
   * or the the outputs are only expected to be visited once.
   *
   * @param inputs - the input values to provide to the board.
   * @param probe - an optional probe. If provided, the board will dispatch
   * events to it. See [Chapter 7: Probes](https://github.com/breadboard-ai/breadboard/tree/main/packages/breadboard/docs/tutorial#chapter-7-probes) of the Breadboard tutorial for more information.
   * @param slots - an optional map of slotted graphs. See [Chapter 6: Boards with slots](https://github.com/breadboard-ai/breadboard/tree/main/packages/breadboard/docs/tutorial#chapter-6-boards-with-slots) of the Breadboard tutorial for more information.
   * @param kits - an optional map of kits to use when running the board.
   * @returns - outputs provided by the board.
   */
  async runOnce(e, r = {}) {
    const n = { ...e, ...this.args }, { probe: s } = r;
    if (r.board && r.descriptor)
      for (const i of r.board.validators)
        this.addValidator(i.getSubgraphValidator(r.descriptor, Object.keys(n)));
    try {
      let i = {};
      const a = r.invocationPath || [];
      for await (const o of this.run(r))
        if (o.type === "input")
          o.inputs = n;
        else if (o.type === "output") {
          i = o.outputs, await s?.report?.({
            type: "nodeend",
            data: {
              node: o.node,
              inputs: o.inputs,
              outputs: i,
              path: [...a, o.invocationId],
              timestamp: Dt()
            }
          }), await s?.report?.({
            type: "graphend",
            data: { metadata: this, path: a, timestamp: Dt() }
          });
          break;
        }
      return i;
    } catch (i) {
      if (i.cause)
        return { $error: i.cause };
      throw i;
    }
  }
  /**
   * Add validator to the board.
   * Will call .addGraph() on the validator before executing a graph.
   *
   * @param validator - a validator to add to the board.
   */
  addValidator(e) {
    this.#t.push(e);
  }
  /**
   * Returns a [Mermaid](https://mermaid-js.github.io/mermaid/#/) representation
   * of the board.
   *
   * This is useful for visualizing the board.
   *
   * @returns - a string containing the Mermaid representation of the board.
   */
  mermaid(e = "TD", r = !1, n = !1) {
    return Jd(this, e, r, n);
  }
  /**
   * Creates a new board from JSON. If you have a serialized board, you can
   * use this method to turn it into into a new Board instance.
   *
   * @param graph - the JSON representation of the board.
   * @returns - a new `Board` instance.
   */
  static async fromGraphDescriptor(e) {
    const r = new wt(e);
    return r.edges = e.edges, r.nodes = e.nodes, r.graphs = e.graphs, r.args = e.args, r;
  }
  /**
   * Loads a board from a URL or a file path.
   *
   * @param url - the URL or a file path to the board.
   * @param slots - optional slots to provide to the board.
   * @returns - a new `Board` instance.
   */
  static async load(e, r) {
    const { base: n, slotted: s, outerGraph: i } = r || {}, a = new qd({
      base: n,
      graphs: i?.graphs
    }), { isSubgraph: o, graph: c } = await a.load(e), l = await wt.fromGraphDescriptor(c);
    return o && (l.#r = i), l.#e = s || {}, l;
  }
  /**
   * Creates a runnable board from a BreadboardCapability,
   * @param board {BreadboardCapability} A BreadboardCapability including a board
   * @returns {Board} A runnable board.
   */
  static async fromBreadboardCapability(e) {
    if (e.kind !== "board" || !e.board)
      throw new Error(`Expected a "board" Capability, but got ${e}`);
    const r = e.board;
    if (!(r.edges && r.kits && r.nodes))
      throw new Error('Supplied "board" Capability argument is not actually a board');
    let n = e.board;
    return n.runOnce || (n = await wt.fromGraphDescriptor(r)), n;
  }
  static async handlersFromBoard(e, r = []) {
    const s = [new gf(), ...r, ...e.kits];
    return Ba(s);
  }
  static runRemote = Wd;
}
let gf = class {
  handlers;
  constructor() {
    this.handlers = {
      lambda: {
        describe: async (e) => ({
          inputSchema: new Et().setAdditionalProperties(!0).addInputs(e).addProperty("board", {
            title: "board",
            description: "The board to run.",
            type: "object"
          }).build(),
          outputSchema: new Et().addProperty("board", {
            title: "board",
            description: "The now-runnable board.",
            type: "object"
          }).build()
        }),
        invoke: async (e) => {
          const { board: r, ...n } = e;
          if (!r || r.kind !== "board" || !r.board)
            throw new Error('Lambda node requires a BoardCapability as "board" input');
          const s = {
            ...await wt.fromBreadboardCapability(r),
            args: n
          };
          return {
            board: { ...r, board: s }
          };
        }
      }
    };
  }
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class cu {
  #e = /* @__PURE__ */ new Map();
  vendId(e, r) {
    let n = this.#e.get(e) || 0;
    return n++, this.#e.set(e, n), `${r}-${n}`;
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const yf = /^((?<a>.*)(?<dir><-|->))?(?<b>[^(.|?)]*)(?<q>\.|\?)?$/m, vf = (t) => {
  const e = { ltr: !0 }, r = t.match(yf);
  if (!r)
    throw new Error(`Invalid edge spec: ${t}`);
  const { a: n, b: s, dir: i, q: a } = r?.groups, o = i !== "<-";
  e.ltr = o;
  const c = a === "?", l = a === ".";
  return e.edge = {}, l && (e.edge.constant = !0), c && (e.edge.optional = !0), !n && !s ? e : n === "*" || s === "*" ? (e.edge.out = "*", e) : n ? s ? (o ? (e.edge.out = n, e.edge.in = s) : (e.edge.out = s, e.edge.in = n), e) : (e.edge.out = n, e.edge.in = n, e) : (e.edge.out = s, e.edge.in = s, e);
}, bf = new cu(), wf = (t) => Object.values(t).length > 0;
class rn {
  #e;
  #t;
  constructor(e, r, n, s, i) {
    if (this.#t = e.currentBoardToAddTo(), this.#e = {
      id: i ?? bf.vendId(this.#t, n),
      type: n
    }, s && wf(s)) {
      const a = Object.entries(s).filter(([o, c]) => c instanceof rn);
      for (const [o, c] of a) {
        if (delete s[o], o.indexOf("->") !== -1)
          throw Error("Cannot pass output wire in confdig");
        this.wire(o.indexOf("<-") === -1 ? `${o}<-.` : o, c);
      }
      this.#e.configuration = s;
    }
    r?.url && !this.#t.kits.find((a) => a.url === r.url) && this.#t.kits.push(r), this.#t.addNode(this.#e);
  }
  wire(e, r) {
    const { ltr: n, edge: s } = vf(e), [i, a] = n ? [this, r] : [r, this], o = {
      from: i.#e.id,
      to: a.#e.id,
      ...s
    };
    return i.#t !== a.#t ? a.#t.addEdgeAcrossBoards(o, i.#t, a.#t) : this.#t.addEdge(o), this;
  }
  get id() {
    return this.#e.id;
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const ii = (t) => new t({
  create: () => {
    throw Error("Node instantiation can't (yet) happen during runtime");
  }
}), _f = (t, e) => new t({
  create: (...r) => new rn(e, ...r),
  getConfigWithLambda: (r) => Ef(e, r)
}), Ef = (t, e) => {
  const r = e.nodes !== void 0 && e.edges !== void 0 && e.kits !== void 0, s = r || typeof e == "function" || e instanceof rn || e.kind === "board" && e.board ? { board: r ? { kind: "board", board: e } : e } : e;
  return typeof s.board == "function" && (s.board = t.lambda(s.board)), s;
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class Gt extends wt {
  #e = [];
  #t;
  #r = [];
  /**
   * Core nodes. Breadboard won't function without these.
   * These are always included.
   */
  /**
   * Places an `input` node on the board.
   *
   * An `input` node is a node that asks for inputs from the user.
   *
   * See [`input` node reference](https://github.com/breadboard-ai/breadboard/blob/main/packages/breadboard/docs/nodes.md#input) for more information.
   *
   * @param config - optional configuration for the node.
   * @returns - a `Node` object that represents the placed node.
   */
  input(e = {}) {
    const { $id: r, ...n } = e;
    return new rn(this, void 0, "input", { ...n }, r);
  }
  /**
   * Places an `output` node on the board.
   *
   * An `output` node is a node that provides outputs to the user.
   *
   * See [`output` node reference](https://github.com/breadboard-ai/breadboard/blob/main/packages/breadboard/docs/nodes.md#output) for more information.
   *
   * @param config - optional configuration for the node.
   * @returns - a `Node` object that represents the placed node.
   */
  output(e = {}) {
    const { $id: r, ...n } = e;
    return new rn(this, void 0, "output", { ...n }, r);
  }
  /**
   * Place a `lambda` node on the board.
   *
   * It is a node that represents a subgraph of nodes. It can be passed to
   * `invoke` or nodes like `map` (defined in another kit) that invoke boards.
   *
   * Input wires are made available as input values to the lambda board.
   *
   * `board` is the only output and represents a BoardCapability that invoke and
   * others consume.
   *
   * You can either pass a `Board` or a Javascript function to this method. The
   * JS function is called with a `board` to add things to, and for convenience,
   * input and output nodes attached to the board.
   *
   * Example: board.lambda((board, input, output) => { input.wire( "item->item",
   * kit.someNode().wire( "value->value", output));
   * });
   *
   * @param boardOrFunction A board or a function that builds the board
   * @param config - optional configuration for the node.
   * @returns - a `Node` object that represents the placed node.
   */
  lambda(e, r = {}) {
    const { $id: n, ...s } = r;
    let i, a;
    if (typeof e == "function") {
      i = new Gt(), a = i.input();
      const c = i.output();
      i.#t = this.#t ?? this, i.#t.#e.push(i), e(i, a, c), i.#t.#e.pop();
    } else
      i = e;
    const o = new rn(this, void 0, "lambda", {
      board: { kind: "board", board: i },
      ...s
    }, n);
    if (a && i.#r.length > 0) {
      for (const { edge: c, from: l, to: f } of i.#r) {
        if (f !== i || !c.constant)
          throw new Error("Across board wires: Must be constant and from parent to child");
        const h = `$l-${c.to}-${c.in}`;
        i.addEdge({ ...c, from: a.id, out: h });
        const y = { ...c, to: o.id, in: h };
        l === this ? this.addEdge(y) : this.addEdgeAcrossBoards(y, l, this);
      }
      i.#r = [];
    }
    return o;
  }
  addEdge(e) {
    this.edges.push(e);
  }
  addNode(e) {
    this.nodes.push(e);
  }
  /**
   * Adds a new kit to the board.
   *
   * Kits are collections of nodes that are bundled together for a specific
   * purpose. For example, the [Core Kit](https://github.com/breadboard-ai/breadboard/tree/main/packages/core) provides a nodes that
   * are useful for making boards.
   *
   * Typically, kits are distributed as NPM packages. To add a kit to the board,
   * simply install it using `npm` or `yarn`, and then add it to the board:
   *
   * ```js
   * import { Board } from "@google-labs/breadboard";
   * import { Core } from "@google-labs/core-kit";
   *
   * const board = new Board();
   * const kit = board.addKit(Core);
   * ```
   *
   * @param ctr - the kit constructor.
   * @returns - the kit object, which is associated with
   * the board and can be used to place nodes on that board.
   */
  addKit(e) {
    const r = _f(e, this);
    return this.kits.push(r), r;
  }
  /**
   * Used in the context of board.lambda(): Returns the board that is currently
   * being constructed, according to the nesting level of board.lambda() calls
   * with JS functions.
   *
   * Only called by Node constructor, when adding nodes.
   */
  currentBoardToAddTo() {
    const e = this.#t ? this.#t.#e : this.#e;
    return e.length === 0 ? this : e[e.length - 1];
  }
  /**
   *
   */
  addEdgeAcrossBoards(e, r, n) {
    if (e.out === "*")
      throw new Error("Across board wires: * wires not supported");
    if (!e.constant)
      throw new Error("Across board wires: Must be constant for now");
    if (n !== this)
      throw new Error("Across board wires: Must be invoked on to board");
    const s = this.#t ? this.#t.#e : this.#e;
    if (r !== this.#t && !s.includes(r))
      throw new Error("Across board wires: From must be parent of to");
    this.#r.push({ edge: e, from: r, to: n });
  }
}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class Sf {
  #e;
  constructor(e) {
    this.#e = e;
  }
  async serve() {
    const n = await this.#e.createServerStream().readableRequests.getReader().read();
    if (n.done)
      throw new Error("Client closed stream without sending a request.");
    return n.value.url;
  }
}
class m$ {
  #e;
  constructor(e) {
    this.#e = e;
  }
  async load(e) {
    const n = this.#e.createClientStream().writableRequests.getWriter();
    await n.write({ url: e }), await n.close();
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class $f extends EventTarget {
  #e;
  constructor(e) {
    super(), this.#e = e;
  }
  async report(e) {
    return this.#e(e);
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const uu = "stream";
class Ci {
  kind = uu;
  stream;
  constructor(e) {
    this.stream = e;
  }
}
const g$ = (t) => {
  const [e, r] = t.stream.tee();
  return t.stream = e, r;
}, lu = (t) => {
  const e = t;
  return e && e.kind && e.kind === uu && e.stream instanceof ReadableStream;
}, du = (t) => {
  const e = [];
  return {
    value: JSON.stringify(t, (r, n) => lu(n) ? (e.push(n.stream), { $type: "Stream", id: e.length - 1 }) : n),
    streams: e
  };
}, kf = (t, e) => JSON.parse(t, (n, s) => typeof s == "object" && s !== null && s.$type === "Stream" && typeof s.id == "number" ? new Ci(e(s.id)) : s), Tf = (t) => {
  const e = du(t).value;
  return kf(e, () => new ReadableStream());
}, ha = (t) => {
  const e = new ReadableStream({
    start(n) {
      t.onmessage = (s) => {
        if (s.data === null) {
          n.close();
          return;
        }
        n.enqueue(s.data);
      };
    },
    cancel() {
      t.onmessage = null;
    }
  }), r = new WritableStream({
    write(n) {
      const s = du(n);
      t.postMessage(n, s.streams);
    },
    close() {
      t.postMessage(null, []);
    }
  });
  return {
    readable: e,
    writable: r
  };
}, Pf = (t) => {
  let e;
  const r = new Promise((i) => {
    t().then((a) => {
      e = ha(a), i();
    });
  }), n = new ReadableStream({
    async start() {
      await r;
    },
    pull(i) {
      return e.readable.pipeTo(new WritableStream({
        write(a) {
          i.enqueue(a);
        }
      }));
    },
    cancel() {
      e.readable.cancel();
    }
  }), s = new WritableStream({
    async start() {
      await r;
    },
    async write(i) {
      const a = e.writable.getWriter();
      await a.write(i), a.releaseLock();
    },
    async close() {
      await e.writable.close();
    },
    async abort(i) {
      await e.writable.abort(i);
    }
  });
  return {
    readable: n,
    writable: s
  };
};
class If {
  #e;
  data;
  constructor(e, r) {
    this.#e = r, this.data = e;
  }
  async reply(e) {
    await this.#e.write(e);
  }
}
class Of {
  #e;
  #t;
  constructor(e, r) {
    this.#e = r.getReader(), this.#t = e.getWriter();
  }
  async next() {
    const { done: e, value: r } = await this.#e.read();
    return e ? (this.#t.close(), { done: e, value: void 0 }) : {
      done: !1,
      value: new If(r, this.#t)
    };
  }
  async return() {
    return this.#t.close(), { done: !0, value: void 0 };
  }
  async throw(e) {
    return this.#t.abort(e), { done: !0, value: void 0 };
  }
}
const fu = (t, e) => ({
  async start(r) {
    const n = t.getWriter();
    await n.write(r), n.releaseLock();
  },
  [Symbol.asyncIterator]() {
    return new Of(t, e);
  }
}), Af = (t) => new ReadableStream({
  async pull(e) {
    const { value: r, done: n } = await t.read();
    if (n) {
      e.close();
      return;
    }
    e.enqueue(r);
  }
}, { highWaterMark: 0 }), Nf = (t) => new WritableStream({
  async write(e) {
    return t.write(e);
  }
}, { highWaterMark: 0 });
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Cf = (t) => {
  const [e, , r] = t;
  if (console.log("resumeRun", e, r), !r)
    return;
  if (r.length > 1)
    throw new Error("I don't yet know how to resume from nested subgraphs.");
  const n = _s.load(r[0].state);
  if (e === "input") {
    const [, s] = t;
    n.inputs = s.inputs;
  }
  return n;
};
class Rf {
  #e;
  constructor(e) {
    this.#e = e;
  }
  async serve(e, r = !1, n = {}) {
    const s = this.#e.createServerStream(), i = s.readableRequests.getReader();
    let a = await i.read();
    if (a.done)
      return;
    const o = Cf(a.value), c = s.writableResponses.getWriter(), l = {
      ...n,
      probe: r ? new $f(async (f) => {
        const { type: h, data: y } = f, S = [h, Tf(y)];
        h == "nodestart" && S.push(f.state), await c.write(S);
      }) : void 0
    };
    try {
      for await (const f of e.run(l, o))
        if (f.type === "input") {
          const h = f.runState, { node: y, inputArguments: S, timestamp: E } = f;
          if (await c.write([
            "input",
            { node: y, inputArguments: S, timestamp: E },
            h
          ]), a = await i.read(), a.done) {
            await c.close();
            return;
          } else {
            const [M, A] = a.value;
            M === "input" && (f.inputs = A.inputs);
          }
        } else if (f.type === "output") {
          const { node: h, outputs: y, timestamp: S } = f;
          await c.write(["output", { node: h, outputs: y, timestamp: S }]);
        }
      await c.write(["end", { timestamp: Dt() }]), await c.close();
    } catch (f) {
      const h = f;
      let y;
      if (h?.cause) {
        const { cause: S } = h;
        y = S;
      } else
        y = h.message;
      console.error("Run Server error:", y), await c.write([
        "error",
        { error: y, timestamp: Dt() }
      ]), await c.close();
    }
  }
}
const Df = (t) => {
  const [e, r, n] = t.data;
  return {
    type: e,
    data: r,
    state: n,
    reply: async (i) => {
      if (e !== "input")
        throw new Error("For now, we cannot reply to messages other than 'input'.");
      await t.reply([e, i, n]);
    }
  };
};
class y$ {
  #e;
  constructor(e) {
    this.#e = e;
  }
  async *run(e) {
    const r = this.#e.createClientStream(), n = fu(r.writableRequests, r.readableResponses), s = ["run", {}];
    e && s.push(e), await n.start(s);
    for await (const i of n)
      yield Df(i);
  }
  async runOnce(e) {
    let r;
    for await (const n of this.run()) {
      const { type: s, data: i } = n;
      if (s === "input")
        n.reply({ inputs: e });
      else if (s === "output") {
        r = i.outputs;
        break;
      }
    }
    return r || {};
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const ec = "port-dispatcher-sendport";
class xf {
  #e;
  #t = /* @__PURE__ */ new Map();
  #r = /* @__PURE__ */ new Map();
  constructor(e) {
    this.#e = e, this.#e.addEventListener("message", (r) => {
      const { type: n, id: s, port: i } = r.data;
      if (n !== ec)
        return;
      const a = this.#t.get(s);
      a ? (a(i), this.#t.delete(s)) : this.#r.set(s, i);
    });
  }
  receive(e) {
    const r = this.#r.get(e);
    return r ? (this.#r.delete(e), ha(r)) : Pf(() => new Promise((n) => {
      this.#t.set(e, n);
    }));
  }
  send(e) {
    const { port1: r, port2: n } = new MessageChannel();
    return this.#e.postMessage({ type: ec, id: e, port: n }, [
      n
    ]), ha(r);
  }
}
class Mf {
  #e;
  #t;
  constructor(e) {
    this.#e = e.readable.getReader(), this.#t = e.writable.getWriter();
  }
  createClientStream() {
    return {
      writableRequests: Nf(this.#t),
      readableResponses: Af(this.#e)
    };
  }
}
class jf {
  #e;
  constructor(e) {
    this.#e = e;
  }
  createServerStream() {
    return {
      readableRequests: this.#e.readable,
      writableResponses: this.#e.writable
    };
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class gr {
  url;
  title;
  description;
  version;
  namespacePrefix;
  constructor({ title: e, description: r, version: n, url: s, namespacePrefix: i = "" }) {
    this.url = s, this.title = e, this.description = r, this.version = n, this.namespacePrefix = i;
  }
  #e(e) {
    return Object.keys(e).reduce((r, n) => (r[`${this.namespacePrefix}${n}`] = e[n], r), {});
  }
  build(e) {
    if (!this.url)
      throw new Error("Builder was not yet initialized.");
    const r = this.url, n = this.namespacePrefix, { title: s, description: i, version: a } = this, o = this.#e(e), c = Object.keys(e);
    return class {
      title = s;
      description = i;
      version = a;
      url = r;
      get handlers() {
        return o;
      }
      constructor(l) {
        const f = new Proxy(this, {
          get(h, y) {
            if (y === "handlers" || y === "url")
              return h[y];
            if (c.includes(y))
              return (S = {}) => {
                const E = l.getConfigWithLambda(S), { $id: M, ...A } = E;
                return l.create(f, `${n}${y}`, { ...A }, M);
              };
          }
        });
        return f;
      }
    };
  }
  static wrap(e, r) {
    const n = (a, o) => {
      const [c, l] = o;
      return a[c] = {
        invoke: async (f) => {
          let h = [];
          l && l.length > 0 && (h = l.toString().match(/\((.+?)\)/)?.[1].split(",") ?? [], l.length > 1 && h.length === 0 && "___args" in f && Array.isArray(f.___args) && (h = ["___args"]));
          for (const M of h)
            if (!(M.trim() in f))
              throw new Error(`Missing input: ${M.trim()}. Valid inputs are: ${Object.keys(f).join(", ")}`);
          const y = h.filter((M) => M.startsWith("___") == !1).map((M) => f[M.trim()]), S = h[h.length - 1];
          S != null && S.startsWith("___") && y.push(...f[S]);
          const E = await l(...y);
          return typeof E != "object" || Array.isArray(E) ? { result: E } : { ...E };
        }
      }, a;
    }, s = Object.entries(r).reduce(n, {});
    return new gr(e).build(s);
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Lf = globalThis.process ? (t) => Buffer.from(t, "base64").toString("binary") : globalThis.atob, Uf = globalThis.process ? (t) => Buffer.from(t, "binary").toString("base64") : globalThis.btoa, pa = "~";
class Ms {
  outputName;
  from;
  to;
  when;
  constructor(e, r, n, s = {}) {
    this.outputName = e, this.from = r, this.to = n, this.when = s;
  }
  getInputNames() {
    const e = Object.keys(this.when);
    return e.length === 0 ? [this.outputName] : e;
  }
  matches(e) {
    return Object.entries(this.when).every(([r, n]) => {
      const s = e[r];
      return typeof n == "string" ? s === n : typeof s != "string" ? !1 : n.test(s);
    });
  }
}
const Ff = (t) => t.proxy ? Object.fromEntries(t.proxy.map((e) => {
  if (typeof e != "string" && e.tunnel)
    return [e.node, Vf(e.node, e.tunnel)];
}).filter(Boolean)) : {}, Vf = (t, e) => Object.fromEntries(Object.entries(e).map(([r, n]) => typeof n == "string" ? [r, [new Ms(r, t, n)]] : Array.isArray(n) ? [
  r,
  n.map((s) => typeof s == "string" ? new Ms(r, t, s) : new Ms(r, t, s.to, s.when))
] : [
  r,
  [new Ms(r, t, n.to, n.when)]
])), qf = (t, e, r) => {
  if (t)
    return Object.fromEntries(Object.entries(t).map(([n, s]) => n in e ? [n, r(n, s)] : [n, s]));
}, Bf = async (t, e, r) => {
  const n = e.some((s) => s.matches(t));
  return Object.fromEntries(await Promise.all(Object.entries(t).map(async ([s, i]) => [s, await r(i, n)])));
}, zf = 1e3 * 60 * 60 * 24 * 7, hu = Math.round(Date.now() / zf).toString(36), Wa = `T-${hu}-`, Ha = `-${hu}-T`, Wf = new RegExp(`(${Wa}.*?${Ha})`, "gm"), Hf = new RegExp(`^${Wa}(.+?)${Ha}$`), Zf = "VALUE_BLOCKED", Kf = (t, e, r) => {
  const n = Uf(JSON.stringify(r)).replace("=", "");
  return `${Wa}${t}${pa}${e}${pa}${n}${Ha}`;
}, Gf = (t) => t.split(Wf).filter(Boolean).map((r) => {
  const n = r.match(Hf);
  if (n) {
    const s = n[1].split(pa), [i, a, o] = s, c = Lf(o);
    return {
      nodeType: i,
      outputName: a,
      inputs: c
    };
  } else
    return {
      value: r
    };
}), Jf = async (t, e, r) => {
  const n = JSON.stringify(t), s = Gf(n), i = await Promise.all(s.map(async (a) => {
    if ("inputs" in a) {
      const o = JSON.parse(a.inputs), { nodeType: c, outputName: l } = a, f = e ? await r(c, o) : { [l]: Zf };
      if (!f)
        return "";
      let h = JSON.stringify(f[l]);
      return h.startsWith('"') && (h = h.slice(1, -1)), h = JSON.stringify(h), h.slice(1, -1);
    }
    return a.value;
  }));
  return JSON.parse(i.join(""));
}, Yf = (t) => Object.entries(t).flatMap(([r, n]) => Object.entries(n).flatMap(([s, i]) => i.map((a) => [a.to, a]))).reduce((r, [n, s]) => (r[n] || (r[n] = []), r[n].push(s), r), {}), Xf = (t, e) => {
  const r = Object.fromEntries(Object.entries(e).map(([i, a]) => {
    const o = t[i];
    return o ? [
      i,
      async (c, l) => {
        const f = await En(a, c, l);
        return qf(f, o, (h) => Kf(i, h, c));
      }
    ] : [i, a];
  })), n = Yf(t);
  return {
    url: "tunnel-kit",
    handlers: Object.fromEntries(Object.entries(r).map(([i, a]) => {
      const o = n[i];
      return o ? [
        i,
        async (c, l) => En(a, await Bf(c, o, async (f, h) => Jf(f, h, async (y, S) => En(e[y], S, l))), l)
      ] : [i, a];
    }))
  };
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Qf = (t, e = []) => {
  const r = e.find((n) => typeof n == "string" ? n === t : n.node === t);
  return typeof r == "string" ? {
    node: r
  } : r;
};
class v$ {
  #e;
  constructor(e) {
    this.#e = e;
  }
  async serve(e) {
    const { kits: r } = e, n = this.#e.createServerStream(), i = Xf(Ff(e), Ba(r)).handlers;
    for await (const a of fu(n.writableResponses, n.readableRequests)) {
      const [o] = a.data;
      if (o === "end")
        break;
      if (o !== "proxy") {
        a.reply([
          "error",
          { error: "Expected proxy request.", timestamp: Dt() }
        ]);
        continue;
      }
      const [, { node: c, inputs: l }] = a.data, h = Qf(c.type, e.proxy) ? i[c.type] : void 0;
      if (!h) {
        a.reply([
          "error",
          {
            error: "Can't proxy a node of this node type.",
            timestamp: Dt()
          }
        ]);
        continue;
      }
      try {
        const y = await En(h, l, {
          descriptor: c
        });
        if (!y) {
          a.reply([
            "error",
            { error: "Handler returned nothing.", timestamp: Dt() }
          ]);
          continue;
        }
        a.reply(["proxy", { outputs: y }]);
      } catch (y) {
        a.reply([
          "error",
          { error: y.message, timestamp: Dt() }
        ]);
      }
    }
  }
}
class eh {
  #e;
  constructor(e) {
    this.#e = e;
  }
  shutdownServer() {
    const r = this.#e.createClientStream().writableRequests.getWriter();
    r.write(["end", { timestamp: Dt() }]), r.close();
  }
  async proxy(e, r) {
    const n = this.#e.createClientStream(), s = n.writableRequests.getWriter(), i = n.readableResponses.getReader();
    s.write(["proxy", { node: e, inputs: r }]), s.close();
    const a = await i.read();
    if (a.done)
      throw new Error("Unexpected proxy failure: empty response.");
    const [o] = a.value;
    if (o === "proxy") {
      const [, { outputs: c }] = a.value;
      return c;
    } else if (o === "error") {
      const [, { error: c }] = a.value;
      throw new Error(JSON.stringify(c));
    } else
      throw new Error(`Unexpected proxy failure: unknown response type "${o}".`);
  }
  createProxyKit(e = []) {
    const r = e.map((s) => typeof s == "string" ? s : s.node), n = Object.fromEntries(r.map((s) => [
      s,
      {
        invoke: async (i, a) => {
          const o = a.descriptor;
          return await this.proxy(o, i);
        }
      }
    ]));
    return ii(new gr({ url: "proxy" }).build(n));
  }
}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const th = (t) => "proxy" in t, rh = (t, e) => t.map((r) => th(r) ? new eh(e.client("proxy")).createProxyKit(r.proxy) : r);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const nh = (t) => t.base ? t.base : "window" in self ? new URL(self.location.href) : new URL(import.meta.url);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const sh = () => (
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  typeof WorkerGlobalScope < "u" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  self instanceof WorkerGlobalScope
), ih = () => {
  throw new Error("Not implemented");
};
class ah {
  #e;
  constructor(e) {
    this.#e = e;
  }
  client(e) {
    return new Mf(this.#e.send(e));
  }
  server(e) {
    return new jf(this.#e.receive(e));
  }
}
const oh = async (t, e) => {
  const r = t.url;
  return r || await new Sf(e.server("load")).serve();
}, b$ = async (t) => {
  if (t.transport !== "worker")
    throw new Error("Only worker transport is supported at this time.");
  const r = sh() ? self : ih(), n = new ah(new xf(r)), s = rh(t.kits, n), i = new Rf(n.server("run")), a = await oh(t, n), o = nh(t), c = await Gt.load(a, { base: o });
  return i.serve(c, !!t.diagnostics, { kits: s });
}, ch = (t) => t;
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function uh(t) {
  return Object.fromEntries(Object.entries(t.handlers).map(([e, r]) => {
    const n = r instanceof Function ? r : r.invoke, s = r instanceof Function ? void 0 : r.describe;
    return [
      e,
      {
        invoke: async (a) => n(await a, {}),
        ...s ? { describe: s } : {}
      }
    ];
  }));
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class Zs {
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const lh = new cu();
class tc extends Zs {
  id;
  type;
  outgoing = [];
  incoming = [];
  configuration = {};
  #e;
  #t;
  constructor(e, r, n = {}) {
    super(), this.#t = r, typeof e == "string" ? this.type = e : (this.type = "fn", this.#e = e);
    const { $id: s, ...i } = n;
    this.id = s ?? lh.vendId(r, this.type), this.configuration = i;
  }
  addIncomingEdge(e, r, n, s, i) {
    if (e.#t !== this.#t)
      throw new Error("Can't connect nodes from different scopes");
    const a = {
      to: this,
      from: e,
      out: r,
      in: n,
      schema: i
    };
    s && (a.constant = !0), this.incoming.push(a), e.outgoing.push(a);
  }
  #r(e) {
    const r = this.#e ?? e.getHandler(this.type);
    return r && typeof r != "function" ? r.describe : void 0;
  }
  // In the end, we need to capture the outputs and resolve the promise. But
  // before that there is a bit of refactoring to do to allow returning of
  // graphs, parallel execution, etc.
  //
  // The logic from BuilderNode.invoke should be somehow called from here, for
  // deserialized nodes that require the Builder environment.
  async invoke(e, r) {
    const n = r ?? this.#t, s = this.#e ?? n.getHandler(this.type);
    let i;
    const a = typeof s == "function" ? s : s?.invoke;
    if (a)
      i = await a(e, this);
    else if (s && typeof s != "function" && s.graph) {
      const o = s.graph.getPinnedNodes();
      if (o.length !== 1)
        throw new Error("Expected exactly one graph");
      i = await n.invokeOneRound(e, o[0]);
    } else
      throw new Error(`Can't find handler for ${this.id}`);
    return i;
  }
  async describe(e = this.#t, r, n, s) {
    const i = this.#r(e);
    return i ? await i(r, n, s) : void 0;
  }
  async serialize(e) {
    return this.#t.serialize(e, this);
  }
  async serializeNode() {
    return [{
      id: this.id,
      type: this.type,
      configuration: this.configuration
    }];
  }
}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class dh {
  queue = [];
  inputs = /* @__PURE__ */ new Map();
  constants = /* @__PURE__ */ new Map();
  controlWires = /* @__PURE__ */ new Map();
  haveRun = /* @__PURE__ */ new Set();
  queueUp(e) {
    this.queue.includes(e) || this.queue.push(e);
  }
  next() {
    if (!this.queue.length)
      throw new Error("No nodes in queue");
    return this.queue.shift();
  }
  done() {
    return this.queue.length === 0;
  }
  /**
   * Compute required inputs from edges and compare with present inputs
   *
   * Required inputs are
   *  - for all named incoming edges, the presence of any data, irrespective of
   *    which node they come from
   *  - at least one of the incoming empty or * wires, if present (TODO: Is that
   *    correct?)
   *  - data from at least one node if it already ran
   *
   * @returns false if none are missing, otherwise string[] of missing inputs.
   * NOTE: A node with no incoming wires returns an empty array after  first
   * run.
   */
  missingInputs(e) {
    if (e.incoming.length === 0 && this.haveRun.has(e))
      return [];
    const r = new Set(e.incoming.map((i) => i.in)), n = /* @__PURE__ */ new Set([
      ...Object.keys(e.configuration),
      ...Object.keys(this.constants.get(e) ?? {})
    ]);
    for (const [i, a] of (this.inputs.get(e) ?? /* @__PURE__ */ new Map()).entries())
      a.length && n.add(i);
    this.controlWires.get(e)?.length && n.add("");
    const s = [...r].filter((i) => !n.has(i));
    return s.length ? s : !1;
  }
  shiftInputs(e) {
    const r = { ...e.configuration, ...this.constants.get(e) }, n = this.inputs.get(e) ?? /* @__PURE__ */ new Map();
    for (const [s, i] of n.entries())
      i.length > 0 && (r[s] = i.shift());
    return this.haveRun.add(e), this.controlWires.delete(e), r;
  }
  processResult(e, r) {
    const n = { nodes: [], unused: [] }, s = new Set(Object.keys(r));
    for (const i of e.outgoing) {
      const a = this.distributeResults(i, r);
      a.forEach((c) => s.delete(c));
      const o = this.missingInputs(i.to);
      o || this.queueUp(i.to), n.nodes.push({ node: i.to, received: a, missing: o });
    }
    return n.unused = [...s], n;
  }
  distributeResults(e, r) {
    const n = e.out === "*" ? r : e.out === "" ? {} : r[e.out] !== void 0 ? { [e.in]: r[e.out] } : {};
    e.constant && this.constants.set(e.to, { ...this.constants.get(e.to), ...n }), this.inputs.has(e.to) || this.inputs.set(e.to, /* @__PURE__ */ new Map());
    const s = this.inputs.get(e.to);
    for (const i of Object.keys(n))
      s?.has(i) || s?.set(i, []), s?.get(i)?.push(n[i]);
    return e.in === "" && this.controlWires.set(e.to, [
      ...this.controlWires.get(e.to) ?? [],
      e.from
    ]), Object.keys(n);
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const fh = (t) => Object.entries(t).map(([e, r]) => {
  const n = r;
  if (n.$optional) {
    delete n.$optional;
    return;
  }
  return e;
}).filter(Boolean);
class Za {
  parentLexicalScope;
  parentDynamicScope;
  #e = {};
  #t = [];
  #r = [];
  constructor(e = {}) {
    this.parentLexicalScope = e.lexicalScope, this.parentDynamicScope = e.dynamicScope;
  }
  addHandlers(e) {
    Object.entries(e).forEach(([r, n]) => this.#e[r] = n);
  }
  getHandler(e) {
    return this.#e[e] || this.parentDynamicScope?.getHandler(e) || this.parentLexicalScope?.getHandler(e);
  }
  pin(e) {
    this.#t.push(e);
  }
  compactPins() {
    const e = /* @__PURE__ */ new Set(), r = [];
    for (const n of this.#t) {
      if (e.has(n))
        continue;
      r.push(n), this.#s(n).forEach((i) => e.add(i));
    }
    this.#t = r;
  }
  getPinnedNodes() {
    return this.#t;
  }
  addCallbacks(e) {
    this.#r.push(e);
  }
  #n() {
    return [
      ...this.#r,
      ...this.parentDynamicScope ? this.parentDynamicScope.#n() : []
    ];
  }
  async invoke(e, r = new dh()) {
    try {
      e !== !1 && (e ? e instanceof Array ? e : [e] : this.#t).flatMap((s) => this.#s(s).filter((i) => r?.missingInputs(i) === !1)).forEach((s) => r?.queueUp(s));
      const n = this.#n();
      for (; !r.done(); ) {
        for (const l of n)
          if (await l.stop?.(this, r))
            return;
        const s = r.next(), i = r.shiftInputs(s);
        let a;
        for (const l of n)
          a ??= await l.before?.(this, s, i);
        const o = a ?? await s.invoke(i, this).catch((l) => ({
          $error: {
            type: "error",
            error: l
          }
        })), c = r.processResult(s, o);
        for (const l of n)
          await l.after?.(this, s, i, o, c);
        if (c.unused.includes("$error"))
          throw o.$error.error;
      }
    } finally {
      for (const n of this.#r)
        await n.done?.();
    }
  }
  invokeOneRound(e = {}, r = void 0, n) {
    "$state" in e && (n = e.$state, delete e.$state);
    let s;
    const i = new Promise((h) => {
      s = h;
    }), a = new Za({ dynamicScope: this });
    a.addHandlers({
      input: async () => e,
      output: async (h) => (s?.(await h), s = void 0, h)
    });
    let o;
    const c = /* @__PURE__ */ new Map();
    let l;
    a.addCallbacks({
      stop: (h, y) => (s || (l = y), !s),
      after: (h, y, S, E, M) => {
        o = y;
        for (const { node: A, missing: $ } of M.nodes)
          $ ? c.set(A.id, $.join(", ")) : c.delete(A.id);
      },
      done: () => {
        s?.({
          $error: {
            type: "error",
            error: new Error(`Output node never reach. Last node was ${o?.id}.

These nodes had inputs missing:
${Array.from(c, ([h, y]) => `  ${h}: ${y}`).join(`
`)}`)
          }
        });
      }
    });
    const f = a.invoke(r !== void 0 ? r : this.#t, n);
    return Promise.all([i, f]).then(([h]) => ({
      ...h,
      ...l ? { $state: l } : {}
    }));
  }
  async serialize(e, r) {
    const n = (r ? [r] : this.#t).flatMap((o) => this.#s(o)), s = {}, i = await Promise.all(n.map(async (o) => {
      const [c, l] = await o.serializeNode();
      if (l && (s[c.id] = l), (c.type === "input" || c.type === "output") && !c.configuration?.schema) {
        const f = await this.#a(o);
        Object.entries(f.properties ?? {}).length > 0 && (c.configuration = {
          ...c.configuration,
          schema: f
        });
      }
      return c;
    })), a = n.flatMap((o) => o.outgoing.map((c) => ({
      from: c.from.id,
      to: c.to.id,
      out: c.out,
      in: c.in,
      ...c.constant ? { constant: !0 } : {}
    })));
    return { ...e, edges: a, nodes: i, graphs: s };
  }
  #s(e) {
    const r = /* @__PURE__ */ new Set(), n = [e];
    for (; n.length; ) {
      const s = n.shift();
      r.has(s) || (r.add(s), s.incoming.forEach((i) => n.push(i.from)), s.outgoing.forEach((i) => n.push(i.to)));
    }
    return [...r];
  }
  async #i(e) {
    const r = Object.fromEntries(e.incoming.filter((s) => s.out !== "" && s.out !== "*").map((s) => [s.out, s.schema ?? {}])), n = Object.fromEntries(e.outgoing.filter((s) => s.out !== "" && s.out !== "*").map((s) => [s.out, s.schema ?? {}]));
    return await e.describe(this, e.configuration, { properties: r }, { properties: n });
  }
  async #a(e) {
    const r = {}, n = /* @__PURE__ */ new Set();
    if (e.type === "input") {
      const i = /* @__PURE__ */ new Set();
      for (const a of e.outgoing)
        a.out !== "*" && a.out !== "" && (i.add(a.to), n.add(a.out), a.schema && (r[a.out] = a.schema));
      for (const a of i) {
        const c = (await this.#i(a))?.inputSchema?.properties;
        if (c)
          for (const l of a.incoming)
            l.from === e && c[l.in] && (r[l.out] = {
              ...c[l.in],
              ...r[l.out]
            });
      }
    } else if (e.type === "output") {
      const i = /* @__PURE__ */ new Set();
      for (const a of e.incoming)
        a.out !== "*" && a.out !== "" && (i.add(a.from), n.add(a.in), a.schema && (r[a.in] = a.schema));
      for (const a of i) {
        const c = (await this.#i(a))?.outputSchema?.properties;
        if (c)
          for (const l of a.outgoing)
            l.to === e && c[l.out] && (r[l.in] = {
              ...c[l.out],
              ...r[l.in]
            });
      }
    } else
      throw new Error("Can't yet derive schema for non-input/output nodes");
    for (const i of n)
      r[i] ? (r[i].type ||= "string", r[i].title ||= i) : r[i] = { type: "string", title: i };
    const s = fh(r);
    return { type: "object", properties: r, required: s };
  }
}
var Ke;
(function(t) {
  t.assertEqual = (s) => s;
  function e(s) {
  }
  t.assertIs = e;
  function r(s) {
    throw new Error();
  }
  t.assertNever = r, t.arrayToEnum = (s) => {
    const i = {};
    for (const a of s)
      i[a] = a;
    return i;
  }, t.getValidEnumValues = (s) => {
    const i = t.objectKeys(s).filter((o) => typeof s[s[o]] != "number"), a = {};
    for (const o of i)
      a[o] = s[o];
    return t.objectValues(a);
  }, t.objectValues = (s) => t.objectKeys(s).map(function(i) {
    return s[i];
  }), t.objectKeys = typeof Object.keys == "function" ? (s) => Object.keys(s) : (s) => {
    const i = [];
    for (const a in s)
      Object.prototype.hasOwnProperty.call(s, a) && i.push(a);
    return i;
  }, t.find = (s, i) => {
    for (const a of s)
      if (i(a))
        return a;
  }, t.isInteger = typeof Number.isInteger == "function" ? (s) => Number.isInteger(s) : (s) => typeof s == "number" && isFinite(s) && Math.floor(s) === s;
  function n(s, i = " | ") {
    return s.map((a) => typeof a == "string" ? `'${a}'` : a).join(i);
  }
  t.joinValues = n, t.jsonStringifyReplacer = (s, i) => typeof i == "bigint" ? i.toString() : i;
})(Ke || (Ke = {}));
var ma;
(function(t) {
  t.mergeShapes = (e, r) => ({
    ...e,
    ...r
    // second overwrites first
  });
})(ma || (ma = {}));
const le = Ke.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), Mr = (t) => {
  switch (typeof t) {
    case "undefined":
      return le.undefined;
    case "string":
      return le.string;
    case "number":
      return isNaN(t) ? le.nan : le.number;
    case "boolean":
      return le.boolean;
    case "function":
      return le.function;
    case "bigint":
      return le.bigint;
    case "symbol":
      return le.symbol;
    case "object":
      return Array.isArray(t) ? le.array : t === null ? le.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? le.promise : typeof Map < "u" && t instanceof Map ? le.map : typeof Set < "u" && t instanceof Set ? le.set : typeof Date < "u" && t instanceof Date ? le.date : le.object;
    default:
      return le.unknown;
  }
}, ne = Ke.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), hh = (t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
class nr extends Error {
  constructor(e) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = e;
  }
  get errors() {
    return this.issues;
  }
  format(e) {
    const r = e || function(i) {
      return i.message;
    }, n = { _errors: [] }, s = (i) => {
      for (const a of i.issues)
        if (a.code === "invalid_union")
          a.unionErrors.map(s);
        else if (a.code === "invalid_return_type")
          s(a.returnTypeError);
        else if (a.code === "invalid_arguments")
          s(a.argumentsError);
        else if (a.path.length === 0)
          n._errors.push(r(a));
        else {
          let o = n, c = 0;
          for (; c < a.path.length; ) {
            const l = a.path[c];
            c === a.path.length - 1 ? (o[l] = o[l] || { _errors: [] }, o[l]._errors.push(r(a))) : o[l] = o[l] || { _errors: [] }, o = o[l], c++;
          }
        }
    };
    return s(this), n;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, Ke.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (r) => r.message) {
    const r = {}, n = [];
    for (const s of this.issues)
      s.path.length > 0 ? (r[s.path[0]] = r[s.path[0]] || [], r[s.path[0]].push(e(s))) : n.push(e(s));
    return { formErrors: n, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
}
nr.create = (t) => new nr(t);
const ts = (t, e) => {
  let r;
  switch (t.code) {
    case ne.invalid_type:
      t.received === le.undefined ? r = "Required" : r = `Expected ${t.expected}, received ${t.received}`;
      break;
    case ne.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(t.expected, Ke.jsonStringifyReplacer)}`;
      break;
    case ne.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${Ke.joinValues(t.keys, ", ")}`;
      break;
    case ne.invalid_union:
      r = "Invalid input";
      break;
    case ne.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${Ke.joinValues(t.options)}`;
      break;
    case ne.invalid_enum_value:
      r = `Invalid enum value. Expected ${Ke.joinValues(t.options)}, received '${t.received}'`;
      break;
    case ne.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case ne.invalid_return_type:
      r = "Invalid function return type";
      break;
    case ne.invalid_date:
      r = "Invalid date";
      break;
    case ne.invalid_string:
      typeof t.validation == "object" ? "includes" in t.validation ? (r = `Invalid input: must include "${t.validation.includes}"`, typeof t.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? r = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? r = `Invalid input: must end with "${t.validation.endsWith}"` : Ke.assertNever(t.validation) : t.validation !== "regex" ? r = `Invalid ${t.validation}` : r = "Invalid";
      break;
    case ne.too_small:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : r = "Invalid input";
      break;
    case ne.too_big:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? r = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : r = "Invalid input";
      break;
    case ne.custom:
      r = "Invalid input";
      break;
    case ne.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case ne.not_multiple_of:
      r = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case ne.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = e.defaultError, Ke.assertNever(t);
  }
  return { message: r };
};
let pu = ts;
function ph(t) {
  pu = t;
}
function ai() {
  return pu;
}
const oi = (t) => {
  const { data: e, path: r, errorMaps: n, issueData: s } = t, i = [...r, ...s.path || []], a = {
    ...s,
    path: i
  };
  let o = "";
  const c = n.filter((l) => !!l).slice().reverse();
  for (const l of c)
    o = l(a, { data: e, defaultError: o }).message;
  return {
    ...s,
    path: i,
    message: s.message || o
  };
}, mh = [];
function de(t, e) {
  const r = oi({
    issueData: e,
    data: t.data,
    path: t.path,
    errorMaps: [
      t.common.contextualErrorMap,
      t.schemaErrorMap,
      ai(),
      ts
      // then global default map
    ].filter((n) => !!n)
  });
  t.common.issues.push(r);
}
class Nt {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, r) {
    const n = [];
    for (const s of r) {
      if (s.status === "aborted")
        return Ne;
      s.status === "dirty" && e.dirty(), n.push(s.value);
    }
    return { status: e.value, value: n };
  }
  static async mergeObjectAsync(e, r) {
    const n = [];
    for (const s of r)
      n.push({
        key: await s.key,
        value: await s.value
      });
    return Nt.mergeObjectSync(e, n);
  }
  static mergeObjectSync(e, r) {
    const n = {};
    for (const s of r) {
      const { key: i, value: a } = s;
      if (i.status === "aborted" || a.status === "aborted")
        return Ne;
      i.status === "dirty" && e.dirty(), a.status === "dirty" && e.dirty(), i.value !== "__proto__" && (typeof a.value < "u" || s.alwaysSet) && (n[i.value] = a.value);
    }
    return { status: e.value, value: n };
  }
}
const Ne = Object.freeze({
  status: "aborted"
}), mu = (t) => ({ status: "dirty", value: t }), xt = (t) => ({ status: "valid", value: t }), ga = (t) => t.status === "aborted", ya = (t) => t.status === "dirty", rs = (t) => t.status === "valid", ci = (t) => typeof Promise < "u" && t instanceof Promise;
var $e;
(function(t) {
  t.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, t.toString = (e) => typeof e == "string" ? e : e?.message;
})($e || ($e = {}));
class hr {
  constructor(e, r, n, s) {
    this._cachedPath = [], this.parent = e, this.data = r, this._path = n, this._key = s;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const rc = (t, e) => {
  if (rs(e))
    return { success: !0, data: e.value };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const r = new nr(t.common.issues);
      return this._error = r, this._error;
    }
  };
};
function De(t) {
  if (!t)
    return {};
  const { errorMap: e, invalid_type_error: r, required_error: n, description: s } = t;
  if (e && (r || n))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: s } : { errorMap: (a, o) => a.code !== "invalid_type" ? { message: o.defaultError } : typeof o.data > "u" ? { message: n ?? o.defaultError } : { message: r ?? o.defaultError }, description: s };
}
class Le {
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return Mr(e.data);
  }
  _getOrReturnCtx(e, r) {
    return r || {
      common: e.parent.common,
      data: e.data,
      parsedType: Mr(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new Nt(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: Mr(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const r = this._parse(e);
    if (ci(r))
      throw new Error("Synchronous parse encountered promise.");
    return r;
  }
  _parseAsync(e) {
    const r = this._parse(e);
    return Promise.resolve(r);
  }
  parse(e, r) {
    const n = this.safeParse(e, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  safeParse(e, r) {
    var n;
    const s = {
      common: {
        issues: [],
        async: (n = r?.async) !== null && n !== void 0 ? n : !1,
        contextualErrorMap: r?.errorMap
      },
      path: r?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: Mr(e)
    }, i = this._parseSync({ data: e, path: s.path, parent: s });
    return rc(s, i);
  }
  async parseAsync(e, r) {
    const n = await this.safeParseAsync(e, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  async safeParseAsync(e, r) {
    const n = {
      common: {
        issues: [],
        contextualErrorMap: r?.errorMap,
        async: !0
      },
      path: r?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: Mr(e)
    }, s = this._parse({ data: e, path: n.path, parent: n }), i = await (ci(s) ? s : Promise.resolve(s));
    return rc(n, i);
  }
  refine(e, r) {
    const n = (s) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(s) : r;
    return this._refinement((s, i) => {
      const a = e(s), o = () => i.addIssue({
        code: ne.custom,
        ...n(s)
      });
      return typeof Promise < "u" && a instanceof Promise ? a.then((c) => c ? !0 : (o(), !1)) : a ? !0 : (o(), !1);
    });
  }
  refinement(e, r) {
    return this._refinement((n, s) => e(n) ? !0 : (s.addIssue(typeof r == "function" ? r(n, s) : r), !1));
  }
  _refinement(e) {
    return new ar({
      schema: this,
      typeName: ee.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  optional() {
    return Sr.create(this, this._def);
  }
  nullable() {
    return cn.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return sr.create(this, this._def);
  }
  promise() {
    return Nn.create(this, this._def);
  }
  or(e) {
    return as.create([this, e], this._def);
  }
  and(e) {
    return os.create(this, e, this._def);
  }
  transform(e) {
    return new ar({
      ...De(this._def),
      schema: this,
      typeName: ee.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const r = typeof e == "function" ? e : () => e;
    return new fs({
      ...De(this._def),
      innerType: this,
      defaultValue: r,
      typeName: ee.ZodDefault
    });
  }
  brand() {
    return new yu({
      typeName: ee.ZodBranded,
      type: this,
      ...De(this._def)
    });
  }
  catch(e) {
    const r = typeof e == "function" ? e : () => e;
    return new fi({
      ...De(this._def),
      innerType: this,
      catchValue: r,
      typeName: ee.ZodCatch
    });
  }
  describe(e) {
    const r = this.constructor;
    return new r({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return Es.create(this, e);
  }
  readonly() {
    return pi.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const gh = /^c[^\s-]{8,}$/i, yh = /^[a-z][a-z0-9]*$/, vh = /^[0-9A-HJKMNP-TV-Z]{26}$/, bh = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, wh = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, _h = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let Gi;
const Eh = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, Sh = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, $h = (t) => t.precision ? t.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${t.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${t.precision}}Z$`) : t.precision === 0 ? t.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : t.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function kh(t, e) {
  return !!((e === "v4" || !e) && Eh.test(t) || (e === "v6" || !e) && Sh.test(t));
}
class rr extends Le {
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== le.string) {
      const i = this._getOrReturnCtx(e);
      return de(
        i,
        {
          code: ne.invalid_type,
          expected: le.string,
          received: i.parsedType
        }
        //
      ), Ne;
    }
    const n = new Nt();
    let s;
    for (const i of this._def.checks)
      if (i.kind === "min")
        e.data.length < i.value && (s = this._getOrReturnCtx(e, s), de(s, {
          code: ne.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), n.dirty());
      else if (i.kind === "max")
        e.data.length > i.value && (s = this._getOrReturnCtx(e, s), de(s, {
          code: ne.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), n.dirty());
      else if (i.kind === "length") {
        const a = e.data.length > i.value, o = e.data.length < i.value;
        (a || o) && (s = this._getOrReturnCtx(e, s), a ? de(s, {
          code: ne.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }) : o && de(s, {
          code: ne.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }), n.dirty());
      } else if (i.kind === "email")
        wh.test(e.data) || (s = this._getOrReturnCtx(e, s), de(s, {
          validation: "email",
          code: ne.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "emoji")
        Gi || (Gi = new RegExp(_h, "u")), Gi.test(e.data) || (s = this._getOrReturnCtx(e, s), de(s, {
          validation: "emoji",
          code: ne.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "uuid")
        bh.test(e.data) || (s = this._getOrReturnCtx(e, s), de(s, {
          validation: "uuid",
          code: ne.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "cuid")
        gh.test(e.data) || (s = this._getOrReturnCtx(e, s), de(s, {
          validation: "cuid",
          code: ne.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "cuid2")
        yh.test(e.data) || (s = this._getOrReturnCtx(e, s), de(s, {
          validation: "cuid2",
          code: ne.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "ulid")
        vh.test(e.data) || (s = this._getOrReturnCtx(e, s), de(s, {
          validation: "ulid",
          code: ne.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "url")
        try {
          new URL(e.data);
        } catch {
          s = this._getOrReturnCtx(e, s), de(s, {
            validation: "url",
            code: ne.invalid_string,
            message: i.message
          }), n.dirty();
        }
      else
        i.kind === "regex" ? (i.regex.lastIndex = 0, i.regex.test(e.data) || (s = this._getOrReturnCtx(e, s), de(s, {
          validation: "regex",
          code: ne.invalid_string,
          message: i.message
        }), n.dirty())) : i.kind === "trim" ? e.data = e.data.trim() : i.kind === "includes" ? e.data.includes(i.value, i.position) || (s = this._getOrReturnCtx(e, s), de(s, {
          code: ne.invalid_string,
          validation: { includes: i.value, position: i.position },
          message: i.message
        }), n.dirty()) : i.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : i.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : i.kind === "startsWith" ? e.data.startsWith(i.value) || (s = this._getOrReturnCtx(e, s), de(s, {
          code: ne.invalid_string,
          validation: { startsWith: i.value },
          message: i.message
        }), n.dirty()) : i.kind === "endsWith" ? e.data.endsWith(i.value) || (s = this._getOrReturnCtx(e, s), de(s, {
          code: ne.invalid_string,
          validation: { endsWith: i.value },
          message: i.message
        }), n.dirty()) : i.kind === "datetime" ? $h(i).test(e.data) || (s = this._getOrReturnCtx(e, s), de(s, {
          code: ne.invalid_string,
          validation: "datetime",
          message: i.message
        }), n.dirty()) : i.kind === "ip" ? kh(e.data, i.version) || (s = this._getOrReturnCtx(e, s), de(s, {
          validation: "ip",
          code: ne.invalid_string,
          message: i.message
        }), n.dirty()) : Ke.assertNever(i);
    return { status: n.value, value: e.data };
  }
  _regex(e, r, n) {
    return this.refinement((s) => e.test(s), {
      validation: r,
      code: ne.invalid_string,
      ...$e.errToObj(n)
    });
  }
  _addCheck(e) {
    return new rr({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...$e.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...$e.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...$e.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...$e.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...$e.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...$e.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...$e.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...$e.errToObj(e) });
  }
  datetime(e) {
    var r;
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof e?.precision > "u" ? null : e?.precision,
      offset: (r = e?.offset) !== null && r !== void 0 ? r : !1,
      ...$e.errToObj(e?.message)
    });
  }
  regex(e, r) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...$e.errToObj(r)
    });
  }
  includes(e, r) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: r?.position,
      ...$e.errToObj(r?.message)
    });
  }
  startsWith(e, r) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...$e.errToObj(r)
    });
  }
  endsWith(e, r) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...$e.errToObj(r)
    });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...$e.errToObj(r)
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...$e.errToObj(r)
    });
  }
  length(e, r) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...$e.errToObj(r)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(e) {
    return this.min(1, $e.errToObj(e));
  }
  trim() {
    return new rr({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new rr({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new rr({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get minLength() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
}
rr.create = (t) => {
  var e;
  return new rr({
    checks: [],
    typeName: ee.ZodString,
    coerce: (e = t?.coerce) !== null && e !== void 0 ? e : !1,
    ...De(t)
  });
};
function Th(t, e) {
  const r = (t.toString().split(".")[1] || "").length, n = (e.toString().split(".")[1] || "").length, s = r > n ? r : n, i = parseInt(t.toFixed(s).replace(".", "")), a = parseInt(e.toFixed(s).replace(".", ""));
  return i % a / Math.pow(10, s);
}
class zr extends Le {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== le.number) {
      const i = this._getOrReturnCtx(e);
      return de(i, {
        code: ne.invalid_type,
        expected: le.number,
        received: i.parsedType
      }), Ne;
    }
    let n;
    const s = new Nt();
    for (const i of this._def.checks)
      i.kind === "int" ? Ke.isInteger(e.data) || (n = this._getOrReturnCtx(e, n), de(n, {
        code: ne.invalid_type,
        expected: "integer",
        received: "float",
        message: i.message
      }), s.dirty()) : i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (n = this._getOrReturnCtx(e, n), de(n, {
        code: ne.too_small,
        minimum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), s.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (n = this._getOrReturnCtx(e, n), de(n, {
        code: ne.too_big,
        maximum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), s.dirty()) : i.kind === "multipleOf" ? Th(e.data, i.value) !== 0 && (n = this._getOrReturnCtx(e, n), de(n, {
        code: ne.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), s.dirty()) : i.kind === "finite" ? Number.isFinite(e.data) || (n = this._getOrReturnCtx(e, n), de(n, {
        code: ne.not_finite,
        message: i.message
      }), s.dirty()) : Ke.assertNever(i);
    return { status: s.value, value: e.data };
  }
  gte(e, r) {
    return this.setLimit("min", e, !0, $e.toString(r));
  }
  gt(e, r) {
    return this.setLimit("min", e, !1, $e.toString(r));
  }
  lte(e, r) {
    return this.setLimit("max", e, !0, $e.toString(r));
  }
  lt(e, r) {
    return this.setLimit("max", e, !1, $e.toString(r));
  }
  setLimit(e, r, n, s) {
    return new zr({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: r,
          inclusive: n,
          message: $e.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new zr({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: $e.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: $e.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: $e.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: $e.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: $e.toString(e)
    });
  }
  multipleOf(e, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: $e.toString(r)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: $e.toString(e)
    });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: $e.toString(e)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: $e.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && Ke.isInteger(e.value));
  }
  get isFinite() {
    let e = null, r = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return !0;
      n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    }
    return Number.isFinite(r) && Number.isFinite(e);
  }
}
zr.create = (t) => new zr({
  checks: [],
  typeName: ee.ZodNumber,
  coerce: t?.coerce || !1,
  ...De(t)
});
class Wr extends Le {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== le.bigint) {
      const i = this._getOrReturnCtx(e);
      return de(i, {
        code: ne.invalid_type,
        expected: le.bigint,
        received: i.parsedType
      }), Ne;
    }
    let n;
    const s = new Nt();
    for (const i of this._def.checks)
      i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (n = this._getOrReturnCtx(e, n), de(n, {
        code: ne.too_small,
        type: "bigint",
        minimum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), s.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (n = this._getOrReturnCtx(e, n), de(n, {
        code: ne.too_big,
        type: "bigint",
        maximum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), s.dirty()) : i.kind === "multipleOf" ? e.data % i.value !== BigInt(0) && (n = this._getOrReturnCtx(e, n), de(n, {
        code: ne.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), s.dirty()) : Ke.assertNever(i);
    return { status: s.value, value: e.data };
  }
  gte(e, r) {
    return this.setLimit("min", e, !0, $e.toString(r));
  }
  gt(e, r) {
    return this.setLimit("min", e, !1, $e.toString(r));
  }
  lte(e, r) {
    return this.setLimit("max", e, !0, $e.toString(r));
  }
  lt(e, r) {
    return this.setLimit("max", e, !1, $e.toString(r));
  }
  setLimit(e, r, n, s) {
    return new Wr({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: r,
          inclusive: n,
          message: $e.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new Wr({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: $e.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: $e.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: $e.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: $e.toString(e)
    });
  }
  multipleOf(e, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: $e.toString(r)
    });
  }
  get minValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
}
Wr.create = (t) => {
  var e;
  return new Wr({
    checks: [],
    typeName: ee.ZodBigInt,
    coerce: (e = t?.coerce) !== null && e !== void 0 ? e : !1,
    ...De(t)
  });
};
class ns extends Le {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== le.boolean) {
      const n = this._getOrReturnCtx(e);
      return de(n, {
        code: ne.invalid_type,
        expected: le.boolean,
        received: n.parsedType
      }), Ne;
    }
    return xt(e.data);
  }
}
ns.create = (t) => new ns({
  typeName: ee.ZodBoolean,
  coerce: t?.coerce || !1,
  ...De(t)
});
class an extends Le {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== le.date) {
      const i = this._getOrReturnCtx(e);
      return de(i, {
        code: ne.invalid_type,
        expected: le.date,
        received: i.parsedType
      }), Ne;
    }
    if (isNaN(e.data.getTime())) {
      const i = this._getOrReturnCtx(e);
      return de(i, {
        code: ne.invalid_date
      }), Ne;
    }
    const n = new Nt();
    let s;
    for (const i of this._def.checks)
      i.kind === "min" ? e.data.getTime() < i.value && (s = this._getOrReturnCtx(e, s), de(s, {
        code: ne.too_small,
        message: i.message,
        inclusive: !0,
        exact: !1,
        minimum: i.value,
        type: "date"
      }), n.dirty()) : i.kind === "max" ? e.data.getTime() > i.value && (s = this._getOrReturnCtx(e, s), de(s, {
        code: ne.too_big,
        message: i.message,
        inclusive: !0,
        exact: !1,
        maximum: i.value,
        type: "date"
      }), n.dirty()) : Ke.assertNever(i);
    return {
      status: n.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new an({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: $e.toString(r)
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: $e.toString(r)
    });
  }
  get minDate() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
}
an.create = (t) => new an({
  checks: [],
  coerce: t?.coerce || !1,
  typeName: ee.ZodDate,
  ...De(t)
});
class ui extends Le {
  _parse(e) {
    if (this._getType(e) !== le.symbol) {
      const n = this._getOrReturnCtx(e);
      return de(n, {
        code: ne.invalid_type,
        expected: le.symbol,
        received: n.parsedType
      }), Ne;
    }
    return xt(e.data);
  }
}
ui.create = (t) => new ui({
  typeName: ee.ZodSymbol,
  ...De(t)
});
class ss extends Le {
  _parse(e) {
    if (this._getType(e) !== le.undefined) {
      const n = this._getOrReturnCtx(e);
      return de(n, {
        code: ne.invalid_type,
        expected: le.undefined,
        received: n.parsedType
      }), Ne;
    }
    return xt(e.data);
  }
}
ss.create = (t) => new ss({
  typeName: ee.ZodUndefined,
  ...De(t)
});
class is extends Le {
  _parse(e) {
    if (this._getType(e) !== le.null) {
      const n = this._getOrReturnCtx(e);
      return de(n, {
        code: ne.invalid_type,
        expected: le.null,
        received: n.parsedType
      }), Ne;
    }
    return xt(e.data);
  }
}
is.create = (t) => new is({
  typeName: ee.ZodNull,
  ...De(t)
});
class An extends Le {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(e) {
    return xt(e.data);
  }
}
An.create = (t) => new An({
  typeName: ee.ZodAny,
  ...De(t)
});
class nn extends Le {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(e) {
    return xt(e.data);
  }
}
nn.create = (t) => new nn({
  typeName: ee.ZodUnknown,
  ...De(t)
});
class Tr extends Le {
  _parse(e) {
    const r = this._getOrReturnCtx(e);
    return de(r, {
      code: ne.invalid_type,
      expected: le.never,
      received: r.parsedType
    }), Ne;
  }
}
Tr.create = (t) => new Tr({
  typeName: ee.ZodNever,
  ...De(t)
});
class li extends Le {
  _parse(e) {
    if (this._getType(e) !== le.undefined) {
      const n = this._getOrReturnCtx(e);
      return de(n, {
        code: ne.invalid_type,
        expected: le.void,
        received: n.parsedType
      }), Ne;
    }
    return xt(e.data);
  }
}
li.create = (t) => new li({
  typeName: ee.ZodVoid,
  ...De(t)
});
class sr extends Le {
  _parse(e) {
    const { ctx: r, status: n } = this._processInputParams(e), s = this._def;
    if (r.parsedType !== le.array)
      return de(r, {
        code: ne.invalid_type,
        expected: le.array,
        received: r.parsedType
      }), Ne;
    if (s.exactLength !== null) {
      const a = r.data.length > s.exactLength.value, o = r.data.length < s.exactLength.value;
      (a || o) && (de(r, {
        code: a ? ne.too_big : ne.too_small,
        minimum: o ? s.exactLength.value : void 0,
        maximum: a ? s.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: s.exactLength.message
      }), n.dirty());
    }
    if (s.minLength !== null && r.data.length < s.minLength.value && (de(r, {
      code: ne.too_small,
      minimum: s.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: s.minLength.message
    }), n.dirty()), s.maxLength !== null && r.data.length > s.maxLength.value && (de(r, {
      code: ne.too_big,
      maximum: s.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: s.maxLength.message
    }), n.dirty()), r.common.async)
      return Promise.all([...r.data].map((a, o) => s.type._parseAsync(new hr(r, a, r.path, o)))).then((a) => Nt.mergeArray(n, a));
    const i = [...r.data].map((a, o) => s.type._parseSync(new hr(r, a, r.path, o)));
    return Nt.mergeArray(n, i);
  }
  get element() {
    return this._def.type;
  }
  min(e, r) {
    return new sr({
      ...this._def,
      minLength: { value: e, message: $e.toString(r) }
    });
  }
  max(e, r) {
    return new sr({
      ...this._def,
      maxLength: { value: e, message: $e.toString(r) }
    });
  }
  length(e, r) {
    return new sr({
      ...this._def,
      exactLength: { value: e, message: $e.toString(r) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
sr.create = (t, e) => new sr({
  type: t,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: ee.ZodArray,
  ...De(e)
});
function yn(t) {
  if (t instanceof ut) {
    const e = {};
    for (const r in t.shape) {
      const n = t.shape[r];
      e[r] = Sr.create(yn(n));
    }
    return new ut({
      ...t._def,
      shape: () => e
    });
  } else
    return t instanceof sr ? new sr({
      ...t._def,
      type: yn(t.element)
    }) : t instanceof Sr ? Sr.create(yn(t.unwrap())) : t instanceof cn ? cn.create(yn(t.unwrap())) : t instanceof pr ? pr.create(t.items.map((e) => yn(e))) : t;
}
class ut extends Le {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), r = Ke.objectKeys(e);
    return this._cached = { shape: e, keys: r };
  }
  _parse(e) {
    if (this._getType(e) !== le.object) {
      const l = this._getOrReturnCtx(e);
      return de(l, {
        code: ne.invalid_type,
        expected: le.object,
        received: l.parsedType
      }), Ne;
    }
    const { status: n, ctx: s } = this._processInputParams(e), { shape: i, keys: a } = this._getCached(), o = [];
    if (!(this._def.catchall instanceof Tr && this._def.unknownKeys === "strip"))
      for (const l in s.data)
        a.includes(l) || o.push(l);
    const c = [];
    for (const l of a) {
      const f = i[l], h = s.data[l];
      c.push({
        key: { status: "valid", value: l },
        value: f._parse(new hr(s, h, s.path, l)),
        alwaysSet: l in s.data
      });
    }
    if (this._def.catchall instanceof Tr) {
      const l = this._def.unknownKeys;
      if (l === "passthrough")
        for (const f of o)
          c.push({
            key: { status: "valid", value: f },
            value: { status: "valid", value: s.data[f] }
          });
      else if (l === "strict")
        o.length > 0 && (de(s, {
          code: ne.unrecognized_keys,
          keys: o
        }), n.dirty());
      else if (l !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const l = this._def.catchall;
      for (const f of o) {
        const h = s.data[f];
        c.push({
          key: { status: "valid", value: f },
          value: l._parse(
            new hr(s, h, s.path, f)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: f in s.data
        });
      }
    }
    return s.common.async ? Promise.resolve().then(async () => {
      const l = [];
      for (const f of c) {
        const h = await f.key;
        l.push({
          key: h,
          value: await f.value,
          alwaysSet: f.alwaysSet
        });
      }
      return l;
    }).then((l) => Nt.mergeObjectSync(n, l)) : Nt.mergeObjectSync(n, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return $e.errToObj, new ut({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (r, n) => {
          var s, i, a, o;
          const c = (a = (i = (s = this._def).errorMap) === null || i === void 0 ? void 0 : i.call(s, r, n).message) !== null && a !== void 0 ? a : n.defaultError;
          return r.code === "unrecognized_keys" ? {
            message: (o = $e.errToObj(e).message) !== null && o !== void 0 ? o : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new ut({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ut({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e) {
    return new ut({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e) {
    return new ut({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape()
      }),
      typeName: ee.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e, r) {
    return this.augment({ [e]: r });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e) {
    return new ut({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const r = {};
    return Ke.objectKeys(e).forEach((n) => {
      e[n] && this.shape[n] && (r[n] = this.shape[n]);
    }), new ut({
      ...this._def,
      shape: () => r
    });
  }
  omit(e) {
    const r = {};
    return Ke.objectKeys(this.shape).forEach((n) => {
      e[n] || (r[n] = this.shape[n]);
    }), new ut({
      ...this._def,
      shape: () => r
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return yn(this);
  }
  partial(e) {
    const r = {};
    return Ke.objectKeys(this.shape).forEach((n) => {
      const s = this.shape[n];
      e && !e[n] ? r[n] = s : r[n] = s.optional();
    }), new ut({
      ...this._def,
      shape: () => r
    });
  }
  required(e) {
    const r = {};
    return Ke.objectKeys(this.shape).forEach((n) => {
      if (e && !e[n])
        r[n] = this.shape[n];
      else {
        let i = this.shape[n];
        for (; i instanceof Sr; )
          i = i._def.innerType;
        r[n] = i;
      }
    }), new ut({
      ...this._def,
      shape: () => r
    });
  }
  keyof() {
    return gu(Ke.objectKeys(this.shape));
  }
}
ut.create = (t, e) => new ut({
  shape: () => t,
  unknownKeys: "strip",
  catchall: Tr.create(),
  typeName: ee.ZodObject,
  ...De(e)
});
ut.strictCreate = (t, e) => new ut({
  shape: () => t,
  unknownKeys: "strict",
  catchall: Tr.create(),
  typeName: ee.ZodObject,
  ...De(e)
});
ut.lazycreate = (t, e) => new ut({
  shape: t,
  unknownKeys: "strip",
  catchall: Tr.create(),
  typeName: ee.ZodObject,
  ...De(e)
});
class as extends Le {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), n = this._def.options;
    function s(i) {
      for (const o of i)
        if (o.result.status === "valid")
          return o.result;
      for (const o of i)
        if (o.result.status === "dirty")
          return r.common.issues.push(...o.ctx.common.issues), o.result;
      const a = i.map((o) => new nr(o.ctx.common.issues));
      return de(r, {
        code: ne.invalid_union,
        unionErrors: a
      }), Ne;
    }
    if (r.common.async)
      return Promise.all(n.map(async (i) => {
        const a = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await i._parseAsync({
            data: r.data,
            path: r.path,
            parent: a
          }),
          ctx: a
        };
      })).then(s);
    {
      let i;
      const a = [];
      for (const c of n) {
        const l = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        }, f = c._parseSync({
          data: r.data,
          path: r.path,
          parent: l
        });
        if (f.status === "valid")
          return f;
        f.status === "dirty" && !i && (i = { result: f, ctx: l }), l.common.issues.length && a.push(l.common.issues);
      }
      if (i)
        return r.common.issues.push(...i.ctx.common.issues), i.result;
      const o = a.map((c) => new nr(c));
      return de(r, {
        code: ne.invalid_union,
        unionErrors: o
      }), Ne;
    }
  }
  get options() {
    return this._def.options;
  }
}
as.create = (t, e) => new as({
  options: t,
  typeName: ee.ZodUnion,
  ...De(e)
});
const Ks = (t) => t instanceof us ? Ks(t.schema) : t instanceof ar ? Ks(t.innerType()) : t instanceof ls ? [t.value] : t instanceof Hr ? t.options : t instanceof ds ? Object.keys(t.enum) : t instanceof fs ? Ks(t._def.innerType) : t instanceof ss ? [void 0] : t instanceof is ? [null] : null;
class Ri extends Le {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== le.object)
      return de(r, {
        code: ne.invalid_type,
        expected: le.object,
        received: r.parsedType
      }), Ne;
    const n = this.discriminator, s = r.data[n], i = this.optionsMap.get(s);
    return i ? r.common.async ? i._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    }) : i._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }) : (de(r, {
      code: ne.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [n]
    }), Ne);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(e, r, n) {
    const s = /* @__PURE__ */ new Map();
    for (const i of r) {
      const a = Ks(i.shape[e]);
      if (!a)
        throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
      for (const o of a) {
        if (s.has(o))
          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(o)}`);
        s.set(o, i);
      }
    }
    return new Ri({
      typeName: ee.ZodDiscriminatedUnion,
      discriminator: e,
      options: r,
      optionsMap: s,
      ...De(n)
    });
  }
}
function va(t, e) {
  const r = Mr(t), n = Mr(e);
  if (t === e)
    return { valid: !0, data: t };
  if (r === le.object && n === le.object) {
    const s = Ke.objectKeys(e), i = Ke.objectKeys(t).filter((o) => s.indexOf(o) !== -1), a = { ...t, ...e };
    for (const o of i) {
      const c = va(t[o], e[o]);
      if (!c.valid)
        return { valid: !1 };
      a[o] = c.data;
    }
    return { valid: !0, data: a };
  } else if (r === le.array && n === le.array) {
    if (t.length !== e.length)
      return { valid: !1 };
    const s = [];
    for (let i = 0; i < t.length; i++) {
      const a = t[i], o = e[i], c = va(a, o);
      if (!c.valid)
        return { valid: !1 };
      s.push(c.data);
    }
    return { valid: !0, data: s };
  } else
    return r === le.date && n === le.date && +t == +e ? { valid: !0, data: t } : { valid: !1 };
}
class os extends Le {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e), s = (i, a) => {
      if (ga(i) || ga(a))
        return Ne;
      const o = va(i.value, a.value);
      return o.valid ? ((ya(i) || ya(a)) && r.dirty(), { status: r.value, value: o.data }) : (de(n, {
        code: ne.invalid_intersection_types
      }), Ne);
    };
    return n.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }),
      this._def.right._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      })
    ]).then(([i, a]) => s(i, a)) : s(this._def.left._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }), this._def.right._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }));
  }
}
os.create = (t, e, r) => new os({
  left: t,
  right: e,
  typeName: ee.ZodIntersection,
  ...De(r)
});
class pr extends Le {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== le.array)
      return de(n, {
        code: ne.invalid_type,
        expected: le.array,
        received: n.parsedType
      }), Ne;
    if (n.data.length < this._def.items.length)
      return de(n, {
        code: ne.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), Ne;
    !this._def.rest && n.data.length > this._def.items.length && (de(n, {
      code: ne.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), r.dirty());
    const i = [...n.data].map((a, o) => {
      const c = this._def.items[o] || this._def.rest;
      return c ? c._parse(new hr(n, a, n.path, o)) : null;
    }).filter((a) => !!a);
    return n.common.async ? Promise.all(i).then((a) => Nt.mergeArray(r, a)) : Nt.mergeArray(r, i);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new pr({
      ...this._def,
      rest: e
    });
  }
}
pr.create = (t, e) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new pr({
    items: t,
    typeName: ee.ZodTuple,
    rest: null,
    ...De(e)
  });
};
class cs extends Le {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== le.object)
      return de(n, {
        code: ne.invalid_type,
        expected: le.object,
        received: n.parsedType
      }), Ne;
    const s = [], i = this._def.keyType, a = this._def.valueType;
    for (const o in n.data)
      s.push({
        key: i._parse(new hr(n, o, n.path, o)),
        value: a._parse(new hr(n, n.data[o], n.path, o))
      });
    return n.common.async ? Nt.mergeObjectAsync(r, s) : Nt.mergeObjectSync(r, s);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, r, n) {
    return r instanceof Le ? new cs({
      keyType: e,
      valueType: r,
      typeName: ee.ZodRecord,
      ...De(n)
    }) : new cs({
      keyType: rr.create(),
      valueType: e,
      typeName: ee.ZodRecord,
      ...De(r)
    });
  }
}
class di extends Le {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== le.map)
      return de(n, {
        code: ne.invalid_type,
        expected: le.map,
        received: n.parsedType
      }), Ne;
    const s = this._def.keyType, i = this._def.valueType, a = [...n.data.entries()].map(([o, c], l) => ({
      key: s._parse(new hr(n, o, n.path, [l, "key"])),
      value: i._parse(new hr(n, c, n.path, [l, "value"]))
    }));
    if (n.common.async) {
      const o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of a) {
          const l = await c.key, f = await c.value;
          if (l.status === "aborted" || f.status === "aborted")
            return Ne;
          (l.status === "dirty" || f.status === "dirty") && r.dirty(), o.set(l.value, f.value);
        }
        return { status: r.value, value: o };
      });
    } else {
      const o = /* @__PURE__ */ new Map();
      for (const c of a) {
        const l = c.key, f = c.value;
        if (l.status === "aborted" || f.status === "aborted")
          return Ne;
        (l.status === "dirty" || f.status === "dirty") && r.dirty(), o.set(l.value, f.value);
      }
      return { status: r.value, value: o };
    }
  }
}
di.create = (t, e, r) => new di({
  valueType: e,
  keyType: t,
  typeName: ee.ZodMap,
  ...De(r)
});
class on extends Le {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== le.set)
      return de(n, {
        code: ne.invalid_type,
        expected: le.set,
        received: n.parsedType
      }), Ne;
    const s = this._def;
    s.minSize !== null && n.data.size < s.minSize.value && (de(n, {
      code: ne.too_small,
      minimum: s.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: s.minSize.message
    }), r.dirty()), s.maxSize !== null && n.data.size > s.maxSize.value && (de(n, {
      code: ne.too_big,
      maximum: s.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: s.maxSize.message
    }), r.dirty());
    const i = this._def.valueType;
    function a(c) {
      const l = /* @__PURE__ */ new Set();
      for (const f of c) {
        if (f.status === "aborted")
          return Ne;
        f.status === "dirty" && r.dirty(), l.add(f.value);
      }
      return { status: r.value, value: l };
    }
    const o = [...n.data.values()].map((c, l) => i._parse(new hr(n, c, n.path, l)));
    return n.common.async ? Promise.all(o).then((c) => a(c)) : a(o);
  }
  min(e, r) {
    return new on({
      ...this._def,
      minSize: { value: e, message: $e.toString(r) }
    });
  }
  max(e, r) {
    return new on({
      ...this._def,
      maxSize: { value: e, message: $e.toString(r) }
    });
  }
  size(e, r) {
    return this.min(e, r).max(e, r);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
on.create = (t, e) => new on({
  valueType: t,
  minSize: null,
  maxSize: null,
  typeName: ee.ZodSet,
  ...De(e)
});
class Sn extends Le {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== le.function)
      return de(r, {
        code: ne.invalid_type,
        expected: le.function,
        received: r.parsedType
      }), Ne;
    function n(o, c) {
      return oi({
        data: o,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          ai(),
          ts
        ].filter((l) => !!l),
        issueData: {
          code: ne.invalid_arguments,
          argumentsError: c
        }
      });
    }
    function s(o, c) {
      return oi({
        data: o,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          ai(),
          ts
        ].filter((l) => !!l),
        issueData: {
          code: ne.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    const i = { errorMap: r.common.contextualErrorMap }, a = r.data;
    if (this._def.returns instanceof Nn) {
      const o = this;
      return xt(async function(...c) {
        const l = new nr([]), f = await o._def.args.parseAsync(c, i).catch((S) => {
          throw l.addIssue(n(c, S)), l;
        }), h = await Reflect.apply(a, this, f);
        return await o._def.returns._def.type.parseAsync(h, i).catch((S) => {
          throw l.addIssue(s(h, S)), l;
        });
      });
    } else {
      const o = this;
      return xt(function(...c) {
        const l = o._def.args.safeParse(c, i);
        if (!l.success)
          throw new nr([n(c, l.error)]);
        const f = Reflect.apply(a, this, l.data), h = o._def.returns.safeParse(f, i);
        if (!h.success)
          throw new nr([s(f, h.error)]);
        return h.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new Sn({
      ...this._def,
      args: pr.create(e).rest(nn.create())
    });
  }
  returns(e) {
    return new Sn({
      ...this._def,
      returns: e
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, r, n) {
    return new Sn({
      args: e || pr.create([]).rest(nn.create()),
      returns: r || nn.create(),
      typeName: ee.ZodFunction,
      ...De(n)
    });
  }
}
class us extends Le {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
  }
}
us.create = (t, e) => new us({
  getter: t,
  typeName: ee.ZodLazy,
  ...De(e)
});
class ls extends Le {
  _parse(e) {
    if (e.data !== this._def.value) {
      const r = this._getOrReturnCtx(e);
      return de(r, {
        received: r.data,
        code: ne.invalid_literal,
        expected: this._def.value
      }), Ne;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
ls.create = (t, e) => new ls({
  value: t,
  typeName: ee.ZodLiteral,
  ...De(e)
});
function gu(t, e) {
  return new Hr({
    values: t,
    typeName: ee.ZodEnum,
    ...De(e)
  });
}
class Hr extends Le {
  _parse(e) {
    if (typeof e.data != "string") {
      const r = this._getOrReturnCtx(e), n = this._def.values;
      return de(r, {
        expected: Ke.joinValues(n),
        received: r.parsedType,
        code: ne.invalid_type
      }), Ne;
    }
    if (this._def.values.indexOf(e.data) === -1) {
      const r = this._getOrReturnCtx(e), n = this._def.values;
      return de(r, {
        received: r.data,
        code: ne.invalid_enum_value,
        options: n
      }), Ne;
    }
    return xt(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  get Values() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  get Enum() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  extract(e) {
    return Hr.create(e);
  }
  exclude(e) {
    return Hr.create(this.options.filter((r) => !e.includes(r)));
  }
}
Hr.create = gu;
class ds extends Le {
  _parse(e) {
    const r = Ke.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(e);
    if (n.parsedType !== le.string && n.parsedType !== le.number) {
      const s = Ke.objectValues(r);
      return de(n, {
        expected: Ke.joinValues(s),
        received: n.parsedType,
        code: ne.invalid_type
      }), Ne;
    }
    if (r.indexOf(e.data) === -1) {
      const s = Ke.objectValues(r);
      return de(n, {
        received: n.data,
        code: ne.invalid_enum_value,
        options: s
      }), Ne;
    }
    return xt(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
ds.create = (t, e) => new ds({
  values: t,
  typeName: ee.ZodNativeEnum,
  ...De(e)
});
class Nn extends Le {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== le.promise && r.common.async === !1)
      return de(r, {
        code: ne.invalid_type,
        expected: le.promise,
        received: r.parsedType
      }), Ne;
    const n = r.parsedType === le.promise ? r.data : Promise.resolve(r.data);
    return xt(n.then((s) => this._def.type.parseAsync(s, {
      path: r.path,
      errorMap: r.common.contextualErrorMap
    })));
  }
}
Nn.create = (t, e) => new Nn({
  type: t,
  typeName: ee.ZodPromise,
  ...De(e)
});
class ar extends Le {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ee.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e), s = this._def.effect || null, i = {
      addIssue: (a) => {
        de(n, a), a.fatal ? r.abort() : r.dirty();
      },
      get path() {
        return n.path;
      }
    };
    if (i.addIssue = i.addIssue.bind(i), s.type === "preprocess") {
      const a = s.transform(n.data, i);
      return n.common.issues.length ? {
        status: "dirty",
        value: n.data
      } : n.common.async ? Promise.resolve(a).then((o) => this._def.schema._parseAsync({
        data: o,
        path: n.path,
        parent: n
      })) : this._def.schema._parseSync({
        data: a,
        path: n.path,
        parent: n
      });
    }
    if (s.type === "refinement") {
      const a = (o) => {
        const c = s.refinement(o, i);
        if (n.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (n.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return o.status === "aborted" ? Ne : (o.status === "dirty" && r.dirty(), a(o.value), { status: r.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((o) => o.status === "aborted" ? Ne : (o.status === "dirty" && r.dirty(), a(o.value).then(() => ({ status: r.value, value: o.value }))));
    }
    if (s.type === "transform")
      if (n.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        if (!rs(a))
          return a;
        const o = s.transform(a.value, i);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: r.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((a) => rs(a) ? Promise.resolve(s.transform(a.value, i)).then((o) => ({ status: r.value, value: o })) : a);
    Ke.assertNever(s);
  }
}
ar.create = (t, e, r) => new ar({
  schema: t,
  typeName: ee.ZodEffects,
  effect: e,
  ...De(r)
});
ar.createWithPreprocess = (t, e, r) => new ar({
  schema: e,
  effect: { type: "preprocess", transform: t },
  typeName: ee.ZodEffects,
  ...De(r)
});
class Sr extends Le {
  _parse(e) {
    return this._getType(e) === le.undefined ? xt(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Sr.create = (t, e) => new Sr({
  innerType: t,
  typeName: ee.ZodOptional,
  ...De(e)
});
class cn extends Le {
  _parse(e) {
    return this._getType(e) === le.null ? xt(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
cn.create = (t, e) => new cn({
  innerType: t,
  typeName: ee.ZodNullable,
  ...De(e)
});
class fs extends Le {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    let n = r.data;
    return r.parsedType === le.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
fs.create = (t, e) => new fs({
  innerType: t,
  typeName: ee.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ...De(e)
});
class fi extends Le {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), n = {
      ...r,
      common: {
        ...r.common,
        issues: []
      }
    }, s = this._def.innerType._parse({
      data: n.data,
      path: n.path,
      parent: {
        ...n
      }
    });
    return ci(s) ? s.then((i) => ({
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new nr(n.common.issues);
        },
        input: n.data
      })
    })) : {
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new nr(n.common.issues);
        },
        input: n.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
fi.create = (t, e) => new fi({
  innerType: t,
  typeName: ee.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ...De(e)
});
class hi extends Le {
  _parse(e) {
    if (this._getType(e) !== le.nan) {
      const n = this._getOrReturnCtx(e);
      return de(n, {
        code: ne.invalid_type,
        expected: le.nan,
        received: n.parsedType
      }), Ne;
    }
    return { status: "valid", value: e.data };
  }
}
hi.create = (t) => new hi({
  typeName: ee.ZodNaN,
  ...De(t)
});
const Ph = Symbol("zod_brand");
class yu extends Le {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), n = r.data;
    return this._def.type._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Es extends Le {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.common.async)
      return (async () => {
        const i = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return i.status === "aborted" ? Ne : i.status === "dirty" ? (r.dirty(), mu(i.value)) : this._def.out._parseAsync({
          data: i.value,
          path: n.path,
          parent: n
        });
      })();
    {
      const s = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      });
      return s.status === "aborted" ? Ne : s.status === "dirty" ? (r.dirty(), {
        status: "dirty",
        value: s.value
      }) : this._def.out._parseSync({
        data: s.value,
        path: n.path,
        parent: n
      });
    }
  }
  static create(e, r) {
    return new Es({
      in: e,
      out: r,
      typeName: ee.ZodPipeline
    });
  }
}
class pi extends Le {
  _parse(e) {
    const r = this._def.innerType._parse(e);
    return rs(r) && (r.value = Object.freeze(r.value)), r;
  }
}
pi.create = (t, e) => new pi({
  innerType: t,
  typeName: ee.ZodReadonly,
  ...De(e)
});
const vu = (t, e = {}, r) => t ? An.create().superRefine((n, s) => {
  var i, a;
  if (!t(n)) {
    const o = typeof e == "function" ? e(n) : typeof e == "string" ? { message: e } : e, c = (a = (i = o.fatal) !== null && i !== void 0 ? i : r) !== null && a !== void 0 ? a : !0, l = typeof o == "string" ? { message: o } : o;
    s.addIssue({ code: "custom", ...l, fatal: c });
  }
}) : An.create(), Ih = {
  object: ut.lazycreate
};
var ee;
(function(t) {
  t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodSymbol = "ZodSymbol", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodCatch = "ZodCatch", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded", t.ZodPipeline = "ZodPipeline", t.ZodReadonly = "ZodReadonly";
})(ee || (ee = {}));
const Oh = (t, e = {
  message: `Input not instance of ${t.name}`
}) => vu((r) => r instanceof t, e), bu = rr.create, wu = zr.create, Ah = hi.create, Nh = Wr.create, _u = ns.create, Ch = an.create, Rh = ui.create, Dh = ss.create, xh = is.create, Mh = An.create, jh = nn.create, Lh = Tr.create, Uh = li.create, Fh = sr.create, Vh = ut.create, qh = ut.strictCreate, Bh = as.create, zh = Ri.create, Wh = os.create, Hh = pr.create, Zh = cs.create, Kh = di.create, Gh = on.create, Jh = Sn.create, Yh = us.create, Xh = ls.create, Qh = Hr.create, ep = ds.create, tp = Nn.create, nc = ar.create, rp = Sr.create, np = cn.create, sp = ar.createWithPreprocess, ip = Es.create, ap = () => bu().optional(), op = () => wu().optional(), cp = () => _u().optional(), up = {
  string: (t) => rr.create({ ...t, coerce: !0 }),
  number: (t) => zr.create({ ...t, coerce: !0 }),
  boolean: (t) => ns.create({
    ...t,
    coerce: !0
  }),
  bigint: (t) => Wr.create({ ...t, coerce: !0 }),
  date: (t) => an.create({ ...t, coerce: !0 })
}, lp = Ne;
var dp = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: ts,
  setErrorMap: ph,
  getErrorMap: ai,
  makeIssue: oi,
  EMPTY_PATH: mh,
  addIssueToContext: de,
  ParseStatus: Nt,
  INVALID: Ne,
  DIRTY: mu,
  OK: xt,
  isAborted: ga,
  isDirty: ya,
  isValid: rs,
  isAsync: ci,
  get util() {
    return Ke;
  },
  get objectUtil() {
    return ma;
  },
  ZodParsedType: le,
  getParsedType: Mr,
  ZodType: Le,
  ZodString: rr,
  ZodNumber: zr,
  ZodBigInt: Wr,
  ZodBoolean: ns,
  ZodDate: an,
  ZodSymbol: ui,
  ZodUndefined: ss,
  ZodNull: is,
  ZodAny: An,
  ZodUnknown: nn,
  ZodNever: Tr,
  ZodVoid: li,
  ZodArray: sr,
  ZodObject: ut,
  ZodUnion: as,
  ZodDiscriminatedUnion: Ri,
  ZodIntersection: os,
  ZodTuple: pr,
  ZodRecord: cs,
  ZodMap: di,
  ZodSet: on,
  ZodFunction: Sn,
  ZodLazy: us,
  ZodLiteral: ls,
  ZodEnum: Hr,
  ZodNativeEnum: ds,
  ZodPromise: Nn,
  ZodEffects: ar,
  ZodTransformer: ar,
  ZodOptional: Sr,
  ZodNullable: cn,
  ZodDefault: fs,
  ZodCatch: fi,
  ZodNaN: hi,
  BRAND: Ph,
  ZodBranded: yu,
  ZodPipeline: Es,
  ZodReadonly: pi,
  custom: vu,
  Schema: Le,
  ZodSchema: Le,
  late: Ih,
  get ZodFirstPartyTypeKind() {
    return ee;
  },
  coerce: up,
  any: Mh,
  array: Fh,
  bigint: Nh,
  boolean: _u,
  date: Ch,
  discriminatedUnion: zh,
  effect: nc,
  enum: Qh,
  function: Jh,
  instanceof: Oh,
  intersection: Wh,
  lazy: Yh,
  literal: Xh,
  map: Kh,
  nan: Ah,
  nativeEnum: ep,
  never: Lh,
  null: xh,
  nullable: np,
  number: wu,
  object: Vh,
  oboolean: cp,
  onumber: op,
  optional: rp,
  ostring: ap,
  pipeline: ip,
  preprocess: sp,
  promise: tp,
  record: Zh,
  set: Gh,
  strictObject: qh,
  string: bu,
  symbol: Rh,
  transformer: nc,
  tuple: Hh,
  undefined: Dh,
  union: Bh,
  unknown: jh,
  void: Uh,
  NEVER: lp,
  ZodIssueCode: ne,
  quotelessJson: hh,
  ZodError: nr
});
function Eu(t, e, r, n) {
  n?.errorMessages && r && (t.errorMessage = {
    ...t.errorMessage,
    [e]: r
  });
}
function rt(t, e, r, n, s) {
  t[e] = r, Eu(t, e, n, s);
}
const sc = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "string",
  mapStrategy: "entries",
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: !1,
  definitions: {},
  errorMessages: !1,
  markdownDescription: !1,
  patternStrategy: "escape",
  emailStrategy: "format:email"
}, fp = (t) => typeof t == "string" ? {
  ...sc,
  name: t
} : {
  ...sc,
  ...t
};
function hp() {
  return {};
}
function pp(t, e) {
  const r = {
    type: "array"
  };
  return t.type?._def?.typeName !== ee.ZodAny && (r.items = Xe(t.type._def, {
    ...e,
    currentPath: [...e.currentPath, "items"]
  })), t.minLength && rt(r, "minItems", t.minLength.value, t.minLength.message, e), t.maxLength && rt(r, "maxItems", t.maxLength.value, t.maxLength.message, e), t.exactLength && (rt(r, "minItems", t.exactLength.value, t.exactLength.message, e), rt(r, "maxItems", t.exactLength.value, t.exactLength.message, e)), r;
}
function mp(t, e) {
  const r = {
    type: "integer",
    format: "int64"
  };
  if (!t.checks)
    return r;
  for (const n of t.checks)
    switch (n.kind) {
      case "min":
        e.target === "jsonSchema7" ? n.inclusive ? rt(r, "minimum", n.value, n.message, e) : rt(r, "exclusiveMinimum", n.value, n.message, e) : (n.inclusive || (r.exclusiveMinimum = !0), rt(r, "minimum", n.value, n.message, e));
        break;
      case "max":
        e.target === "jsonSchema7" ? n.inclusive ? rt(r, "maximum", n.value, n.message, e) : rt(r, "exclusiveMaximum", n.value, n.message, e) : (n.inclusive || (r.exclusiveMaximum = !0), rt(r, "maximum", n.value, n.message, e));
        break;
      case "multipleOf":
        rt(r, "multipleOf", n.value, n.message, e);
        break;
    }
  return r;
}
function gp() {
  return {
    type: "boolean"
  };
}
function yp(t, e) {
  return Xe(t.type._def, e);
}
const vp = (t, e) => Xe(t.innerType._def, e);
function bp(t, e) {
  return e.dateStrategy == "integer" ? wp(t, e) : {
    type: "string",
    format: "date-time"
  };
}
const wp = (t, e) => {
  const r = {
    type: "integer",
    format: "unix-time"
  };
  for (const n of t.checks)
    switch (n.kind) {
      case "min":
        e.target === "jsonSchema7" && rt(
          r,
          "minimum",
          n.value,
          // This is in milliseconds
          n.message,
          e
        );
        break;
      case "max":
        e.target === "jsonSchema7" && rt(
          r,
          "maximum",
          n.value,
          // This is in milliseconds
          n.message,
          e
        );
        break;
    }
  return r;
};
function _p(t, e) {
  return {
    ...Xe(t.innerType._def, e),
    default: t.defaultValue()
  };
}
function Ep(t, e) {
  return e.effectStrategy === "input" ? Xe(t.schema._def, e) : {};
}
function Sp(t) {
  return {
    type: "string",
    enum: t.values
  };
}
const $p = (t) => "type" in t && t.type === "string" ? !1 : "allOf" in t;
function kp(t, e) {
  const r = [
    Xe(t.left._def, {
      ...e,
      currentPath: [...e.currentPath, "allOf", "0"]
    }),
    Xe(t.right._def, {
      ...e,
      currentPath: [...e.currentPath, "allOf", "1"]
    })
  ].filter((i) => !!i);
  let n = e.target === "jsonSchema2019-09" ? { unevaluatedProperties: !1 } : void 0;
  const s = [];
  return r.forEach((i) => {
    if ($p(i))
      s.push(...i.allOf), i.unevaluatedProperties === void 0 && (n = void 0);
    else {
      let a = i;
      if ("additionalProperties" in i && i.additionalProperties === !1) {
        const { additionalProperties: o, ...c } = i;
        a = c;
      } else
        n = void 0;
      s.push(a);
    }
  }), s.length ? {
    allOf: s,
    ...n
  } : void 0;
}
function Tp(t, e) {
  const r = typeof t.value;
  return r !== "bigint" && r !== "number" && r !== "boolean" && r !== "string" ? {
    type: Array.isArray(t.value) ? "array" : "object"
  } : e.target === "openApi3" ? {
    type: r === "bigint" ? "integer" : r,
    enum: [t.value]
  } : {
    type: r === "bigint" ? "integer" : r,
    const: t.value
  };
}
const Bn = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: "^[cC][^\\s-]{8,}$",
  cuid2: "^[a-z][a-z0-9]*$",
  ulid: "^[0-9A-HJKMNP-TV-Z]{26}$",
  /**
   * `a-z` was added to replicate /i flag
   */
  email: "^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_+-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$",
  emoji: "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
  /**
   * Unused
   */
  uuid: "^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$",
  /**
   * Unused
   */
  ipv4: "^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$",
  /**
   * Unused
   */
  ipv6: "^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$"
};
function Su(t, e) {
  const r = {
    type: "string"
  };
  function n(s) {
    return e.patternStrategy === "escape" ? Pp(s) : s;
  }
  if (t.checks)
    for (const s of t.checks)
      switch (s.kind) {
        case "min":
          rt(r, "minLength", typeof r.minLength == "number" ? Math.max(r.minLength, s.value) : s.value, s.message, e);
          break;
        case "max":
          rt(r, "maxLength", typeof r.maxLength == "number" ? Math.min(r.maxLength, s.value) : s.value, s.message, e);
          break;
        case "email":
          switch (e.emailStrategy) {
            case "format:email":
              Zr(r, "email", s.message, e);
              break;
            case "format:idn-email":
              Zr(r, "idn-email", s.message, e);
              break;
            case "pattern:zod":
              wr(r, Bn.email, s.message, e);
              break;
          }
          break;
        case "url":
          Zr(r, "uri", s.message, e);
          break;
        case "uuid":
          Zr(r, "uuid", s.message, e);
          break;
        case "regex":
          wr(r, s.regex.source, s.message, e);
          break;
        case "cuid":
          wr(r, Bn.cuid, s.message, e);
          break;
        case "cuid2":
          wr(r, Bn.cuid2, s.message, e);
          break;
        case "startsWith":
          wr(r, "^" + n(s.value), s.message, e);
          break;
        case "endsWith":
          wr(r, n(s.value) + "$", s.message, e);
          break;
        case "datetime":
          Zr(r, "date-time", s.message, e);
          break;
        case "length":
          rt(r, "minLength", typeof r.minLength == "number" ? Math.max(r.minLength, s.value) : s.value, s.message, e), rt(r, "maxLength", typeof r.maxLength == "number" ? Math.min(r.maxLength, s.value) : s.value, s.message, e);
          break;
        case "includes": {
          wr(r, n(s.value), s.message, e);
          break;
        }
        case "ip": {
          s.version !== "v6" && Zr(r, "ipv4", s.message, e), s.version !== "v4" && Zr(r, "ipv6", s.message, e);
          break;
        }
        case "emoji":
          wr(r, Bn.emoji, s.message, e);
          break;
        case "ulid": {
          wr(r, Bn.ulid, s.message, e);
          break;
        }
      }
  return r;
}
const Pp = (t) => Array.from(t).map((e) => /[a-zA-Z0-9]/.test(e) ? e : `\\${e}`).join(""), Zr = (t, e, r, n) => {
  t.format || t.anyOf?.some((s) => s.format) ? (t.anyOf || (t.anyOf = []), t.format && (t.anyOf.push({
    format: t.format,
    ...t.errorMessage && n.errorMessages && {
      errorMessage: { format: t.errorMessage.format }
    }
  }), delete t.format, t.errorMessage && (delete t.errorMessage.format, Object.keys(t.errorMessage).length === 0 && delete t.errorMessage)), t.anyOf.push({
    format: e,
    ...r && n.errorMessages && { errorMessage: { format: r } }
  })) : rt(t, "format", e, r, n);
}, wr = (t, e, r, n) => {
  t.pattern || t.allOf?.some((s) => s.pattern) ? (t.allOf || (t.allOf = []), t.pattern && (t.allOf.push({
    pattern: t.pattern,
    ...t.errorMessage && n.errorMessages && {
      errorMessage: { pattern: t.errorMessage.pattern }
    }
  }), delete t.pattern, t.errorMessage && (delete t.errorMessage.pattern, Object.keys(t.errorMessage).length === 0 && delete t.errorMessage)), t.allOf.push({
    pattern: e,
    ...r && n.errorMessages && { errorMessage: { pattern: r } }
  })) : rt(t, "pattern", e, r, n);
};
function $u(t, e) {
  if (e.target === "openApi3" && t.keyType?._def.typeName === ee.ZodEnum)
    return {
      type: "object",
      required: t.keyType._def.values,
      properties: t.keyType._def.values.reduce((n, s) => ({
        ...n,
        [s]: Xe(t.valueType._def, {
          ...e,
          currentPath: [...e.currentPath, "properties", s]
        }) ?? {}
      }), {}),
      additionalProperties: !1
    };
  const r = {
    type: "object",
    additionalProperties: Xe(t.valueType._def, {
      ...e,
      currentPath: [...e.currentPath, "additionalProperties"]
    }) ?? {}
  };
  if (e.target === "openApi3")
    return r;
  if (t.keyType?._def.typeName === ee.ZodString && t.keyType._def.checks?.length) {
    const n = Object.entries(Su(t.keyType._def, e)).reduce((s, [i, a]) => i === "type" ? s : { ...s, [i]: a }, {});
    return {
      ...r,
      propertyNames: n
    };
  } else if (t.keyType?._def.typeName === ee.ZodEnum)
    return {
      ...r,
      propertyNames: {
        enum: t.keyType._def.values
      }
    };
  return r;
}
function Ip(t, e) {
  if (e.mapStrategy === "record")
    return $u(t, e);
  const r = Xe(t.keyType._def, {
    ...e,
    currentPath: [...e.currentPath, "items", "items", "0"]
  }) || {}, n = Xe(t.valueType._def, {
    ...e,
    currentPath: [...e.currentPath, "items", "items", "1"]
  }) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [r, n],
      minItems: 2,
      maxItems: 2
    }
  };
}
function Op(t) {
  const e = t.values, n = Object.keys(t.values).filter((i) => typeof e[e[i]] != "number").map((i) => e[i]), s = Array.from(new Set(n.map((i) => typeof i)));
  return {
    type: s.length === 1 ? s[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: n
  };
}
function Ap() {
  return {
    not: {}
  };
}
function Np(t) {
  return t.target === "openApi3" ? {
    enum: ["null"],
    nullable: !0
  } : {
    type: "null"
  };
}
const mi = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function Cp(t, e) {
  if (e.target === "openApi3")
    return ic(t, e);
  const r = t.options instanceof Map ? Array.from(t.options.values()) : t.options;
  if (r.every((n) => n._def.typeName in mi && (!n._def.checks || !n._def.checks.length))) {
    const n = r.reduce((s, i) => {
      const a = mi[i._def.typeName];
      return a && !s.includes(a) ? [...s, a] : s;
    }, []);
    return {
      type: n.length > 1 ? n : n[0]
    };
  } else if (r.every((n) => n._def.typeName === "ZodLiteral" && !n.description)) {
    const n = r.reduce((s, i) => {
      const a = typeof i._def.value;
      switch (a) {
        case "string":
        case "number":
        case "boolean":
          return [...s, a];
        case "bigint":
          return [...s, "integer"];
        case "object":
          if (i._def.value === null)
            return [...s, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return s;
      }
    }, []);
    if (n.length === r.length) {
      const s = n.filter((i, a, o) => o.indexOf(i) === a);
      return {
        type: s.length > 1 ? s : s[0],
        enum: r.reduce((i, a) => i.includes(a._def.value) ? i : [...i, a._def.value], [])
      };
    }
  } else if (r.every((n) => n._def.typeName === "ZodEnum"))
    return {
      type: "string",
      enum: r.reduce((n, s) => [
        ...n,
        ...s._def.values.filter((i) => !n.includes(i))
      ], [])
    };
  return ic(t, e);
}
const ic = (t, e) => {
  const r = (t.options instanceof Map ? Array.from(t.options.values()) : t.options).map((n, s) => Xe(n._def, {
    ...e,
    currentPath: [...e.currentPath, "anyOf", `${s}`]
  })).filter((n) => !!n && (!e.strictUnions || typeof n == "object" && Object.keys(n).length > 0));
  return r.length ? { anyOf: r } : void 0;
};
function Rp(t, e) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(t.innerType._def.typeName) && (!t.innerType._def.checks || !t.innerType._def.checks.length))
    return e.target === "openApi3" ? {
      type: mi[t.innerType._def.typeName],
      nullable: !0
    } : {
      type: [
        mi[t.innerType._def.typeName],
        "null"
      ]
    };
  if (e.target === "openApi3") {
    const n = Xe(t.innerType._def, {
      ...e,
      currentPath: [...e.currentPath]
    });
    return n && "$ref" in n ? { allOf: [n], nullable: !0 } : n && { ...n, nullable: !0 };
  }
  const r = Xe(t.innerType._def, {
    ...e,
    currentPath: [...e.currentPath, "anyOf", "0"]
  });
  return r && { anyOf: [r, { type: "null" }] };
}
function Dp(t, e) {
  const r = {
    type: "number"
  };
  if (!t.checks)
    return r;
  for (const n of t.checks)
    switch (n.kind) {
      case "int":
        r.type = "integer", Eu(r, "type", n.message, e);
        break;
      case "min":
        e.target === "jsonSchema7" ? n.inclusive ? rt(r, "minimum", n.value, n.message, e) : rt(r, "exclusiveMinimum", n.value, n.message, e) : (n.inclusive || (r.exclusiveMinimum = !0), rt(r, "minimum", n.value, n.message, e));
        break;
      case "max":
        e.target === "jsonSchema7" ? n.inclusive ? rt(r, "maximum", n.value, n.message, e) : rt(r, "exclusiveMaximum", n.value, n.message, e) : (n.inclusive || (r.exclusiveMaximum = !0), rt(r, "maximum", n.value, n.message, e));
        break;
      case "multipleOf":
        rt(r, "multipleOf", n.value, n.message, e);
        break;
    }
  return r;
}
function xp(t, e) {
  const r = {
    type: "object",
    ...Object.entries(t.shape()).reduce((n, [s, i]) => {
      if (i === void 0 || i._def === void 0)
        return n;
      const a = Xe(i._def, {
        ...e,
        currentPath: [...e.currentPath, "properties", s],
        propertyPath: [...e.currentPath, "properties", s]
      });
      return a === void 0 ? n : {
        properties: { ...n.properties, [s]: a },
        required: i.isOptional() ? n.required : [...n.required, s]
      };
    }, { properties: {}, required: [] }),
    additionalProperties: t.catchall._def.typeName === "ZodNever" ? t.unknownKeys === "passthrough" : Xe(t.catchall._def, {
      ...e,
      currentPath: [...e.currentPath, "additionalProperties"]
    }) ?? !0
  };
  return r.required.length || delete r.required, r;
}
const Mp = (t, e) => {
  if (e.currentPath.toString() === e.propertyPath?.toString())
    return Xe(t.innerType._def, e);
  const r = Xe(t.innerType._def, {
    ...e,
    currentPath: [...e.currentPath, "anyOf", "1"]
  });
  return r ? {
    anyOf: [
      {
        not: {}
      },
      r
    ]
  } : {};
}, jp = (t, e) => {
  if (e.pipeStrategy === "input")
    return Xe(t.in._def, e);
  if (e.pipeStrategy === "output")
    return Xe(t.out._def, e);
  const r = Xe(t.in._def, {
    ...e,
    currentPath: [...e.currentPath, "allOf", "0"]
  }), n = Xe(t.out._def, {
    ...e,
    currentPath: [...e.currentPath, "allOf", r ? "1" : "0"]
  });
  return {
    allOf: [r, n].filter((s) => s !== void 0)
  };
};
function Lp(t, e) {
  return Xe(t.type._def, e);
}
function Up(t, e) {
  const n = {
    type: "array",
    uniqueItems: !0,
    items: Xe(t.valueType._def, {
      ...e,
      currentPath: [...e.currentPath, "items"]
    })
  };
  return t.minSize && rt(n, "minItems", t.minSize.value, t.minSize.message, e), t.maxSize && rt(n, "maxItems", t.maxSize.value, t.maxSize.message, e), n;
}
function Fp(t, e) {
  return t.rest ? {
    type: "array",
    minItems: t.items.length,
    items: t.items.map((r, n) => Xe(r._def, {
      ...e,
      currentPath: [...e.currentPath, "items", `${n}`]
    })).reduce((r, n) => n === void 0 ? r : [...r, n], []),
    additionalItems: Xe(t.rest._def, {
      ...e,
      currentPath: [...e.currentPath, "additionalItems"]
    })
  } : {
    type: "array",
    minItems: t.items.length,
    maxItems: t.items.length,
    items: t.items.map((r, n) => Xe(r._def, {
      ...e,
      currentPath: [...e.currentPath, "items", `${n}`]
    })).reduce((r, n) => n === void 0 ? r : [...r, n], [])
  };
}
function Vp() {
  return {
    not: {}
  };
}
function qp() {
  return {};
}
const Bp = (t, e) => Xe(t.innerType._def, e);
function Xe(t, e, r = !1) {
  const n = e.seen.get(t);
  if (n && !r) {
    const a = zp(n, e);
    if (a !== void 0)
      return a;
  }
  const s = { def: t, path: e.currentPath, jsonSchema: void 0 };
  e.seen.set(t, s);
  const i = Hp(t, t.typeName, e);
  return i && Zp(t, e, i), s.jsonSchema = i, i;
}
const zp = (t, e) => {
  switch (e.$refStrategy) {
    case "root":
      return { $ref: t.path.join("/") };
    case "relative":
      return { $ref: Wp(e.currentPath, t.path) };
    case "none":
    case "seen":
      return t.path.length < e.currentPath.length && t.path.every((r, n) => e.currentPath[n] === r) ? (console.warn(`Recursive reference detected at ${e.currentPath.join("/")}! Defaulting to any`), {}) : e.$refStrategy === "seen" ? {} : void 0;
  }
}, Wp = (t, e) => {
  let r = 0;
  for (; r < t.length && r < e.length && t[r] === e[r]; r++)
    ;
  return [(t.length - r).toString(), ...e.slice(r)].join("/");
}, Hp = (t, e, r) => {
  switch (e) {
    case ee.ZodString:
      return Su(t, r);
    case ee.ZodNumber:
      return Dp(t, r);
    case ee.ZodObject:
      return xp(t, r);
    case ee.ZodBigInt:
      return mp(t, r);
    case ee.ZodBoolean:
      return gp();
    case ee.ZodDate:
      return bp(t, r);
    case ee.ZodUndefined:
      return Vp();
    case ee.ZodNull:
      return Np(r);
    case ee.ZodArray:
      return pp(t, r);
    case ee.ZodUnion:
    case ee.ZodDiscriminatedUnion:
      return Cp(t, r);
    case ee.ZodIntersection:
      return kp(t, r);
    case ee.ZodTuple:
      return Fp(t, r);
    case ee.ZodRecord:
      return $u(t, r);
    case ee.ZodLiteral:
      return Tp(t, r);
    case ee.ZodEnum:
      return Sp(t);
    case ee.ZodNativeEnum:
      return Op(t);
    case ee.ZodNullable:
      return Rp(t, r);
    case ee.ZodOptional:
      return Mp(t, r);
    case ee.ZodMap:
      return Ip(t, r);
    case ee.ZodSet:
      return Up(t, r);
    case ee.ZodLazy:
      return Xe(t.getter()._def, r);
    case ee.ZodPromise:
      return Lp(t, r);
    case ee.ZodNaN:
    case ee.ZodNever:
      return Ap();
    case ee.ZodEffects:
      return Ep(t, r);
    case ee.ZodAny:
      return hp();
    case ee.ZodUnknown:
      return qp();
    case ee.ZodDefault:
      return _p(t, r);
    case ee.ZodBranded:
      return yp(t, r);
    case ee.ZodReadonly:
      return Bp(t, r);
    case ee.ZodCatch:
      return vp(t, r);
    case ee.ZodPipeline:
      return jp(t, r);
    case ee.ZodFunction:
    case ee.ZodVoid:
    case ee.ZodSymbol:
      return;
    default:
      return /* @__PURE__ */ ((n) => {
      })();
  }
}, Zp = (t, e, r) => (t.description && (r.description = t.description, e.markdownDescription && (r.markdownDescription = t.description)), r), Kp = (t) => {
  const e = fp(t), r = e.name !== void 0 ? [...e.basePath, e.definitionPath, e.name] : e.basePath;
  return {
    ...e,
    currentPath: r,
    propertyPath: void 0,
    seen: new Map(Object.entries(e.definitions).map(([n, s]) => [
      s._def,
      {
        def: s._def,
        path: [...e.basePath, e.definitionPath, n],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
}, Gp = (t, e) => {
  const r = Kp(e), n = typeof e == "object" && e.definitions ? Object.entries(e.definitions).reduce((o, [c, l]) => ({
    ...o,
    [c]: Xe(l._def, {
      ...r,
      currentPath: [...r.basePath, r.definitionPath, c]
    }, !0) ?? {}
  }), {}) : void 0, s = typeof e == "string" ? e : e?.name, i = Xe(t._def, s === void 0 ? r : {
    ...r,
    currentPath: [...r.basePath, r.definitionPath, s]
  }, !1) ?? {}, a = s === void 0 ? n ? {
    ...i,
    [r.definitionPath]: n
  } : i : {
    $ref: [
      ...r.$refStrategy === "relative" ? [] : r.basePath,
      r.definitionPath,
      s
    ].join("/"),
    [r.definitionPath]: {
      ...n,
      [s]: i
    }
  };
  return r.target === "jsonSchema7" ? a.$schema = "http://json-schema.org/draft-07/schema#" : r.target === "jsonSchema2019-09" && (a.$schema = "https://json-schema.org/draft/2019-09/schema#"), a;
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function ba(t) {
  if (!Jp(t))
    return t;
  const e = Gp(t);
  delete e.$schema;
  const r = (n) => {
    if (n.description) {
      const [s, i] = n.description.split(":", 2);
      n.title = s.trim(), n.description = i.trim();
    }
    n.properties && Object.values(n.properties).forEach((s) => r(s));
  };
  return r(e), e;
}
function ac(t, e) {
  return t.schema && t.schema instanceof dp.ZodType && (t.schema = ba(t.schema)), e(t);
}
function Jp(t) {
  return typeof t?.parse == "function";
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let Gs;
function en() {
  return Gs || (Gs = new gi()), Gs;
}
function oc(t) {
  const e = en();
  return Gs = t, e;
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class gi extends Za {
  #e;
  #t = [];
  parentLambdaNode;
  // TODO:BASE, config of subclasses can have more fields
  constructor(e = {}) {
    super(e), this.#e = e.serialize ?? !1, this.parentLambdaNode = e.parentLambda;
  }
  async serialize(e, r) {
    return super.serialize(e, r && typeof r.unProxy == "function" ? r.unProxy() : r);
  }
  serializing() {
    return this.#e;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  asScopeFor(e) {
    return (...r) => {
      const n = oc(this);
      try {
        return e(...r);
      } finally {
        oc(n);
      }
    };
  }
  addClosureEdge(e) {
    this.#t.push(e);
  }
  getClosureEdges() {
    return this.#t;
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class Yp {
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const ku = Symbol("IsValue");
function vn(t) {
  return (typeof t == "object" || typeof t == "function") && t[ku] !== void 0;
}
class hs extends Yp {
  #e;
  #t;
  #r;
  #n;
  #s;
  constructor(e, r, n, s = !1, i = {}) {
    super(), this.#e = e, this.#t = r, this.#r = typeof n == "string" ? { [n]: n } : n, this[ku] = this, this.#n = s, this.#s = i;
  }
  then(e, r) {
    if (Object.keys(this.#r).length !== 1)
      throw Error("Can't `await` for multiple values");
    return this.#e.then((n) => n && e && this.#t.asScopeFor(e)(n[Object.keys(this.#r)[0]]), r && this.#t.asScopeFor(r));
  }
  asNodeInput() {
    return [this.#e.unProxy(), this.#r, this.#n, this.#s];
  }
  to(e, r) {
    const n = xr(e) ? e.unProxy() : new At(e, this.#t, r);
    return n.addInputsFromNode(this.#e, this.#r, this.#n, this.#s), n.asProxy();
  }
  // This doesn't do any type checking on the inputs.
  //
  // TODO: See whether that's somehow possible. The main problem is that
  // node.<field> is typed for the outputs. We could add a new InputValue type
  // and generate those from node.in().field so that the final syntax could be
  // `toNode.toField.in(fromNode.in().fromField)`.
  //
  // That is, today .in() on a value returns void and in the future it would
  // return that new InputValue type, typed with the right input value from the
  // original node. To accomplish this, we'll have to keep passing the
  // node input values type through the chain of values and .as() statements.
  in(e) {
    let r = Object.fromEntries(Object.entries(this.#r).map(([n, s]) => [s, n]));
    vn(e) ? (r = e.#i(r), this.#e.addInputsFromNode(e.#e, r, e.#n, e.#s)) : xr(e) ? this.#e.addInputsFromNode(e.unProxy(), r) : this.#e.addInputsAsValues(e);
  }
  as(e) {
    let r;
    if (typeof e == "string") {
      if (Object.keys(this.#r).length !== 1)
        throw new Error("Can't rename multiple values with a single string");
      r = { [Object.keys(this.#r)[0]]: e };
    } else
      r = this.#i(e);
    return new hs(this.#e, this.#t, r, this.#n, this.#s);
  }
  memoize() {
    return new hs(this.#e, this.#t, this.#r, !0, this.#s);
  }
  // Create a node for the lambda that is being sent as this value. At this
  // point we can't verify that this actually is a BoardCapability, so we just
  // do it and let the runtime throw an error if this wasn't one.
  invoke(e) {
    return new At("invoke", this.#t, {
      ...e,
      $board: this
    }).asProxy();
  }
  /**
   * The following are type-casting methods that are useful when a node type
   * returns generic types but we want to narrow the types to what we know they
   * are, e.g. a parser node returning the result as raw wires.
   *
   * This is also a way to define the schema of a board, e.g. by casting input
   * wires and what is returned.
   *
   * Use as `foo.asString()` or `foo.asNumber()`. `isArray` and `isObject` cast
   * to generic arrays and objects.
   */
  isUnknown() {
    return delete this.#s.type, this;
  }
  isString() {
    return this.#s.type = "string", this;
  }
  isNumber() {
    return this.#s.type = "number", this;
  }
  isBoolean() {
    return this.#s.type = "boolean", this;
  }
  isArray() {
    return this.#s.type = "array", this;
  }
  isImage(e = "image/png") {
    return this.#s.type = e, this;
  }
  isObject() {
    return this.#s.type = "object", this;
  }
  title(e) {
    return this.#s.title = e, this;
  }
  description(e) {
    return this.#s.description = e, this;
  }
  format(e) {
    return this.#s.format = e, this;
  }
  examples(...e) {
    return this.#s.examples = e, this;
  }
  default(e) {
    return this.#s.default = e, this;
  }
  optional() {
    return this.#s.$optional = !0, this;
  }
  transient() {
    return this.#s.$optional = !0, this;
  }
  #i(e) {
    const r = { ...this.#r };
    return Object.entries(e).forEach(([n, s]) => {
      this.#r[s] ? (r[n] = this.#r[s], delete this.#r[s]) : r[n] = s;
    }), r;
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class At extends tc {
  #e;
  #t;
  #r;
  #n;
  #s;
  constructor(e, r, n = {}) {
    const s = !xr(n) && !(n instanceof Zs) && !js(n) && !vn(n) && n.$id;
    super(e, r, s ? { $id: s } : {}), this.#n = r, typeof e != "string" && (this.#s = e), xr(n) ? this.addInputsFromNode(n.unProxy()) : n instanceof Zs ? this.addInputsFromNode(n) : js(n) ? this.addInputsAsValues({
      $board: n.getBoardCapabilityAsValue()
    }) : vn(n) ? this.addInputsFromNode(...n.asNodeInput()) : (n.$id !== void 0 && delete n.$id, this.addInputsAsValues(n)), this[this.#i()] = this, this.#e = new Promise((i, a) => {
      this.#t = i, this.#r = a;
    });
  }
  addInputsAsValues(e) {
    const r = {}, n = [];
    Object.entries(e).forEach(([s, i]) => {
      js(i) && (i = i.getBoardCapabilityAsValue()), vn(i) ? n.push(i.as(s).asNodeInput()) : i instanceof Zs || xr(i) ? n.push([
        xr(i) ? i.unProxy() : i,
        { [s]: s },
        !1,
        void 0
        // Defers inference of schema from node to serialization
      ]) : r[s] = i;
    }), this.configuration = { ...this.configuration, ...r }, n.forEach((s) => this.unProxy().addInputsFromNode(...s));
  }
  // Add inputs from another node as edges
  addInputsFromNode(e, r = { "*": "" }, n, s) {
    const i = Object.entries(r);
    i.length === 0 ? this.addIncomingEdge(e, "", "", n) : i.forEach(([a, o]) => {
      a.startsWith("*-") && (a = "*", o = ""), this.unProxy().addIncomingEdge(xr(e) ? e.unProxy() : e, a, o, n, s);
    });
  }
  addIncomingEdge(e, r, n, s, i) {
    const a = e.#n;
    if (a === this.#n) {
      super.addIncomingEdge(e, r, n, s, i);
      return;
    }
    for (let o = this.#n; o !== a; o = o.parentLexicalScope)
      if (!o)
        throw new Error("Only wires from parent scopes allowed");
    if (r === "*" || r === "")
      throw new Error("Can't use * or empty wires from parent scopes");
    this.#n.addClosureEdge({
      scope: a,
      from: e,
      to: this,
      out: r,
      in: n
    });
  }
  async invoke(e, r) {
    const n = new gi({
      dynamicScope: r,
      lexicalScope: this.#n
    });
    return n.asScopeFor(async () => {
      try {
        const s = this.#s ?? n.getHandler(this.type);
        let i;
        const a = typeof s == "function" ? s : s?.invoke;
        if (a)
          i = await a(e, this);
        else if (s && typeof s != "function" && s.graph) {
          const o = s.graph.getPinnedNodes();
          if (o.length !== 1)
            throw new Error("Expected exactly one graph");
          i = await n.invokeOneRound(e, o[0]);
        } else
          throw new Error(`Can't find handler for ${this.id}`);
        for (const [o, c] of Object.entries(i))
          c instanceof At ? i[o] = (await c)[o] : vn(c) ? i[o] = await c : js(c) && (i[o] = await c.getBoardCapabilityAsValue());
        return this.#t && (this.#t(i), this.#t = this.#r = void 0), i;
      } catch (s) {
        throw this.#r && (this.#r(s), this.#t = this.#r = void 0), s;
      }
    })();
  }
  // TODO:BASE Special casing the function case (which is most of the code
  // here), everything else is the same, but really just the first few lines
  // here.
  async serializeNode() {
    for (const [h, y] of Object.entries(this.configuration))
      y instanceof Promise && (this.configuration[h] = await y);
    if (this.type !== "fn")
      return super.serializeNode();
    const e = new gi({
      lexicalScope: this.#n,
      serialize: !0
    }), r = this.#s ?? e.getHandler(this.type);
    if (r && typeof r != "function" && r.graph) {
      const h = {
        id: this.id,
        type: "invoke",
        configuration: {
          ...this.configuration,
          path: "#" + this.id
        }
      }, y = r.graph.getPinnedNodes();
      if (y.length !== 1)
        throw new Error("Expected exactly one graph");
      return [h, await e.serialize({}, y[0])];
    }
    const n = typeof r == "function" ? r : r?.invoke;
    if (!n)
      throw new Error(`Handler for ${this.type} in ${this.id} not found`);
    let s = n.toString(), i = this.id.replace(/-/g, "_");
    const a = /(?:async\s*)?(\w+|\([^)]*\))\s*=>\s*/, o = /(?:async\s+)?function\s+(\w+)\s*\(([^)]*)\)\s*\{/;
    if (a.test(s))
      s = s.replace(a, (h, y) => {
        const S = s.trim().startsWith("async") ? "async " : "", E = y.startsWith("(") ? y : `(${y})`;
        return `${S}function ${i}${E} `;
      });
    else {
      const h = o.exec(s);
      if (h === null)
        throw new Error("Unexpected seralization: " + s);
      i = h[1] || i;
    }
    const c = await this.describe(e), l = {
      edges: [
        { from: `${this.id}-input`, to: `${this.id}-run`, out: "*" },
        { from: `${this.id}-run`, to: `${this.id}-output`, out: "*" }
      ],
      nodes: [
        {
          id: `${this.id}-input`,
          type: "input",
          configuration: c?.inputSchema ? { schema: c.inputSchema } : {}
        },
        {
          id: `${this.id}-run`,
          type: "runJavascript",
          configuration: {
            ...this.configuration,
            code: s,
            name: i,
            raw: !0
          }
        },
        {
          id: `${this.id}-output`,
          type: "output",
          configuration: c?.outputSchema ? { schema: c.outputSchema } : {}
        }
      ]
    };
    return [{
      id: this.id,
      type: "invoke",
      configuration: { path: "#" + this.id }
    }, l];
  }
  /**
   * Creates a proxy for a Node that is used when constructing a graph.
   *
   *   const node = originalNode.asProxy();
   *
   * It acts as a Promise for the Node's output by implementing a `then` method:
   *   const output = await node;
   *
   * It acts a proxy for Promises for the Node's output's members.
   *   const field = await node.field;
   *
   * You can still call methods on the Node:
   *   node.to(nextNode);
   *
   * You can do that on output members too:
   *   node.field.to(nextNode);
   *
   * This even works for its methods and `then` and other reserved words:
   *   const to = await node.to;
   *   const thenValue = await node.then; // note: not then()
   *   node.then.to(nextNode); // send the value of `then` to nextNode
   *   node.to.to(nextNode);   // same for the value of `to`.
   *
   *
   * To achieve this, we use a Proxy that creates instances of Value for each
   * requested key, as if it was an output of the node. If there is a method on
   * node with the same name, we return a proxy for that method instead, that
   * forwards all gets to the Value instance. As this includes the `then` method
   * defined on the value, `await node.foo` works, even though `node.foo` is a a
   * function. That it is a function is important for `node.then`, so that the
   * node acts like a Promise as well.
   *
   */
  // TODO: Hack keys() to make spread work
  asProxy() {
    return new Proxy(this, {
      get(e, r, n) {
        if (typeof r == "string") {
          const s = new hs(e, e.#n, r);
          let i = e[r];
          return i && typeof i == "function" ? i = i.bind(e) : i = ((a) => s.invoke(a)).bind(s), new Proxy(i, {
            get(a, o, c) {
              const l = Reflect.get(s, o, s);
              return typeof l == "function" ? l.bind(s) : l;
            },
            ownKeys(a) {
              return Reflect.ownKeys(s).filter((o) => typeof o == "string");
            }
          });
        } else
          return Reflect.get(e, r, n);
      },
      ownKeys(e) {
        return [e.#i()];
      }
    });
  }
  /**
   * Retrieve underlying node from a NodeProxy. Use like this:
   *
   * if (thing instanceof BuilderNode) { const node = thing.unProxy(); }
   *
   * @returns A BuilderNoder that is not a proxy, but the original BuilderNode.
   */
  unProxy() {
    return this;
  }
  /****
   * Implementations of NodeProxyInterface, used for constructing Graphs,
   * typically invoked on this.asProxy().
   */
  /**
   * Makes the node (and its proxy) act as a Promise, which returns the output
   * of the node. This trigger the execution of the graph built up so far.
   *
   * this.#promise is a Promise that gets resolved with the (first and only the
   * first) invoke() call of the node. It is resolved with the outputs.
   */
  then(e, r) {
    if (this.#n.serializing())
      throw new Error(`Can't \`await\` on ${this.id} in board declaration. Did you mean to use \`code\` instead of \`board\`?`);
    try {
      return this.#n.invoke(this).catch((n) => {
        if (r)
          return Promise.reject(n).catch(this.#n.asScopeFor(r));
        throw n;
      }), this.#e.then(e && this.#n.asScopeFor(e), r && this.#n.asScopeFor(r));
    } catch (n) {
      if (r)
        return Promise.reject(n).catch(this.#n.asScopeFor(r));
      throw n;
    }
  }
  to(e, r) {
    const n = xr(e) ? e.unProxy() : new At(e, this.#n, r);
    return n.addInputsFromNode(this, { "*": "" }), n.asProxy();
  }
  // This doesn't do any type checking on the inputs.
  //
  // TODO: See whether that's somehow possible. The main problem is that
  // node.<field> is typed for the outputs. We could add a new InputValue type
  // and generate those from node.in().field so that the final syntax could be
  // - `toNode.in({ toField: fromNode.in().fromField) }` or
  // - `toNode.in({ field: fromNode.in() })`
  //
  // That is, today .in() returns itself, and in with this change, it would
  // return a proxy object typed with the input types.
  in(e) {
    return e instanceof tc ? this.addInputsFromNode(e) : vn(e) ? this.addInputsFromNode(...e.asNodeInput()) : this.addInputsAsValues(e), this.asProxy();
  }
  as(e) {
    return new hs(this, this.#n, e);
  }
  keys() {
    return [this.#i()];
  }
  #i() {
    return "*-" + this.id;
  }
}
function xr(t) {
  return typeof t.unProxy == "function";
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function Ka(t, e) {
  return t && Tu(t, e), (r) => new At(t ?? e, en(), r).asProxy();
}
function Tu(t, e) {
  en().addHandlers({ [t]: e });
}
function xn(t, e = "") {
  const r = new t({}), n = uh(r), s = e ? (i) => i.startsWith(e) ? i.slice(e.length) : i : (i) => i;
  return Object.fromEntries(Object.entries(n).map(([i, a]) => [
    s(i),
    Ka(i, a)
  ]));
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const yi = (t, e) => {
  const r = typeof t == "object" ? t : {};
  return r.graph ??= typeof t == "function" ? t : e, Pu(r);
}, Xp = (t) => Pu({
  invoke: t
});
function Pu(t) {
  if (!t.invoke && !t.graph)
    throw new Error("Missing invoke or graph definition function");
  const e = en(), r = [], { url: n, title: s, description: i, version: a } = t ?? {}, o = {
    ...n ? { url: n } : {},
    ...s ? { title: s } : {},
    ...i ? { description: i } : {},
    ...a ? { version: a } : {}
  }, c = t.input && ba(t.input), l = t.output && ba(t.output), f = {};
  if (t.describe ? f.describe = t.describe : c && l && (f.describe = async () => ({ inputSchema: c, outputSchema: l })), t.invoke && (f.invoke = t.invoke), t.graph) {
    const E = new gi({ lexicalScope: e, serialize: !0 });
    if (E.asScopeFor(() => {
      const A = new At("input", E, c ? { schema: c } : {}), $ = new At("output", E, l ? { schema: l } : {}), x = (w, R) => {
        const z = new At(w, E, R);
        return E.pin(z), z.asProxy();
      }, P = {
        input: x.bind(null, "input"),
        output: x.bind(null, "output")
      }, U = t.graph?.(A.asProxy(), P);
      if (U === void 0)
        return;
      if (U instanceof Promise)
        throw new Error("Graph generation function can't be async");
      let B = $;
      if (U instanceof At) {
        const w = U.unProxy();
        w.type === "output" ? B = w : $.addInputsFromNode(w);
      } else if (typeof U == "object")
        $.addInputsAsValues(U);
      else
        throw new Error(`Unexpected return ${typeof U} value from graph declaration`);
      E.pin(B);
    })(), E.getClosureEdges().length > 0) {
      const A = new At("input", E, {
        $id: "closure-input"
      });
      E.pin(A);
      for (const $ of E.getClosureEdges()) {
        const { to: x, out: P, in: U } = $, B = `$l-${P}-${x.id}`;
        x.addIncomingEdge(A, B, U, !0), r.push({ ...$, to: A, in: B });
      }
    }
    E.compactPins();
    const M = E.getPinnedNodes().length;
    if (M !== 1)
      throw M === 0 ? new Error("If not returning a graph, use `base.input` and `base.output`.") : new Error(`Expected exactly one graph, but got ${M}. Are ${E.getPinnedNodes().map((A) => A.id).join(", ")} maybe disjoint?`);
    f.graph = E;
  }
  let h;
  t.name && Tu(t.name, f);
  const y = (E) => !h || h.incoming.length === 0 && r.length == 0 ? new At(f, en(), E).asProxy() : new At("invoke", en(), {
    ...E,
    $board: h.asProxy().board
  });
  y.serialize = async (E) => {
    const M = new At(f, e), [A, $] = await M.serializeNode();
    if ($) {
      if (A.type !== "invoke")
        throw new Error("Unexpected node with graph");
      return { ...o, ...E, ...$ };
    } else
      return {
        ...o,
        ...E,
        edges: [
          { from: `${A.id}-input`, to: A.id, out: "*" },
          { from: A.id, to: `${A.id}-output`, out: "*" }
        ],
        nodes: [
          {
            id: `${A.id}-input`,
            type: "input",
            configuration: c ? { schema: c } : {}
          },
          A,
          {
            id: `${A.id}-output`,
            type: "output",
            configuration: l ? { schema: l } : {}
          }
        ]
      };
  };
  function S() {
    if (h)
      return h;
    const E = y.serialize();
    return h = new At("lambda", e, {
      board: (async () => ({
        kind: "board",
        board: { kits: [], ...await E }
        // kits: because Runner.fromBoardCapability checks for that.
      }))()
    }), y.serialize = async (M) => h?.incoming.length === 0 && r.length === 0 ? await E : new At("invoke", en(), {
      $board: h?.asProxy().board
    }).serialize({ ...o, ...M }), h;
  }
  y.getBoardCapabilityAsValue = () => h !== void 0 && (h.incoming.length > 0 || r.length > 0) ? h.asProxy().board : (async () => ({
    kind: "board",
    board: { kits: [], ...await y.serialize() }
  }))(), y.unProxy = () => S().unProxy(), y.in = (E) => (S().in(E), y);
  for (const { scope: E, from: M, out: A, in: $ } of r)
    E === e ? S().addIncomingEdge(M, A, $, !0) : e.addClosureEdge({
      scope: E,
      from: M,
      to: S(),
      out: A,
      in: $
    });
  return y;
}
function js(t) {
  return typeof t == "function" && typeof t.getBoardCapabilityAsValue == "function";
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Iu = async () => {
  throw new Error("Reserved word handler should never be invoked");
}, Qp = Ka("input", Iu), em = Ka("output", Iu), Zt = {
  input: (t) => ac(t, Qp),
  output: (t) => ac(t, em)
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class Di {
  graph;
  handlers;
  runner;
  constructor(e) {
    this.graph = e;
  }
  populateDescriptor(e) {
    const { title: r, description: n, version: s } = this.graph;
    return { title: r, description: n, version: s, ...e };
  }
  async #e(e, r = []) {
    const n = await wt.fromGraphDescriptor(this.graph);
    n.url = e, this.handlers = r?.reduce((s, i) => ({ ...s, ...i.handlers }), {}), this.runner = n;
  }
  handlerForNode(e) {
    if (!this.graph)
      throw new Error("Builder was not yet initialized.");
    const { nodes: r } = this.graph, n = r.find((s) => s.id === e);
    if (!n)
      throw new Error(`Node ${e} not found in graph.`);
    return {
      invoke: async (s, i) => {
        const a = n.configuration;
        a && (s = { ...a, ...s });
        const c = {
          ...this.handlers,
          ...Ba(i?.kits || [])
        }?.[n.type];
        if (!c)
          throw new Error(`No handler found for node "${n.type}".`);
        const l = this.runner, f = l.url ? new URL(l.url) : new URL(import.meta.url);
        return console.log("KIT HANDLER", i), En(c, s, {
          ...i,
          outerGraph: l,
          base: f,
          // Add this board's kits, so they are available to subgraphs
          kits: [...i.kits || [], ...l.kits]
        });
      }
    };
  }
  static async create(e, r, n) {
    const s = new Di(e);
    return await s.#e(r, n), s;
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const tm = {
  describe: async (t) => ({
    inputSchema: new Et().addInputs(t).addProperties({
      path: {
        title: "path",
        description: "The path to the board to import.",
        type: "string"
      },
      graph: {
        title: "graph",
        description: "The graph descriptor of the board to import.",
        type: "object"
      }
    }).setAdditionalProperties(!0).build(),
    outputSchema: new Et().addProperties({
      board: {
        title: "board",
        description: "The imported board.",
        type: "object"
      }
    })
  }),
  invoke: async (t, e) => {
    const { path: r, graph: n, ...s } = t, i = e.base || new URL(import.meta.url), a = n ? n.runOnce ? { ...n } : await wt.fromGraphDescriptor(n) : r ? await wt.load(r, {
      base: i,
      outerGraph: e.outerGraph
    }) : void 0;
    if (!a)
      throw Error("No board provided");
    return a.args = s, { board: { kind: "board", board: a } };
  }
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const rm = {
  describe: async (t) => ({
    inputSchema: new Et().setAdditionalProperties(!0).addInputs(t).addProperties({
      path: {
        title: "path",
        description: "The path to the board to include.",
        type: "string"
      },
      $ref: {
        title: "$ref",
        description: "The $ref to the board to include.",
        type: "string"
      },
      graph: {
        title: "graph",
        description: "The graph descriptor of the board to include.",
        type: "object"
      },
      slotted: {
        title: "slotted",
        description: "The slotted graphs to include.",
        type: "object"
      }
    }).build(),
    outputSchema: new Et().setAdditionalProperties(!0).build()
  }),
  invoke: async (t, e) => {
    const { path: r, $ref: n, board: s, graph: i, slotted: a, ...o } = t, c = {};
    if (a)
      for (const y in a)
        c[y] = { url: e.base?.href, ...a[y] };
    const l = r || n || "", f = e.base || new URL(import.meta.url);
    return await (s ? await wt.fromBreadboardCapability(s) : i ? await wt.fromGraphDescriptor(i) : await wt.load(l, {
      slotted: c,
      base: f,
      outerGraph: e.outerGraph
    })).runOnce(o, e);
  }
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const nm = (t) => {
  const e = t.board?.url;
  return e ? new URL(e) : t.base ? t.base : new URL(import.meta.url);
}, Ou = async (t, e) => {
  const r = nm(e), n = e.outerGraph;
  return await wt.load(t, { base: r, outerGraph: n });
}, sm = async (t, e, r, n) => {
  if (r)
    return await wt.fromBreadboardCapability(r);
  if (n)
    return await wt.fromGraphDescriptor(n);
  if (e)
    return await Ou(e, t);
}, im = (t) => {
  const e = t;
  return e && typeof e == "object" && e.kind === "board" && e.board && Au(e.board);
}, Au = (t) => {
  const e = t;
  return e && typeof e == "object" && e.nodes && e.edges && !0;
}, am = {
  describe: async (t) => ({
    inputSchema: new Et().setAdditionalProperties(!0).addInputs(t).addProperties({
      path: {
        title: "path",
        description: "The path to the board to invoke.",
        type: "string"
      },
      board: {
        title: "board",
        description: "The board to invoke, created by `lambda` or `import`",
        type: "BoardCapability"
      },
      graph: {
        title: "graph",
        description: "The graph descriptor of the board to invoke.",
        type: "object"
      },
      $board: {
        title: "board",
        description: "The board to invoke. Can be a BoardCapability, a graph or a URL",
        type: "string"
        // TODO: Make this a union type
      }
    }).build(),
    outputSchema: new Et().setAdditionalProperties(!0).build()
  }),
  invoke: async (t, e) => {
    const { $board: r, ...n } = t;
    if (r) {
      let s;
      if (im(r) && (s = await wt.fromBreadboardCapability(r)), Au(r) && (s = await wt.fromGraphDescriptor(r)), typeof r == "string" ? s = await Ou(r, e) : s = void 0, !s)
        throw new Error("No board provided");
      return await s.runOnce(n, e);
    } else {
      const { path: s, board: i, graph: a, ...o } = t, c = await sm(e, s, i, a);
      if (!c)
        throw new Error("No board provided");
      return await c.runOnce(o, e);
    }
  }
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const om = {
  desribe: async (t) => t ? {
    inputSchema: new Et().addInputs(t).setAdditionalProperties(!0).build(),
    outputSchema: new Et().addInputs(t).build()
  } : {
    inputSchema: Et.empty(!0),
    outputSchema: Et.empty(!0)
  },
  invoke: async (t) => t
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const cm = (t) => JSON.parse(JSON.stringify(t)), um = {
  desribe: async () => ({
    inputSchema: Et.empty(),
    outputSchema: new Et().addProperties({
      graph: {
        title: "graph",
        description: "The graph descriptor of the current board.",
        type: "object"
      }
    }).setAdditionalProperties(!1).addRequired("graph").build()
  }),
  invoke: async (t, e) => ({ graph: e.board ? cm(e.board) : {} })
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const lm = {
  describe: async (t) => ({
    inputSchema: new Et().setAdditionalProperties(!0).addInputs(t).addProperty("slot", {
      title: "slot",
      description: "The slot to run.",
      type: "string"
    }).build(),
    outputSchema: new Et().setAdditionalProperties(!0).build()
  }),
  invoke: async (t, e) => {
    const { slot: r, ...n } = t;
    if (!r)
      throw new Error("To use a slot, we need to specify its name");
    const s = e.slots && e.slots[r];
    if (!s)
      throw new Error(`No graph found for slot "${r}"`);
    return await (await wt.fromGraphDescriptor(s)).runOnce(n, e);
  }
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const dm = async (t, e) => {
  const { list: r, board: n } = t;
  if (!Array.isArray(r))
    throw new Error(`Expected list to be an array, but got ${r}`);
  if (!n)
    return { list: r };
  const s = await Gt.fromBreadboardCapability(n);
  return { list: await Promise.all(r.map(async (a, o) => {
    const c = {
      ...e,
      invocationPath: [...e?.invocationPath || [], o]
    };
    return await s.runOnce({ item: a, index: o, list: r }, c);
  })) };
};
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const fm = async (t, e) => {
  const { list: r, board: n, accumulator: s } = t;
  if (!Array.isArray(r))
    throw new Error(`Expected list to be an array, but got ${r}`);
  if (!n)
    return { accumulator: s };
  const i = await Gt.fromBreadboardCapability(n);
  let a = s, o = 0;
  for (const c of r) {
    const l = {
      ...e,
      invocationPath: [...e?.invocationPath || [], o++]
    }, { accumulator: f } = await i.runOnce({ item: c, accumulator: a }, l);
    a = f;
  }
  return { accumulator: a };
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const hm = async (t) => {
  const { list: e, size: r } = t;
  if (!e)
    throw new Error("Batcher requires `list` input");
  if (!r)
    throw new Error("Batcher requires `size` input");
  if (!e.length)
    return { list: [[]] };
  const n = [];
  for (let s = 0; s < e.length; s += r)
    n.push(e.slice(s, s + r));
  return { list: n };
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var Kt;
(function(t) {
  t[t.stringy = 0] = "stringy", t[t.array = 1] = "array", t[t.object = 2] = "object";
})(Kt || (Kt = {}));
const vi = (t) => {
  if (t == null)
    return Kt.stringy;
  const e = typeof t;
  return ["string", "number", "boolean", "bigint"].includes(e) ? Kt.stringy : Array.isArray(t) ? Kt.array : Kt.object;
}, pm = (t) => vi(t) == Kt.stringy ? String(t) : Object.entries(t).map(([e, r]) => {
  const n = vi(r) === Kt.stringy ? r : JSON.stringify(r);
  return `${e}: ${n}`;
}).join(`
`), mm = (t) => {
  const e = {
    accumulator: {
      title: "accumulator",
      description: "A string, an object, or an array to which other input values will be appended.",
      type: ["array", "object", "string"],
      items: { type: "string" }
    }
  }, r = { properties: e, additionalProperties: !0 };
  return t.properties && Object.entries(t.properties).forEach(([n, s]) => {
    e[n] = s;
  }), r;
}, gm = (t) => {
  let e = {};
  return Object.entries(t).forEach(([r, n]) => {
    r === "$flatten" && vi(n) == Kt.object ? e = { ...e, ...n } : e[r] = n;
  }), e;
}, ym = async (t, e) => ({
  inputSchema: mm(e || {}),
  outputSchema: {
    properties: {
      accumulator: {
        title: "accumulator",
        description: "The result of appending. This is input `accumulator` with the provided values appended to it."
      }
    }
  }
}), vm = {
  describe: ym,
  invoke: async (t) => {
    const { accumulator: e, ...r } = t;
    if (Object.keys(r).length === 0)
      return { accumulator: e };
    switch (vi(e)) {
      case Kt.stringy:
        return { accumulator: `${e == null ? "" : `${e}
`}${pm(r)}` };
      case Kt.array: {
        const s = gm(r);
        return {
          accumulator: [...e, s]
        };
      }
      case Kt.object:
        return {
          accumulator: {
            ...e,
            ...r
          }
        };
    }
  }
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const bm = () => new TransformStream({
  transform(t, e) {
    const n = t.toString().split(`
`);
    for (const s of n)
      if (s.startsWith("data: ")) {
        const i = s.slice(6);
        let a;
        try {
          if (i === "[DONE]")
            continue;
          a = JSON.parse(i);
        } catch {
          a = i;
        }
        e.enqueue(a);
      }
  }
}), wm = async () => ({
  inputSchema: {
    type: "object",
    properties: {
      url: {
        title: "url",
        description: "The URL to fetch",
        type: "string"
      },
      method: {
        title: "method",
        description: "The HTTP method to use",
        type: "string",
        enum: ["GET", "POST", "PUT", "DELETE"]
      },
      headers: {
        title: "headers",
        description: "Headers to send with the request",
        type: "object",
        additionalProperties: {
          type: "string"
        }
      },
      body: {
        title: "body",
        description: "The body of the request",
        type: ["string", "object"]
      },
      raw: {
        title: "raw",
        description: "Whether or not to return raw text (as opposed to parsing JSON)",
        type: "boolean"
      }
    },
    required: ["url"]
  },
  outputSchema: {
    type: "object",
    properties: {
      response: {
        title: "response",
        description: "The response from the fetch request",
        type: ["string", "object"]
      }
    },
    required: ["response"]
  }
}), _m = {
  describe: wm,
  invoke: async (t) => {
    const { url: e, method: r = "GET", body: n, headers: s = {}, raw: i, stream: a } = t;
    if (!e)
      throw new Error("Fetch requires `url` input");
    const o = {
      method: r,
      headers: s
    };
    r !== "GET" && (o.body = JSON.stringify(n));
    const c = await fetch(e, o);
    if (!c.ok)
      return {
        $error: await c.json()
      };
    if (a) {
      if (!c.body)
        throw new Error("Response is not streamable.");
      return {
        stream: new Ci(c.body.pipeThrough(new TextDecoderStream()).pipeThrough(bm()))
      };
    } else
      return { response: i ? await c.text() : await c.json() };
  }
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Em = (t) => t.replace(/(?:```(?:js|javascript)?\n+)(.*)(?:\n+```)/gms, "$1"), Sm = () => typeof globalThis.process < "u" ? "node" : typeof globalThis.window < "u" ? "browser" : "worker", $m = async ({ code: t, functionName: e, args: r }) => {
  let n;
  typeof require == "function" ? n = require("node:vm") : n = await import(
    /*@vite-ignore*/
    "./__vite-browser-external-jWVCDlBL.js"
  );
  const s = `${t}
${e}(${r});`, i = n.createContext({ console }), o = await new n.Script(s).runInNewContext(i);
  return JSON.stringify(o);
}, km = async ({ code: t, functionName: e, args: r }) => {
  const n = (o, c) => `${o}
self.onmessage = () => self.postMessage({ result: JSON.stringify(${c}(${r})) });self.onerror = (e) => self.postMessage({ error: e.message })`, s = new Blob([n(t, e)], {
    type: "text/javascript"
  }), i = new Worker(URL.createObjectURL(s)), a = new Promise((o, c) => {
    i.onmessage = (l) => {
      const f = l.data;
      if (f.result) {
        o(f.result);
        return;
      } else
        f.error && c(new Error(f.error));
    }, i.onerror = (l) => {
      c(new Error(l.message));
    };
  });
  return i.postMessage("please"), a;
};
function Tm({ funcStr: t, name: e = Nu, throwOnNameMismatch: r = !1 }) {
  const n = /^\s*((?:\((?:.|\n)*?\)|\w+)\s*=>\s*((?:.|\n)*))$/, s = /^\s*function\s+[A-Za-z0-9_$]+\s*\(/, i = /^\s*function\s*\(/;
  if (n.test(t)) {
    let [a, o] = t.split("=>").map((c) => c.trim());
    return a.startsWith("(") || (a = `(${a})`), o.startsWith("{") || (o = `{ return ${o}; }`), `function ${e}${a} ${o}`;
  } else if (s.test(t)) {
    if (r) {
      const a = t.match(/function\s+([A-Za-z0-9_$]+)\s*\(/), o = a ? a[1] : null;
      if (o !== e)
        throw new Error(`Function name mismatch: ${o} !== ${e}`);
    }
    return t.replace(s, `function ${e}(`);
  } else
    return i.test(t) ? t.replace(i, `function ${e}(`) : (console.warn(`Unrecognized function format: ${t}`), t);
}
const Nu = "run", Pm = async ({ code: t, name: e, raw: r, ...n }) => {
  if (!t)
    throw new Error("Running JavaScript requires `code` input");
  t = Em(t), e ??= Nu, t = Tm({ funcStr: t, name: e });
  const s = JSON.stringify(n), i = Sm();
  try {
    const a = JSON.parse(i === "node" ? await $m({ code: t, functionName: e, args: s }) : await km({ code: t, functionName: e, args: s }));
    return r ? a : { result: a };
  } catch (a) {
    const o = a.stack;
    return o !== void 0 && (a.stack = o.split(`
`).filter((c) => !c.startsWith("    at") || c.includes("evalmachine.<anonymous>")).join(`
`)), { $error: { kind: "error", error: a } };
  }
}, Im = (t) => !t || !t.raw ? {
  type: "object",
  properties: {
    result: {
      title: "result",
      description: "The result of running the JavaScript code",
      type: ["string", "object"]
    }
  },
  required: ["result"]
} : {
  type: "object",
  additionalProperties: !0
}, Om = (t) => {
  if (!t)
    return {};
  const { code: e, name: r, raw: n, ...s } = t;
  return s;
}, Am = async (t, e) => ({
  inputSchema: {
    type: "object",
    properties: {
      code: {
        title: "code",
        description: "The JavaScript code to run",
        type: "string"
      },
      name: {
        title: "name",
        description: 'The name of the function to invoke in the supplied code. Default value is "run".',
        type: "string",
        default: "run"
      },
      raw: {
        title: "raw",
        description: "Whether or not to return use the result of execution as raw output (true) or as a port called `result` (false). Default is false.",
        type: "boolean"
      },
      ...Om(e?.properties || {})
    },
    required: ["code"],
    additionalProperties: !0
  },
  outputSchema: Im(t || {})
}), Nm = {
  describe: Am,
  invoke: Pm
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Cm = () => typeof globalThis.process < "u" ? "node" : typeof globalThis.window < "u" ? "browser" : "worker", Rm = async (t) => {
  const e = Cm();
  if (e === "node")
    return process.env[t];
  if (e === "browser")
    return globalThis.localStorage.getItem(t);
  if (e === "worker")
    throw new Error("Secrets are not yet supported in workers. Please proxy these nodes to the main thread.");
}, Dm = (t, e) => {
  if (!e)
    throw new Error(`Key "${t}" was not specified. Please check your environment and make sure it is set.`);
  return e;
}, xm = async (t) => {
  const { keys: e } = t || {}, r = e ? Object.fromEntries(e.map((n) => [
    n,
    {
      title: n
    }
  ])) : {};
  return {
    inputSchema: {
      properties: {
        keys: {
          title: "secrets",
          description: "The array of secrets to retrieve from the node.",
          type: "array",
          items: {
            type: "string"
          }
        }
      }
    },
    outputSchema: {
      properties: r
    }
  };
}, Mm = {
  describe: xm,
  invoke: async (t) => {
    const { keys: e = [] } = t;
    return Object.fromEntries(await Promise.all(e.map(async (r) => [
      r,
      Dm(r, await Rm(r))
    ])));
  }
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const jm = new gr({
  title: "Core Kit",
  description: "A Breadboard kit that enables composition and reuse of boards",
  version: "0.0.1",
  url: "npm:@google-labs/core-kit"
}), Ir = jm.build({
  /**
   * Places an `import` node on the board.
   *
   * Use this node to import other boards into the current board.
   * Outputs `board` as a BoardCapability, which can be passed to e.g. `invoke`.
   *
   * The config param expects either `path` or `graph` as a string or
   * `GraphDescriptor', respectively.
   *
   * @param config - optional configuration for the node.
   * @returns - a `Node` object that represents the placed node.
   */
  import: tm,
  /**
   * Places an `include` node on the board.
   *
   * Use this node to include other boards into the current board.
   *
   * The `include` node acts as a sort of instant board-to-node converter: just
   * give it the URL of a serialized board, and it will pretend as if that whole
   * board is just one node.
   *
   * See [`include` node
   * reference](https://github.com/breadboard-ai/breadboard/blob/main/packages/breadboard/docs/nodes.md#include)
   * for more information.
   *
   * @param $ref - the URL of the board to include, or a graph or a
   *   BreadboardCapability returned by e.g. lambda.
   * @param config - optional configuration for the node.
   * @returns - a `Node` object that represents the placed node.
   */
  include: rm,
  /**
   * Places an `invoke` node on the board.
   *
   * Use this node to invoke other boards into the current board.
   *
   * See [`include` node
   * reference](https://github.com/breadboard-ai/breadboard/blob/main/packages/breadboard/docs/nodes.md#include)
   * for more information.
   *
   * Expects as input one of
   *  - `path`: A board to be loaded
   *  - `graph`: A graph (treated as JSON)
   *  - `board`: A {BreadboardCapability}, e.g. from lambda or import
   *
   * All other inputs are passed to the invoked board,
   * and the output are the invoked board's outputs.
   *
   * @param config - optional configuration for the node.
   * @returns - a `Node` object that represents the placed node.
   */
  invoke: am,
  /**
   * Places the `passthrough` node on the board.
   *
   * A `passthrough` node is a node that simply passes its inputs to
   * its outputs. Every computing machine needs a no-op node,
   * and Breadboard library is no exception.
   *
   * See [`passthrough` node reference](https://github.com/breadboard-ai/breadboard/blob/main/packages/breadboard/docs/nodes.md#passthrough) for more information.
   *
   * @param config - optional configuration for the node.
   * @returns - a `Node` object that represents the placed node.
   */
  passthrough: om,
  /**
   * Places a `reflect` node on the board.
   *
   * This node is used to reflect the board itself. It provides a JSON
   * representation of the board as a `graph` output property. This can be
   * used for studying the board's structure from inside the board.
   *
   * See [`reflect` node reference](https://github.com/breadboard-ai/breadboard/blob/main/packages/breadboard/docs/nodes.md#reflect) for more information.
   *
   * @param config - optional configuration for the node.
   * @returns - a `Node` object that represents the placed node.
   */
  reflect: um,
  /**
   * Places a `slot` node on the board.
   *
   * This node is used to provide a slot for another board to be placed into.
   *
   * This type of node is useful for situations where we wish to leave
   * a place in the board where anyone could insert other boards.
   *
   * Programmers call it "dependency injection".
   *
   * See [`slot` node reference](https://github.com/breadboard-ai/breadboard/blob/main/packages/breadboard/docs/nodes.md#slot) for more information.
   *
   * @param config - optional configuration for the node.
   * @returns - a `Node` object that represents the placed node.
   */
  slot: lm,
  /**
   * Use this node to accumulate local state, like context in a prompt.
   *
   * The node looks for property called `accumulator` in its input. All other
   * properties are appended to this property, and returned as `accumulator`
   * output property.
   *
   * The way the properties are appended depends on the type of the
   * `accumulator` input property.
   *
   * If the `accumulator` property is "string-ey" (that is, it's a `string`,
   * `number`, `boolean`, `bigint`, `null` or `undefined`), the properties will
   * be appended as strings, formatted as
   * `{{property_name}}: {{proprety_value}}` and joined with "`\n`".
   *
   * If the `accumulator` property is an array, the properties will be appended
   * as array items, formatted as `{{property_name}}: {{proprety_value}}`.
   *
   * Otherwise, the `accumulator` property will be treated as an object and
   * the properties will be added as properties on this object.
   *
   * See [`append` node reference](https://github.com/breadboard-ai/breadboard/blob/main/packages/core-kit/README.md) for more information.
   *
   */
  append: vm,
  /**
   * Work-in-progress implementation of the `map` node.
   * See #127 for more information.
   */
  map: dm,
  reduce: fm,
  batch: hm,
  fetch: _m,
  runJavascript: Nm,
  secrets: Mm
}), $n = xn(Ir);
var wa = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Cu(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var _a = { exports: {} }, Ru = {}, ir = {}, Cn = {}, Ss = {}, qe = {}, ps = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.regexpCode = t.getEsmExportName = t.getProperty = t.safeStringify = t.stringify = t.strConcat = t.addCodeArg = t.str = t._ = t.nil = t._Code = t.Name = t.IDENTIFIER = t._CodeOrName = void 0;
  class e {
  }
  t._CodeOrName = e, t.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class r extends e {
    constructor(x) {
      if (super(), !t.IDENTIFIER.test(x))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = x;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return !1;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  t.Name = r;
  class n extends e {
    constructor(x) {
      super(), this._items = typeof x == "string" ? [x] : x;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return !1;
      const x = this._items[0];
      return x === "" || x === '""';
    }
    get str() {
      var x;
      return (x = this._str) !== null && x !== void 0 ? x : this._str = this._items.reduce((P, U) => `${P}${U}`, "");
    }
    get names() {
      var x;
      return (x = this._names) !== null && x !== void 0 ? x : this._names = this._items.reduce((P, U) => (U instanceof r && (P[U.str] = (P[U.str] || 0) + 1), P), {});
    }
  }
  t._Code = n, t.nil = new n("");
  function s($, ...x) {
    const P = [$[0]];
    let U = 0;
    for (; U < x.length; )
      o(P, x[U]), P.push($[++U]);
    return new n(P);
  }
  t._ = s;
  const i = new n("+");
  function a($, ...x) {
    const P = [S($[0])];
    let U = 0;
    for (; U < x.length; )
      P.push(i), o(P, x[U]), P.push(i, S($[++U]));
    return c(P), new n(P);
  }
  t.str = a;
  function o($, x) {
    x instanceof n ? $.push(...x._items) : x instanceof r ? $.push(x) : $.push(h(x));
  }
  t.addCodeArg = o;
  function c($) {
    let x = 1;
    for (; x < $.length - 1; ) {
      if ($[x] === i) {
        const P = l($[x - 1], $[x + 1]);
        if (P !== void 0) {
          $.splice(x - 1, 3, P);
          continue;
        }
        $[x++] = "+";
      }
      x++;
    }
  }
  function l($, x) {
    if (x === '""')
      return $;
    if ($ === '""')
      return x;
    if (typeof $ == "string")
      return x instanceof r || $[$.length - 1] !== '"' ? void 0 : typeof x != "string" ? `${$.slice(0, -1)}${x}"` : x[0] === '"' ? $.slice(0, -1) + x.slice(1) : void 0;
    if (typeof x == "string" && x[0] === '"' && !($ instanceof r))
      return `"${$}${x.slice(1)}`;
  }
  function f($, x) {
    return x.emptyStr() ? $ : $.emptyStr() ? x : a`${$}${x}`;
  }
  t.strConcat = f;
  function h($) {
    return typeof $ == "number" || typeof $ == "boolean" || $ === null ? $ : S(Array.isArray($) ? $.join(",") : $);
  }
  function y($) {
    return new n(S($));
  }
  t.stringify = y;
  function S($) {
    return JSON.stringify($).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  t.safeStringify = S;
  function E($) {
    return typeof $ == "string" && t.IDENTIFIER.test($) ? new n(`.${$}`) : s`[${$}]`;
  }
  t.getProperty = E;
  function M($) {
    if (typeof $ == "string" && t.IDENTIFIER.test($))
      return new n(`${$}`);
    throw new Error(`CodeGen: invalid export name: ${$}, use explicit $id name mapping`);
  }
  t.getEsmExportName = M;
  function A($) {
    return new n($.toString());
  }
  t.regexpCode = A;
})(ps);
var Ea = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.ValueScope = t.ValueScopeName = t.Scope = t.varKinds = t.UsedValueState = void 0;
  const e = ps;
  class r extends Error {
    constructor(l) {
      super(`CodeGen: "code" for ${l} not defined`), this.value = l.value;
    }
  }
  var n;
  (function(c) {
    c[c.Started = 0] = "Started", c[c.Completed = 1] = "Completed";
  })(n = t.UsedValueState || (t.UsedValueState = {})), t.varKinds = {
    const: new e.Name("const"),
    let: new e.Name("let"),
    var: new e.Name("var")
  };
  class s {
    constructor({ prefixes: l, parent: f } = {}) {
      this._names = {}, this._prefixes = l, this._parent = f;
    }
    toName(l) {
      return l instanceof e.Name ? l : this.name(l);
    }
    name(l) {
      return new e.Name(this._newName(l));
    }
    _newName(l) {
      const f = this._names[l] || this._nameGroup(l);
      return `${l}${f.index++}`;
    }
    _nameGroup(l) {
      var f, h;
      if (!((h = (f = this._parent) === null || f === void 0 ? void 0 : f._prefixes) === null || h === void 0) && h.has(l) || this._prefixes && !this._prefixes.has(l))
        throw new Error(`CodeGen: prefix "${l}" is not allowed in this scope`);
      return this._names[l] = { prefix: l, index: 0 };
    }
  }
  t.Scope = s;
  class i extends e.Name {
    constructor(l, f) {
      super(f), this.prefix = l;
    }
    setValue(l, { property: f, itemIndex: h }) {
      this.value = l, this.scopePath = (0, e._)`.${new e.Name(f)}[${h}]`;
    }
  }
  t.ValueScopeName = i;
  const a = (0, e._)`\n`;
  class o extends s {
    constructor(l) {
      super(l), this._values = {}, this._scope = l.scope, this.opts = { ...l, _n: l.lines ? a : e.nil };
    }
    get() {
      return this._scope;
    }
    name(l) {
      return new i(l, this._newName(l));
    }
    value(l, f) {
      var h;
      if (f.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const y = this.toName(l), { prefix: S } = y, E = (h = f.key) !== null && h !== void 0 ? h : f.ref;
      let M = this._values[S];
      if (M) {
        const x = M.get(E);
        if (x)
          return x;
      } else
        M = this._values[S] = /* @__PURE__ */ new Map();
      M.set(E, y);
      const A = this._scope[S] || (this._scope[S] = []), $ = A.length;
      return A[$] = f.ref, y.setValue(f, { property: S, itemIndex: $ }), y;
    }
    getValue(l, f) {
      const h = this._values[l];
      if (h)
        return h.get(f);
    }
    scopeRefs(l, f = this._values) {
      return this._reduceValues(f, (h) => {
        if (h.scopePath === void 0)
          throw new Error(`CodeGen: name "${h}" has no value`);
        return (0, e._)`${l}${h.scopePath}`;
      });
    }
    scopeCode(l = this._values, f, h) {
      return this._reduceValues(l, (y) => {
        if (y.value === void 0)
          throw new Error(`CodeGen: name "${y}" has no value`);
        return y.value.code;
      }, f, h);
    }
    _reduceValues(l, f, h = {}, y) {
      let S = e.nil;
      for (const E in l) {
        const M = l[E];
        if (!M)
          continue;
        const A = h[E] = h[E] || /* @__PURE__ */ new Map();
        M.forEach(($) => {
          if (A.has($))
            return;
          A.set($, n.Started);
          let x = f($);
          if (x) {
            const P = this.opts.es5 ? t.varKinds.var : t.varKinds.const;
            S = (0, e._)`${S}${P} ${$} = ${x};${this.opts._n}`;
          } else if (x = y?.($))
            S = (0, e._)`${S}${x}${this.opts._n}`;
          else
            throw new r($);
          A.set($, n.Completed);
        });
      }
      return S;
    }
  }
  t.ValueScope = o;
})(Ea);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.or = t.and = t.not = t.CodeGen = t.operators = t.varKinds = t.ValueScopeName = t.ValueScope = t.Scope = t.Name = t.regexpCode = t.stringify = t.getProperty = t.nil = t.strConcat = t.str = t._ = void 0;
  const e = ps, r = Ea;
  var n = ps;
  Object.defineProperty(t, "_", { enumerable: !0, get: function() {
    return n._;
  } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
    return n.str;
  } }), Object.defineProperty(t, "strConcat", { enumerable: !0, get: function() {
    return n.strConcat;
  } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
    return n.nil;
  } }), Object.defineProperty(t, "getProperty", { enumerable: !0, get: function() {
    return n.getProperty;
  } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
    return n.stringify;
  } }), Object.defineProperty(t, "regexpCode", { enumerable: !0, get: function() {
    return n.regexpCode;
  } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
    return n.Name;
  } });
  var s = Ea;
  Object.defineProperty(t, "Scope", { enumerable: !0, get: function() {
    return s.Scope;
  } }), Object.defineProperty(t, "ValueScope", { enumerable: !0, get: function() {
    return s.ValueScope;
  } }), Object.defineProperty(t, "ValueScopeName", { enumerable: !0, get: function() {
    return s.ValueScopeName;
  } }), Object.defineProperty(t, "varKinds", { enumerable: !0, get: function() {
    return s.varKinds;
  } }), t.operators = {
    GT: new e._Code(">"),
    GTE: new e._Code(">="),
    LT: new e._Code("<"),
    LTE: new e._Code("<="),
    EQ: new e._Code("==="),
    NEQ: new e._Code("!=="),
    NOT: new e._Code("!"),
    OR: new e._Code("||"),
    AND: new e._Code("&&"),
    ADD: new e._Code("+")
  };
  class i {
    optimizeNodes() {
      return this;
    }
    optimizeNames(p, k) {
      return this;
    }
  }
  class a extends i {
    constructor(p, k, H) {
      super(), this.varKind = p, this.name = k, this.rhs = H;
    }
    render({ es5: p, _n: k }) {
      const H = p ? r.varKinds.var : this.varKind, J = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${H} ${this.name}${J};` + k;
    }
    optimizeNames(p, k) {
      if (p[this.name.str])
        return this.rhs && (this.rhs = Oe(this.rhs, p, k)), this;
    }
    get names() {
      return this.rhs instanceof e._CodeOrName ? this.rhs.names : {};
    }
  }
  class o extends i {
    constructor(p, k, H) {
      super(), this.lhs = p, this.rhs = k, this.sideEffects = H;
    }
    render({ _n: p }) {
      return `${this.lhs} = ${this.rhs};` + p;
    }
    optimizeNames(p, k) {
      if (!(this.lhs instanceof e.Name && !p[this.lhs.str] && !this.sideEffects))
        return this.rhs = Oe(this.rhs, p, k), this;
    }
    get names() {
      const p = this.lhs instanceof e.Name ? {} : { ...this.lhs.names };
      return ke(p, this.rhs);
    }
  }
  class c extends o {
    constructor(p, k, H, J) {
      super(p, H, J), this.op = k;
    }
    render({ _n: p }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + p;
    }
  }
  class l extends i {
    constructor(p) {
      super(), this.label = p, this.names = {};
    }
    render({ _n: p }) {
      return `${this.label}:` + p;
    }
  }
  class f extends i {
    constructor(p) {
      super(), this.label = p, this.names = {};
    }
    render({ _n: p }) {
      return `break${this.label ? ` ${this.label}` : ""};` + p;
    }
  }
  class h extends i {
    constructor(p) {
      super(), this.error = p;
    }
    render({ _n: p }) {
      return `throw ${this.error};` + p;
    }
    get names() {
      return this.error.names;
    }
  }
  class y extends i {
    constructor(p) {
      super(), this.code = p;
    }
    render({ _n: p }) {
      return `${this.code};` + p;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(p, k) {
      return this.code = Oe(this.code, p, k), this;
    }
    get names() {
      return this.code instanceof e._CodeOrName ? this.code.names : {};
    }
  }
  class S extends i {
    constructor(p = []) {
      super(), this.nodes = p;
    }
    render(p) {
      return this.nodes.reduce((k, H) => k + H.render(p), "");
    }
    optimizeNodes() {
      const { nodes: p } = this;
      let k = p.length;
      for (; k--; ) {
        const H = p[k].optimizeNodes();
        Array.isArray(H) ? p.splice(k, 1, ...H) : H ? p[k] = H : p.splice(k, 1);
      }
      return p.length > 0 ? this : void 0;
    }
    optimizeNames(p, k) {
      const { nodes: H } = this;
      let J = H.length;
      for (; J--; ) {
        const O = H[J];
        O.optimizeNames(p, k) || (ht(p, O.names), H.splice(J, 1));
      }
      return H.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((p, k) => he(p, k.names), {});
    }
  }
  class E extends S {
    render(p) {
      return "{" + p._n + super.render(p) + "}" + p._n;
    }
  }
  class M extends S {
  }
  class A extends E {
  }
  A.kind = "else";
  class $ extends E {
    constructor(p, k) {
      super(k), this.condition = p;
    }
    render(p) {
      let k = `if(${this.condition})` + super.render(p);
      return this.else && (k += "else " + this.else.render(p)), k;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const p = this.condition;
      if (p === !0)
        return this.nodes;
      let k = this.else;
      if (k) {
        const H = k.optimizeNodes();
        k = this.else = Array.isArray(H) ? new A(H) : H;
      }
      if (k)
        return p === !1 ? k instanceof $ ? k : k.nodes : this.nodes.length ? this : new $(Me(p), k instanceof $ ? [k] : k.nodes);
      if (!(p === !1 || !this.nodes.length))
        return this;
    }
    optimizeNames(p, k) {
      var H;
      if (this.else = (H = this.else) === null || H === void 0 ? void 0 : H.optimizeNames(p, k), !!(super.optimizeNames(p, k) || this.else))
        return this.condition = Oe(this.condition, p, k), this;
    }
    get names() {
      const p = super.names;
      return ke(p, this.condition), this.else && he(p, this.else.names), p;
    }
  }
  $.kind = "if";
  class x extends E {
  }
  x.kind = "for";
  class P extends x {
    constructor(p) {
      super(), this.iteration = p;
    }
    render(p) {
      return `for(${this.iteration})` + super.render(p);
    }
    optimizeNames(p, k) {
      if (super.optimizeNames(p, k))
        return this.iteration = Oe(this.iteration, p, k), this;
    }
    get names() {
      return he(super.names, this.iteration.names);
    }
  }
  class U extends x {
    constructor(p, k, H, J) {
      super(), this.varKind = p, this.name = k, this.from = H, this.to = J;
    }
    render(p) {
      const k = p.es5 ? r.varKinds.var : this.varKind, { name: H, from: J, to: O } = this;
      return `for(${k} ${H}=${J}; ${H}<${O}; ${H}++)` + super.render(p);
    }
    get names() {
      const p = ke(super.names, this.from);
      return ke(p, this.to);
    }
  }
  class B extends x {
    constructor(p, k, H, J) {
      super(), this.loop = p, this.varKind = k, this.name = H, this.iterable = J;
    }
    render(p) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(p);
    }
    optimizeNames(p, k) {
      if (super.optimizeNames(p, k))
        return this.iterable = Oe(this.iterable, p, k), this;
    }
    get names() {
      return he(super.names, this.iterable.names);
    }
  }
  class w extends E {
    constructor(p, k, H) {
      super(), this.name = p, this.args = k, this.async = H;
    }
    render(p) {
      return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(p);
    }
  }
  w.kind = "func";
  class R extends S {
    render(p) {
      return "return " + super.render(p);
    }
  }
  R.kind = "return";
  class z extends E {
    render(p) {
      let k = "try" + super.render(p);
      return this.catch && (k += this.catch.render(p)), this.finally && (k += this.finally.render(p)), k;
    }
    optimizeNodes() {
      var p, k;
      return super.optimizeNodes(), (p = this.catch) === null || p === void 0 || p.optimizeNodes(), (k = this.finally) === null || k === void 0 || k.optimizeNodes(), this;
    }
    optimizeNames(p, k) {
      var H, J;
      return super.optimizeNames(p, k), (H = this.catch) === null || H === void 0 || H.optimizeNames(p, k), (J = this.finally) === null || J === void 0 || J.optimizeNames(p, k), this;
    }
    get names() {
      const p = super.names;
      return this.catch && he(p, this.catch.names), this.finally && he(p, this.finally.names), p;
    }
  }
  class re extends E {
    constructor(p) {
      super(), this.error = p;
    }
    render(p) {
      return `catch(${this.error})` + super.render(p);
    }
  }
  re.kind = "catch";
  class oe extends E {
    render(p) {
      return "finally" + super.render(p);
    }
  }
  oe.kind = "finally";
  class Ee {
    constructor(p, k = {}) {
      this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...k, _n: k.lines ? `
` : "" }, this._extScope = p, this._scope = new r.Scope({ parent: p }), this._nodes = [new M()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(p) {
      return this._scope.name(p);
    }
    // reserves unique name in the external scope
    scopeName(p) {
      return this._extScope.name(p);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(p, k) {
      const H = this._extScope.value(p, k);
      return (this._values[H.prefix] || (this._values[H.prefix] = /* @__PURE__ */ new Set())).add(H), H;
    }
    getScopeValue(p, k) {
      return this._extScope.getValue(p, k);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(p) {
      return this._extScope.scopeRefs(p, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(p, k, H, J) {
      const O = this._scope.toName(k);
      return H !== void 0 && J && (this._constants[O.str] = H), this._leafNode(new a(p, O, H)), O;
    }
    // `const` declaration (`var` in es5 mode)
    const(p, k, H) {
      return this._def(r.varKinds.const, p, k, H);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(p, k, H) {
      return this._def(r.varKinds.let, p, k, H);
    }
    // `var` declaration with optional assignment
    var(p, k, H) {
      return this._def(r.varKinds.var, p, k, H);
    }
    // assignment code
    assign(p, k, H) {
      return this._leafNode(new o(p, k, H));
    }
    // `+=` code
    add(p, k) {
      return this._leafNode(new c(p, t.operators.ADD, k));
    }
    // appends passed SafeExpr to code or executes Block
    code(p) {
      return typeof p == "function" ? p() : p !== e.nil && this._leafNode(new y(p)), this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...p) {
      const k = ["{"];
      for (const [H, J] of p)
        k.length > 1 && k.push(","), k.push(H), (H !== J || this.opts.es5) && (k.push(":"), (0, e.addCodeArg)(k, J));
      return k.push("}"), new e._Code(k);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(p, k, H) {
      if (this._blockNode(new $(p)), k && H)
        this.code(k).else().code(H).endIf();
      else if (k)
        this.code(k).endIf();
      else if (H)
        throw new Error('CodeGen: "else" body without "then" body');
      return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(p) {
      return this._elseNode(new $(p));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new A());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode($, A);
    }
    _for(p, k) {
      return this._blockNode(p), k && this.code(k).endFor(), this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(p, k) {
      return this._for(new P(p), k);
    }
    // `for` statement for a range of values
    forRange(p, k, H, J, O = this.opts.es5 ? r.varKinds.var : r.varKinds.let) {
      const V = this._scope.toName(p);
      return this._for(new U(O, V, k, H), () => J(V));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(p, k, H, J = r.varKinds.const) {
      const O = this._scope.toName(p);
      if (this.opts.es5) {
        const V = k instanceof e.Name ? k : this.var("_arr", k);
        return this.forRange("_i", 0, (0, e._)`${V}.length`, (L) => {
          this.var(O, (0, e._)`${V}[${L}]`), H(O);
        });
      }
      return this._for(new B("of", J, O, k), () => H(O));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(p, k, H, J = this.opts.es5 ? r.varKinds.var : r.varKinds.const) {
      if (this.opts.ownProperties)
        return this.forOf(p, (0, e._)`Object.keys(${k})`, H);
      const O = this._scope.toName(p);
      return this._for(new B("in", J, O, k), () => H(O));
    }
    // end `for` loop
    endFor() {
      return this._endBlockNode(x);
    }
    // `label` statement
    label(p) {
      return this._leafNode(new l(p));
    }
    // `break` statement
    break(p) {
      return this._leafNode(new f(p));
    }
    // `return` statement
    return(p) {
      const k = new R();
      if (this._blockNode(k), this.code(p), k.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(R);
    }
    // `try` statement
    try(p, k, H) {
      if (!k && !H)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const J = new z();
      if (this._blockNode(J), this.code(p), k) {
        const O = this.name("e");
        this._currNode = J.catch = new re(O), k(O);
      }
      return H && (this._currNode = J.finally = new oe(), this.code(H)), this._endBlockNode(re, oe);
    }
    // `throw` statement
    throw(p) {
      return this._leafNode(new h(p));
    }
    // start self-balancing block
    block(p, k) {
      return this._blockStarts.push(this._nodes.length), p && this.code(p).endBlock(k), this;
    }
    // end the current self-balancing block
    endBlock(p) {
      const k = this._blockStarts.pop();
      if (k === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const H = this._nodes.length - k;
      if (H < 0 || p !== void 0 && H !== p)
        throw new Error(`CodeGen: wrong number of nodes: ${H} vs ${p} expected`);
      return this._nodes.length = k, this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(p, k = e.nil, H, J) {
      return this._blockNode(new w(p, k, H)), J && this.code(J).endFunc(), this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode(w);
    }
    optimize(p = 1) {
      for (; p-- > 0; )
        this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
    }
    _leafNode(p) {
      return this._currNode.nodes.push(p), this;
    }
    _blockNode(p) {
      this._currNode.nodes.push(p), this._nodes.push(p);
    }
    _endBlockNode(p, k) {
      const H = this._currNode;
      if (H instanceof p || k && H instanceof k)
        return this._nodes.pop(), this;
      throw new Error(`CodeGen: not in block "${k ? `${p.kind}/${k.kind}` : p.kind}"`);
    }
    _elseNode(p) {
      const k = this._currNode;
      if (!(k instanceof $))
        throw new Error('CodeGen: "else" without "if"');
      return this._currNode = k.else = p, this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const p = this._nodes;
      return p[p.length - 1];
    }
    set _currNode(p) {
      const k = this._nodes;
      k[k.length - 1] = p;
    }
  }
  t.CodeGen = Ee;
  function he(m, p) {
    for (const k in p)
      m[k] = (m[k] || 0) + (p[k] || 0);
    return m;
  }
  function ke(m, p) {
    return p instanceof e._CodeOrName ? he(m, p.names) : m;
  }
  function Oe(m, p, k) {
    if (m instanceof e.Name)
      return H(m);
    if (!J(m))
      return m;
    return new e._Code(m._items.reduce((O, V) => (V instanceof e.Name && (V = H(V)), V instanceof e._Code ? O.push(...V._items) : O.push(V), O), []));
    function H(O) {
      const V = k[O.str];
      return V === void 0 || p[O.str] !== 1 ? O : (delete p[O.str], V);
    }
    function J(O) {
      return O instanceof e._Code && O._items.some((V) => V instanceof e.Name && p[V.str] === 1 && k[V.str] !== void 0);
    }
  }
  function ht(m, p) {
    for (const k in p)
      m[k] = (m[k] || 0) - (p[k] || 0);
  }
  function Me(m) {
    return typeof m == "boolean" || typeof m == "number" || m === null ? !m : (0, e._)`!${g(m)}`;
  }
  t.not = Me;
  const Te = F(t.operators.AND);
  function vt(...m) {
    return m.reduce(Te);
  }
  t.and = vt;
  const Se = F(t.operators.OR);
  function Y(...m) {
    return m.reduce(Se);
  }
  t.or = Y;
  function F(m) {
    return (p, k) => p === e.nil ? k : k === e.nil ? p : (0, e._)`${g(p)} ${m} ${g(k)}`;
  }
  function g(m) {
    return m instanceof e.Name ? m : (0, e._)`(${m})`;
  }
})(qe);
var He = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.checkStrictMode = t.getErrorPath = t.Type = t.useFunc = t.setEvaluated = t.evaluatedPropsToName = t.mergeEvaluated = t.eachItem = t.unescapeJsonPointer = t.escapeJsonPointer = t.escapeFragment = t.unescapeFragment = t.schemaRefOrVal = t.schemaHasRulesButRef = t.schemaHasRules = t.checkUnknownRules = t.alwaysValidSchema = t.toHash = void 0;
  const e = qe, r = ps;
  function n(w) {
    const R = {};
    for (const z of w)
      R[z] = !0;
    return R;
  }
  t.toHash = n;
  function s(w, R) {
    return typeof R == "boolean" ? R : Object.keys(R).length === 0 ? !0 : (i(w, R), !a(R, w.self.RULES.all));
  }
  t.alwaysValidSchema = s;
  function i(w, R = w.schema) {
    const { opts: z, self: re } = w;
    if (!z.strictSchema || typeof R == "boolean")
      return;
    const oe = re.RULES.keywords;
    for (const Ee in R)
      oe[Ee] || B(w, `unknown keyword: "${Ee}"`);
  }
  t.checkUnknownRules = i;
  function a(w, R) {
    if (typeof w == "boolean")
      return !w;
    for (const z in w)
      if (R[z])
        return !0;
    return !1;
  }
  t.schemaHasRules = a;
  function o(w, R) {
    if (typeof w == "boolean")
      return !w;
    for (const z in w)
      if (z !== "$ref" && R.all[z])
        return !0;
    return !1;
  }
  t.schemaHasRulesButRef = o;
  function c({ topSchemaRef: w, schemaPath: R }, z, re, oe) {
    if (!oe) {
      if (typeof z == "number" || typeof z == "boolean")
        return z;
      if (typeof z == "string")
        return (0, e._)`${z}`;
    }
    return (0, e._)`${w}${R}${(0, e.getProperty)(re)}`;
  }
  t.schemaRefOrVal = c;
  function l(w) {
    return y(decodeURIComponent(w));
  }
  t.unescapeFragment = l;
  function f(w) {
    return encodeURIComponent(h(w));
  }
  t.escapeFragment = f;
  function h(w) {
    return typeof w == "number" ? `${w}` : w.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  t.escapeJsonPointer = h;
  function y(w) {
    return w.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  t.unescapeJsonPointer = y;
  function S(w, R) {
    if (Array.isArray(w))
      for (const z of w)
        R(z);
    else
      R(w);
  }
  t.eachItem = S;
  function E({ mergeNames: w, mergeToName: R, mergeValues: z, resultToName: re }) {
    return (oe, Ee, he, ke) => {
      const Oe = he === void 0 ? Ee : he instanceof e.Name ? (Ee instanceof e.Name ? w(oe, Ee, he) : R(oe, Ee, he), he) : Ee instanceof e.Name ? (R(oe, he, Ee), Ee) : z(Ee, he);
      return ke === e.Name && !(Oe instanceof e.Name) ? re(oe, Oe) : Oe;
    };
  }
  t.mergeEvaluated = {
    props: E({
      mergeNames: (w, R, z) => w.if((0, e._)`${z} !== true && ${R} !== undefined`, () => {
        w.if((0, e._)`${R} === true`, () => w.assign(z, !0), () => w.assign(z, (0, e._)`${z} || {}`).code((0, e._)`Object.assign(${z}, ${R})`));
      }),
      mergeToName: (w, R, z) => w.if((0, e._)`${z} !== true`, () => {
        R === !0 ? w.assign(z, !0) : (w.assign(z, (0, e._)`${z} || {}`), A(w, z, R));
      }),
      mergeValues: (w, R) => w === !0 ? !0 : { ...w, ...R },
      resultToName: M
    }),
    items: E({
      mergeNames: (w, R, z) => w.if((0, e._)`${z} !== true && ${R} !== undefined`, () => w.assign(z, (0, e._)`${R} === true ? true : ${z} > ${R} ? ${z} : ${R}`)),
      mergeToName: (w, R, z) => w.if((0, e._)`${z} !== true`, () => w.assign(z, R === !0 ? !0 : (0, e._)`${z} > ${R} ? ${z} : ${R}`)),
      mergeValues: (w, R) => w === !0 ? !0 : Math.max(w, R),
      resultToName: (w, R) => w.var("items", R)
    })
  };
  function M(w, R) {
    if (R === !0)
      return w.var("props", !0);
    const z = w.var("props", (0, e._)`{}`);
    return R !== void 0 && A(w, z, R), z;
  }
  t.evaluatedPropsToName = M;
  function A(w, R, z) {
    Object.keys(z).forEach((re) => w.assign((0, e._)`${R}${(0, e.getProperty)(re)}`, !0));
  }
  t.setEvaluated = A;
  const $ = {};
  function x(w, R) {
    return w.scopeValue("func", {
      ref: R,
      code: $[R.code] || ($[R.code] = new r._Code(R.code))
    });
  }
  t.useFunc = x;
  var P;
  (function(w) {
    w[w.Num = 0] = "Num", w[w.Str = 1] = "Str";
  })(P = t.Type || (t.Type = {}));
  function U(w, R, z) {
    if (w instanceof e.Name) {
      const re = R === P.Num;
      return z ? re ? (0, e._)`"[" + ${w} + "]"` : (0, e._)`"['" + ${w} + "']"` : re ? (0, e._)`"/" + ${w}` : (0, e._)`"/" + ${w}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return z ? (0, e.getProperty)(w).toString() : "/" + h(w);
  }
  t.getErrorPath = U;
  function B(w, R, z = w.opts.strictSchema) {
    if (z) {
      if (R = `strict mode: ${R}`, z === !0)
        throw new Error(R);
      w.self.logger.warn(R);
    }
  }
  t.checkStrictMode = B;
})(He);
var yr = {};
Object.defineProperty(yr, "__esModule", { value: !0 });
const Ot = qe, Lm = {
  // validation function arguments
  data: new Ot.Name("data"),
  // args passed from referencing schema
  valCxt: new Ot.Name("valCxt"),
  instancePath: new Ot.Name("instancePath"),
  parentData: new Ot.Name("parentData"),
  parentDataProperty: new Ot.Name("parentDataProperty"),
  rootData: new Ot.Name("rootData"),
  dynamicAnchors: new Ot.Name("dynamicAnchors"),
  // function scoped variables
  vErrors: new Ot.Name("vErrors"),
  errors: new Ot.Name("errors"),
  this: new Ot.Name("this"),
  // "globals"
  self: new Ot.Name("self"),
  scope: new Ot.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new Ot.Name("json"),
  jsonPos: new Ot.Name("jsonPos"),
  jsonLen: new Ot.Name("jsonLen"),
  jsonPart: new Ot.Name("jsonPart")
};
yr.default = Lm;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.extendErrors = t.resetErrorsCount = t.reportExtraError = t.reportError = t.keyword$DataError = t.keywordError = void 0;
  const e = qe, r = He, n = yr;
  t.keywordError = {
    message: ({ keyword: A }) => (0, e.str)`must pass "${A}" keyword validation`
  }, t.keyword$DataError = {
    message: ({ keyword: A, schemaType: $ }) => $ ? (0, e.str)`"${A}" keyword must be ${$} ($data)` : (0, e.str)`"${A}" keyword is invalid ($data)`
  };
  function s(A, $ = t.keywordError, x, P) {
    const { it: U } = A, { gen: B, compositeRule: w, allErrors: R } = U, z = h(A, $, x);
    P ?? (w || R) ? c(B, z) : l(U, (0, e._)`[${z}]`);
  }
  t.reportError = s;
  function i(A, $ = t.keywordError, x) {
    const { it: P } = A, { gen: U, compositeRule: B, allErrors: w } = P, R = h(A, $, x);
    c(U, R), B || w || l(P, n.default.vErrors);
  }
  t.reportExtraError = i;
  function a(A, $) {
    A.assign(n.default.errors, $), A.if((0, e._)`${n.default.vErrors} !== null`, () => A.if($, () => A.assign((0, e._)`${n.default.vErrors}.length`, $), () => A.assign(n.default.vErrors, null)));
  }
  t.resetErrorsCount = a;
  function o({ gen: A, keyword: $, schemaValue: x, data: P, errsCount: U, it: B }) {
    if (U === void 0)
      throw new Error("ajv implementation error");
    const w = A.name("err");
    A.forRange("i", U, n.default.errors, (R) => {
      A.const(w, (0, e._)`${n.default.vErrors}[${R}]`), A.if((0, e._)`${w}.instancePath === undefined`, () => A.assign((0, e._)`${w}.instancePath`, (0, e.strConcat)(n.default.instancePath, B.errorPath))), A.assign((0, e._)`${w}.schemaPath`, (0, e.str)`${B.errSchemaPath}/${$}`), B.opts.verbose && (A.assign((0, e._)`${w}.schema`, x), A.assign((0, e._)`${w}.data`, P));
    });
  }
  t.extendErrors = o;
  function c(A, $) {
    const x = A.const("err", $);
    A.if((0, e._)`${n.default.vErrors} === null`, () => A.assign(n.default.vErrors, (0, e._)`[${x}]`), (0, e._)`${n.default.vErrors}.push(${x})`), A.code((0, e._)`${n.default.errors}++`);
  }
  function l(A, $) {
    const { gen: x, validateName: P, schemaEnv: U } = A;
    U.$async ? x.throw((0, e._)`new ${A.ValidationError}(${$})`) : (x.assign((0, e._)`${P}.errors`, $), x.return(!1));
  }
  const f = {
    keyword: new e.Name("keyword"),
    schemaPath: new e.Name("schemaPath"),
    params: new e.Name("params"),
    propertyName: new e.Name("propertyName"),
    message: new e.Name("message"),
    schema: new e.Name("schema"),
    parentSchema: new e.Name("parentSchema")
  };
  function h(A, $, x) {
    const { createErrors: P } = A.it;
    return P === !1 ? (0, e._)`{}` : y(A, $, x);
  }
  function y(A, $, x = {}) {
    const { gen: P, it: U } = A, B = [
      S(U, x),
      E(A, x)
    ];
    return M(A, $, B), P.object(...B);
  }
  function S({ errorPath: A }, { instancePath: $ }) {
    const x = $ ? (0, e.str)`${A}${(0, r.getErrorPath)($, r.Type.Str)}` : A;
    return [n.default.instancePath, (0, e.strConcat)(n.default.instancePath, x)];
  }
  function E({ keyword: A, it: { errSchemaPath: $ } }, { schemaPath: x, parentSchema: P }) {
    let U = P ? $ : (0, e.str)`${$}/${A}`;
    return x && (U = (0, e.str)`${U}${(0, r.getErrorPath)(x, r.Type.Str)}`), [f.schemaPath, U];
  }
  function M(A, { params: $, message: x }, P) {
    const { keyword: U, data: B, schemaValue: w, it: R } = A, { opts: z, propertyName: re, topSchemaRef: oe, schemaPath: Ee } = R;
    P.push([f.keyword, U], [f.params, typeof $ == "function" ? $(A) : $ || (0, e._)`{}`]), z.messages && P.push([f.message, typeof x == "function" ? x(A) : x]), z.verbose && P.push([f.schema, w], [f.parentSchema, (0, e._)`${oe}${Ee}`], [n.default.data, B]), re && P.push([f.propertyName, re]);
  }
})(Ss);
Object.defineProperty(Cn, "__esModule", { value: !0 });
Cn.boolOrEmptySchema = Cn.topBoolOrEmptySchema = void 0;
const Um = Ss, Fm = qe, Vm = yr, qm = {
  message: "boolean schema is false"
};
function Bm(t) {
  const { gen: e, schema: r, validateName: n } = t;
  r === !1 ? Du(t, !1) : typeof r == "object" && r.$async === !0 ? e.return(Vm.default.data) : (e.assign((0, Fm._)`${n}.errors`, null), e.return(!0));
}
Cn.topBoolOrEmptySchema = Bm;
function zm(t, e) {
  const { gen: r, schema: n } = t;
  n === !1 ? (r.var(e, !1), Du(t)) : r.var(e, !0);
}
Cn.boolOrEmptySchema = zm;
function Du(t, e) {
  const { gen: r, data: n } = t, s = {
    gen: r,
    keyword: "false schema",
    data: n,
    schema: !1,
    schemaCode: !1,
    schemaValue: !1,
    params: {},
    it: t
  };
  (0, Um.reportError)(s, qm, void 0, e);
}
var $s = {}, un = {};
Object.defineProperty(un, "__esModule", { value: !0 });
un.getRules = un.isJSONType = void 0;
const Wm = ["string", "number", "integer", "boolean", "null", "object", "array"], Hm = new Set(Wm);
function Zm(t) {
  return typeof t == "string" && Hm.has(t);
}
un.isJSONType = Zm;
function Km() {
  const t = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: { ...t, integer: !0, boolean: !0, null: !0 },
    rules: [{ rules: [] }, t.number, t.string, t.array, t.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
un.getRules = Km;
var $r = {};
Object.defineProperty($r, "__esModule", { value: !0 });
$r.shouldUseRule = $r.shouldUseGroup = $r.schemaHasRulesForType = void 0;
function Gm({ schema: t, self: e }, r) {
  const n = e.RULES.types[r];
  return n && n !== !0 && xu(t, n);
}
$r.schemaHasRulesForType = Gm;
function xu(t, e) {
  return e.rules.some((r) => Mu(t, r));
}
$r.shouldUseGroup = xu;
function Mu(t, e) {
  var r;
  return t[e.keyword] !== void 0 || ((r = e.definition.implements) === null || r === void 0 ? void 0 : r.some((n) => t[n] !== void 0));
}
$r.shouldUseRule = Mu;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.reportTypeError = t.checkDataTypes = t.checkDataType = t.coerceAndCheckDataType = t.getJSONTypes = t.getSchemaTypes = t.DataType = void 0;
  const e = un, r = $r, n = Ss, s = qe, i = He;
  var a;
  (function(P) {
    P[P.Correct = 0] = "Correct", P[P.Wrong = 1] = "Wrong";
  })(a = t.DataType || (t.DataType = {}));
  function o(P) {
    const U = c(P.type);
    if (U.includes("null")) {
      if (P.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!U.length && P.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      P.nullable === !0 && U.push("null");
    }
    return U;
  }
  t.getSchemaTypes = o;
  function c(P) {
    const U = Array.isArray(P) ? P : P ? [P] : [];
    if (U.every(e.isJSONType))
      return U;
    throw new Error("type must be JSONType or JSONType[]: " + U.join(","));
  }
  t.getJSONTypes = c;
  function l(P, U) {
    const { gen: B, data: w, opts: R } = P, z = h(U, R.coerceTypes), re = U.length > 0 && !(z.length === 0 && U.length === 1 && (0, r.schemaHasRulesForType)(P, U[0]));
    if (re) {
      const oe = M(U, w, R.strictNumbers, a.Wrong);
      B.if(oe, () => {
        z.length ? y(P, U, z) : $(P);
      });
    }
    return re;
  }
  t.coerceAndCheckDataType = l;
  const f = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function h(P, U) {
    return U ? P.filter((B) => f.has(B) || U === "array" && B === "array") : [];
  }
  function y(P, U, B) {
    const { gen: w, data: R, opts: z } = P, re = w.let("dataType", (0, s._)`typeof ${R}`), oe = w.let("coerced", (0, s._)`undefined`);
    z.coerceTypes === "array" && w.if((0, s._)`${re} == 'object' && Array.isArray(${R}) && ${R}.length == 1`, () => w.assign(R, (0, s._)`${R}[0]`).assign(re, (0, s._)`typeof ${R}`).if(M(U, R, z.strictNumbers), () => w.assign(oe, R))), w.if((0, s._)`${oe} !== undefined`);
    for (const he of B)
      (f.has(he) || he === "array" && z.coerceTypes === "array") && Ee(he);
    w.else(), $(P), w.endIf(), w.if((0, s._)`${oe} !== undefined`, () => {
      w.assign(R, oe), S(P, oe);
    });
    function Ee(he) {
      switch (he) {
        case "string":
          w.elseIf((0, s._)`${re} == "number" || ${re} == "boolean"`).assign(oe, (0, s._)`"" + ${R}`).elseIf((0, s._)`${R} === null`).assign(oe, (0, s._)`""`);
          return;
        case "number":
          w.elseIf((0, s._)`${re} == "boolean" || ${R} === null
              || (${re} == "string" && ${R} && ${R} == +${R})`).assign(oe, (0, s._)`+${R}`);
          return;
        case "integer":
          w.elseIf((0, s._)`${re} === "boolean" || ${R} === null
              || (${re} === "string" && ${R} && ${R} == +${R} && !(${R} % 1))`).assign(oe, (0, s._)`+${R}`);
          return;
        case "boolean":
          w.elseIf((0, s._)`${R} === "false" || ${R} === 0 || ${R} === null`).assign(oe, !1).elseIf((0, s._)`${R} === "true" || ${R} === 1`).assign(oe, !0);
          return;
        case "null":
          w.elseIf((0, s._)`${R} === "" || ${R} === 0 || ${R} === false`), w.assign(oe, null);
          return;
        case "array":
          w.elseIf((0, s._)`${re} === "string" || ${re} === "number"
              || ${re} === "boolean" || ${R} === null`).assign(oe, (0, s._)`[${R}]`);
      }
    }
  }
  function S({ gen: P, parentData: U, parentDataProperty: B }, w) {
    P.if((0, s._)`${U} !== undefined`, () => P.assign((0, s._)`${U}[${B}]`, w));
  }
  function E(P, U, B, w = a.Correct) {
    const R = w === a.Correct ? s.operators.EQ : s.operators.NEQ;
    let z;
    switch (P) {
      case "null":
        return (0, s._)`${U} ${R} null`;
      case "array":
        z = (0, s._)`Array.isArray(${U})`;
        break;
      case "object":
        z = (0, s._)`${U} && typeof ${U} == "object" && !Array.isArray(${U})`;
        break;
      case "integer":
        z = re((0, s._)`!(${U} % 1) && !isNaN(${U})`);
        break;
      case "number":
        z = re();
        break;
      default:
        return (0, s._)`typeof ${U} ${R} ${P}`;
    }
    return w === a.Correct ? z : (0, s.not)(z);
    function re(oe = s.nil) {
      return (0, s.and)((0, s._)`typeof ${U} == "number"`, oe, B ? (0, s._)`isFinite(${U})` : s.nil);
    }
  }
  t.checkDataType = E;
  function M(P, U, B, w) {
    if (P.length === 1)
      return E(P[0], U, B, w);
    let R;
    const z = (0, i.toHash)(P);
    if (z.array && z.object) {
      const re = (0, s._)`typeof ${U} != "object"`;
      R = z.null ? re : (0, s._)`!${U} || ${re}`, delete z.null, delete z.array, delete z.object;
    } else
      R = s.nil;
    z.number && delete z.integer;
    for (const re in z)
      R = (0, s.and)(R, E(re, U, B, w));
    return R;
  }
  t.checkDataTypes = M;
  const A = {
    message: ({ schema: P }) => `must be ${P}`,
    params: ({ schema: P, schemaValue: U }) => typeof P == "string" ? (0, s._)`{type: ${P}}` : (0, s._)`{type: ${U}}`
  };
  function $(P) {
    const U = x(P);
    (0, n.reportError)(U, A);
  }
  t.reportTypeError = $;
  function x(P) {
    const { gen: U, data: B, schema: w } = P, R = (0, i.schemaRefOrVal)(P, w, "type");
    return {
      gen: U,
      keyword: "type",
      data: B,
      schema: w.type,
      schemaCode: R,
      schemaValue: R,
      parentSchema: w,
      params: {},
      it: P
    };
  }
})($s);
var xi = {};
Object.defineProperty(xi, "__esModule", { value: !0 });
xi.assignDefaults = void 0;
const pn = qe, Jm = He;
function Ym(t, e) {
  const { properties: r, items: n } = t.schema;
  if (e === "object" && r)
    for (const s in r)
      cc(t, s, r[s].default);
  else
    e === "array" && Array.isArray(n) && n.forEach((s, i) => cc(t, i, s.default));
}
xi.assignDefaults = Ym;
function cc(t, e, r) {
  const { gen: n, compositeRule: s, data: i, opts: a } = t;
  if (r === void 0)
    return;
  const o = (0, pn._)`${i}${(0, pn.getProperty)(e)}`;
  if (s) {
    (0, Jm.checkStrictMode)(t, `default is ignored for: ${o}`);
    return;
  }
  let c = (0, pn._)`${o} === undefined`;
  a.useDefaults === "empty" && (c = (0, pn._)`${c} || ${o} === null || ${o} === ""`), n.if(c, (0, pn._)`${o} = ${(0, pn.stringify)(r)}`);
}
var lr = {}, Ve = {};
Object.defineProperty(Ve, "__esModule", { value: !0 });
Ve.validateUnion = Ve.validateArray = Ve.usePattern = Ve.callValidateCode = Ve.schemaProperties = Ve.allSchemaProperties = Ve.noPropertyInData = Ve.propertyInData = Ve.isOwnProperty = Ve.hasPropFunc = Ve.reportMissingProp = Ve.checkMissingProp = Ve.checkReportMissingProp = void 0;
const at = qe, Ga = He, Nr = yr, Xm = He;
function Qm(t, e) {
  const { gen: r, data: n, it: s } = t;
  r.if(Ya(r, n, e, s.opts.ownProperties), () => {
    t.setParams({ missingProperty: (0, at._)`${e}` }, !0), t.error();
  });
}
Ve.checkReportMissingProp = Qm;
function eg({ gen: t, data: e, it: { opts: r } }, n, s) {
  return (0, at.or)(...n.map((i) => (0, at.and)(Ya(t, e, i, r.ownProperties), (0, at._)`${s} = ${i}`)));
}
Ve.checkMissingProp = eg;
function tg(t, e) {
  t.setParams({ missingProperty: e }, !0), t.error();
}
Ve.reportMissingProp = tg;
function ju(t) {
  return t.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: (0, at._)`Object.prototype.hasOwnProperty`
  });
}
Ve.hasPropFunc = ju;
function Ja(t, e, r) {
  return (0, at._)`${ju(t)}.call(${e}, ${r})`;
}
Ve.isOwnProperty = Ja;
function rg(t, e, r, n) {
  const s = (0, at._)`${e}${(0, at.getProperty)(r)} !== undefined`;
  return n ? (0, at._)`${s} && ${Ja(t, e, r)}` : s;
}
Ve.propertyInData = rg;
function Ya(t, e, r, n) {
  const s = (0, at._)`${e}${(0, at.getProperty)(r)} === undefined`;
  return n ? (0, at.or)(s, (0, at.not)(Ja(t, e, r))) : s;
}
Ve.noPropertyInData = Ya;
function Lu(t) {
  return t ? Object.keys(t).filter((e) => e !== "__proto__") : [];
}
Ve.allSchemaProperties = Lu;
function ng(t, e) {
  return Lu(e).filter((r) => !(0, Ga.alwaysValidSchema)(t, e[r]));
}
Ve.schemaProperties = ng;
function sg({ schemaCode: t, data: e, it: { gen: r, topSchemaRef: n, schemaPath: s, errorPath: i }, it: a }, o, c, l) {
  const f = l ? (0, at._)`${t}, ${e}, ${n}${s}` : e, h = [
    [Nr.default.instancePath, (0, at.strConcat)(Nr.default.instancePath, i)],
    [Nr.default.parentData, a.parentData],
    [Nr.default.parentDataProperty, a.parentDataProperty],
    [Nr.default.rootData, Nr.default.rootData]
  ];
  a.opts.dynamicRef && h.push([Nr.default.dynamicAnchors, Nr.default.dynamicAnchors]);
  const y = (0, at._)`${f}, ${r.object(...h)}`;
  return c !== at.nil ? (0, at._)`${o}.call(${c}, ${y})` : (0, at._)`${o}(${y})`;
}
Ve.callValidateCode = sg;
const ig = (0, at._)`new RegExp`;
function ag({ gen: t, it: { opts: e } }, r) {
  const n = e.unicodeRegExp ? "u" : "", { regExp: s } = e.code, i = s(r, n);
  return t.scopeValue("pattern", {
    key: i.toString(),
    ref: i,
    code: (0, at._)`${s.code === "new RegExp" ? ig : (0, Xm.useFunc)(t, s)}(${r}, ${n})`
  });
}
Ve.usePattern = ag;
function og(t) {
  const { gen: e, data: r, keyword: n, it: s } = t, i = e.name("valid");
  if (s.allErrors) {
    const o = e.let("valid", !0);
    return a(() => e.assign(o, !1)), o;
  }
  return e.var(i, !0), a(() => e.break()), i;
  function a(o) {
    const c = e.const("len", (0, at._)`${r}.length`);
    e.forRange("i", 0, c, (l) => {
      t.subschema({
        keyword: n,
        dataProp: l,
        dataPropType: Ga.Type.Num
      }, i), e.if((0, at.not)(i), o);
    });
  }
}
Ve.validateArray = og;
function cg(t) {
  const { gen: e, schema: r, keyword: n, it: s } = t;
  if (!Array.isArray(r))
    throw new Error("ajv implementation error");
  if (r.some((c) => (0, Ga.alwaysValidSchema)(s, c)) && !s.opts.unevaluated)
    return;
  const a = e.let("valid", !1), o = e.name("_valid");
  e.block(() => r.forEach((c, l) => {
    const f = t.subschema({
      keyword: n,
      schemaProp: l,
      compositeRule: !0
    }, o);
    e.assign(a, (0, at._)`${a} || ${o}`), t.mergeValidEvaluated(f, o) || e.if((0, at.not)(a));
  })), t.result(a, () => t.reset(), () => t.error(!0));
}
Ve.validateUnion = cg;
Object.defineProperty(lr, "__esModule", { value: !0 });
lr.validateKeywordUsage = lr.validSchemaType = lr.funcKeywordCode = lr.macroKeywordCode = void 0;
const Rt = qe, Yr = yr, ug = Ve, lg = Ss;
function dg(t, e) {
  const { gen: r, keyword: n, schema: s, parentSchema: i, it: a } = t, o = e.macro.call(a.self, s, i, a), c = Uu(r, n, o);
  a.opts.validateSchema !== !1 && a.self.validateSchema(o, !0);
  const l = r.name("valid");
  t.subschema({
    schema: o,
    schemaPath: Rt.nil,
    errSchemaPath: `${a.errSchemaPath}/${n}`,
    topSchemaRef: c,
    compositeRule: !0
  }, l), t.pass(l, () => t.error(!0));
}
lr.macroKeywordCode = dg;
function fg(t, e) {
  var r;
  const { gen: n, keyword: s, schema: i, parentSchema: a, $data: o, it: c } = t;
  pg(c, e);
  const l = !o && e.compile ? e.compile.call(c.self, i, a, c) : e.validate, f = Uu(n, s, l), h = n.let("valid");
  t.block$data(h, y), t.ok((r = e.valid) !== null && r !== void 0 ? r : h);
  function y() {
    if (e.errors === !1)
      M(), e.modifying && uc(t), A(() => t.error());
    else {
      const $ = e.async ? S() : E();
      e.modifying && uc(t), A(() => hg(t, $));
    }
  }
  function S() {
    const $ = n.let("ruleErrs", null);
    return n.try(() => M((0, Rt._)`await `), (x) => n.assign(h, !1).if((0, Rt._)`${x} instanceof ${c.ValidationError}`, () => n.assign($, (0, Rt._)`${x}.errors`), () => n.throw(x))), $;
  }
  function E() {
    const $ = (0, Rt._)`${f}.errors`;
    return n.assign($, null), M(Rt.nil), $;
  }
  function M($ = e.async ? (0, Rt._)`await ` : Rt.nil) {
    const x = c.opts.passContext ? Yr.default.this : Yr.default.self, P = !("compile" in e && !o || e.schema === !1);
    n.assign(h, (0, Rt._)`${$}${(0, ug.callValidateCode)(t, f, x, P)}`, e.modifying);
  }
  function A($) {
    var x;
    n.if((0, Rt.not)((x = e.valid) !== null && x !== void 0 ? x : h), $);
  }
}
lr.funcKeywordCode = fg;
function uc(t) {
  const { gen: e, data: r, it: n } = t;
  e.if(n.parentData, () => e.assign(r, (0, Rt._)`${n.parentData}[${n.parentDataProperty}]`));
}
function hg(t, e) {
  const { gen: r } = t;
  r.if((0, Rt._)`Array.isArray(${e})`, () => {
    r.assign(Yr.default.vErrors, (0, Rt._)`${Yr.default.vErrors} === null ? ${e} : ${Yr.default.vErrors}.concat(${e})`).assign(Yr.default.errors, (0, Rt._)`${Yr.default.vErrors}.length`), (0, lg.extendErrors)(t);
  }, () => t.error());
}
function pg({ schemaEnv: t }, e) {
  if (e.async && !t.$async)
    throw new Error("async keyword in sync schema");
}
function Uu(t, e, r) {
  if (r === void 0)
    throw new Error(`keyword "${e}" failed to compile`);
  return t.scopeValue("keyword", typeof r == "function" ? { ref: r } : { ref: r, code: (0, Rt.stringify)(r) });
}
function mg(t, e, r = !1) {
  return !e.length || e.some((n) => n === "array" ? Array.isArray(t) : n === "object" ? t && typeof t == "object" && !Array.isArray(t) : typeof t == n || r && typeof t > "u");
}
lr.validSchemaType = mg;
function gg({ schema: t, opts: e, self: r, errSchemaPath: n }, s, i) {
  if (Array.isArray(s.keyword) ? !s.keyword.includes(i) : s.keyword !== i)
    throw new Error("ajv implementation error");
  const a = s.dependencies;
  if (a?.some((o) => !Object.prototype.hasOwnProperty.call(t, o)))
    throw new Error(`parent schema must have dependencies of ${i}: ${a.join(",")}`);
  if (s.validateSchema && !s.validateSchema(t[i])) {
    const c = `keyword "${i}" value is invalid at path "${n}": ` + r.errorsText(s.validateSchema.errors);
    if (e.validateSchema === "log")
      r.logger.error(c);
    else
      throw new Error(c);
  }
}
lr.validateKeywordUsage = gg;
var Vr = {};
Object.defineProperty(Vr, "__esModule", { value: !0 });
Vr.extendSubschemaMode = Vr.extendSubschemaData = Vr.getSubschema = void 0;
const cr = qe, Fu = He;
function yg(t, { keyword: e, schemaProp: r, schema: n, schemaPath: s, errSchemaPath: i, topSchemaRef: a }) {
  if (e !== void 0 && n !== void 0)
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  if (e !== void 0) {
    const o = t.schema[e];
    return r === void 0 ? {
      schema: o,
      schemaPath: (0, cr._)`${t.schemaPath}${(0, cr.getProperty)(e)}`,
      errSchemaPath: `${t.errSchemaPath}/${e}`
    } : {
      schema: o[r],
      schemaPath: (0, cr._)`${t.schemaPath}${(0, cr.getProperty)(e)}${(0, cr.getProperty)(r)}`,
      errSchemaPath: `${t.errSchemaPath}/${e}/${(0, Fu.escapeFragment)(r)}`
    };
  }
  if (n !== void 0) {
    if (s === void 0 || i === void 0 || a === void 0)
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    return {
      schema: n,
      schemaPath: s,
      topSchemaRef: a,
      errSchemaPath: i
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
Vr.getSubschema = yg;
function vg(t, e, { dataProp: r, dataPropType: n, data: s, dataTypes: i, propertyName: a }) {
  if (s !== void 0 && r !== void 0)
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  const { gen: o } = e;
  if (r !== void 0) {
    const { errorPath: l, dataPathArr: f, opts: h } = e, y = o.let("data", (0, cr._)`${e.data}${(0, cr.getProperty)(r)}`, !0);
    c(y), t.errorPath = (0, cr.str)`${l}${(0, Fu.getErrorPath)(r, n, h.jsPropertySyntax)}`, t.parentDataProperty = (0, cr._)`${r}`, t.dataPathArr = [...f, t.parentDataProperty];
  }
  if (s !== void 0) {
    const l = s instanceof cr.Name ? s : o.let("data", s, !0);
    c(l), a !== void 0 && (t.propertyName = a);
  }
  i && (t.dataTypes = i);
  function c(l) {
    t.data = l, t.dataLevel = e.dataLevel + 1, t.dataTypes = [], e.definedProperties = /* @__PURE__ */ new Set(), t.parentData = e.data, t.dataNames = [...e.dataNames, l];
  }
}
Vr.extendSubschemaData = vg;
function bg(t, { jtdDiscriminator: e, jtdMetadata: r, compositeRule: n, createErrors: s, allErrors: i }) {
  n !== void 0 && (t.compositeRule = n), s !== void 0 && (t.createErrors = s), i !== void 0 && (t.allErrors = i), t.jtdDiscriminator = e, t.jtdMetadata = r;
}
Vr.extendSubschemaMode = bg;
var Tt = {}, Vu = function t(e, r) {
  if (e === r)
    return !0;
  if (e && r && typeof e == "object" && typeof r == "object") {
    if (e.constructor !== r.constructor)
      return !1;
    var n, s, i;
    if (Array.isArray(e)) {
      if (n = e.length, n != r.length)
        return !1;
      for (s = n; s-- !== 0; )
        if (!t(e[s], r[s]))
          return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === r.source && e.flags === r.flags;
    if (e.valueOf !== Object.prototype.valueOf)
      return e.valueOf() === r.valueOf();
    if (e.toString !== Object.prototype.toString)
      return e.toString() === r.toString();
    if (i = Object.keys(e), n = i.length, n !== Object.keys(r).length)
      return !1;
    for (s = n; s-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(r, i[s]))
        return !1;
    for (s = n; s-- !== 0; ) {
      var a = i[s];
      if (!t(e[a], r[a]))
        return !1;
    }
    return !0;
  }
  return e !== e && r !== r;
}, qu = { exports: {} }, Fr = qu.exports = function(t, e, r) {
  typeof e == "function" && (r = e, e = {}), r = e.cb || r;
  var n = typeof r == "function" ? r : r.pre || function() {
  }, s = r.post || function() {
  };
  Js(e, n, s, t, "", t);
};
Fr.keywords = {
  additionalItems: !0,
  items: !0,
  contains: !0,
  additionalProperties: !0,
  propertyNames: !0,
  not: !0,
  if: !0,
  then: !0,
  else: !0
};
Fr.arrayKeywords = {
  items: !0,
  allOf: !0,
  anyOf: !0,
  oneOf: !0
};
Fr.propsKeywords = {
  $defs: !0,
  definitions: !0,
  properties: !0,
  patternProperties: !0,
  dependencies: !0
};
Fr.skipKeywords = {
  default: !0,
  enum: !0,
  const: !0,
  required: !0,
  maximum: !0,
  minimum: !0,
  exclusiveMaximum: !0,
  exclusiveMinimum: !0,
  multipleOf: !0,
  maxLength: !0,
  minLength: !0,
  pattern: !0,
  format: !0,
  maxItems: !0,
  minItems: !0,
  uniqueItems: !0,
  maxProperties: !0,
  minProperties: !0
};
function Js(t, e, r, n, s, i, a, o, c, l) {
  if (n && typeof n == "object" && !Array.isArray(n)) {
    e(n, s, i, a, o, c, l);
    for (var f in n) {
      var h = n[f];
      if (Array.isArray(h)) {
        if (f in Fr.arrayKeywords)
          for (var y = 0; y < h.length; y++)
            Js(t, e, r, h[y], s + "/" + f + "/" + y, i, s, f, n, y);
      } else if (f in Fr.propsKeywords) {
        if (h && typeof h == "object")
          for (var S in h)
            Js(t, e, r, h[S], s + "/" + f + "/" + wg(S), i, s, f, n, S);
      } else
        (f in Fr.keywords || t.allKeys && !(f in Fr.skipKeywords)) && Js(t, e, r, h, s + "/" + f, i, s, f, n);
    }
    r(n, s, i, a, o, c, l);
  }
}
function wg(t) {
  return t.replace(/~/g, "~0").replace(/\//g, "~1");
}
var _g = qu.exports;
Object.defineProperty(Tt, "__esModule", { value: !0 });
Tt.getSchemaRefs = Tt.resolveUrl = Tt.normalizeId = Tt._getFullPath = Tt.getFullPath = Tt.inlineRef = void 0;
const Eg = He, Sg = Vu, $g = _g, kg = /* @__PURE__ */ new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function Tg(t, e = !0) {
  return typeof t == "boolean" ? !0 : e === !0 ? !Sa(t) : e ? Bu(t) <= e : !1;
}
Tt.inlineRef = Tg;
const Pg = /* @__PURE__ */ new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function Sa(t) {
  for (const e in t) {
    if (Pg.has(e))
      return !0;
    const r = t[e];
    if (Array.isArray(r) && r.some(Sa) || typeof r == "object" && Sa(r))
      return !0;
  }
  return !1;
}
function Bu(t) {
  let e = 0;
  for (const r in t) {
    if (r === "$ref")
      return 1 / 0;
    if (e++, !kg.has(r) && (typeof t[r] == "object" && (0, Eg.eachItem)(t[r], (n) => e += Bu(n)), e === 1 / 0))
      return 1 / 0;
  }
  return e;
}
function zu(t, e = "", r) {
  r !== !1 && (e = kn(e));
  const n = t.parse(e);
  return Wu(t, n);
}
Tt.getFullPath = zu;
function Wu(t, e) {
  return t.serialize(e).split("#")[0] + "#";
}
Tt._getFullPath = Wu;
const Ig = /#\/?$/;
function kn(t) {
  return t ? t.replace(Ig, "") : "";
}
Tt.normalizeId = kn;
function Og(t, e, r) {
  return r = kn(r), t.resolve(e, r);
}
Tt.resolveUrl = Og;
const Ag = /^[a-z_][-a-z0-9._]*$/i;
function Ng(t, e) {
  if (typeof t == "boolean")
    return {};
  const { schemaId: r, uriResolver: n } = this.opts, s = kn(t[r] || e), i = { "": s }, a = zu(n, s, !1), o = {}, c = /* @__PURE__ */ new Set();
  return $g(t, { allKeys: !0 }, (h, y, S, E) => {
    if (E === void 0)
      return;
    const M = a + y;
    let A = i[E];
    typeof h[r] == "string" && (A = $.call(this, h[r])), x.call(this, h.$anchor), x.call(this, h.$dynamicAnchor), i[y] = A;
    function $(P) {
      const U = this.opts.uriResolver.resolve;
      if (P = kn(A ? U(A, P) : P), c.has(P))
        throw f(P);
      c.add(P);
      let B = this.refs[P];
      return typeof B == "string" && (B = this.refs[B]), typeof B == "object" ? l(h, B.schema, P) : P !== kn(M) && (P[0] === "#" ? (l(h, o[P], P), o[P] = h) : this.refs[P] = M), P;
    }
    function x(P) {
      if (typeof P == "string") {
        if (!Ag.test(P))
          throw new Error(`invalid anchor "${P}"`);
        $.call(this, `#${P}`);
      }
    }
  }), o;
  function l(h, y, S) {
    if (y !== void 0 && !Sg(h, y))
      throw f(S);
  }
  function f(h) {
    return new Error(`reference "${h}" resolves to more than one schema`);
  }
}
Tt.getSchemaRefs = Ng;
Object.defineProperty(ir, "__esModule", { value: !0 });
ir.getData = ir.KeywordCxt = ir.validateFunctionCode = void 0;
const Hu = Cn, lc = $s, Xa = $r, bi = $s, Cg = xi, Gn = lr, Ji = Vr, ve = qe, Ie = yr, Rg = Tt, kr = He, zn = Ss;
function Dg(t) {
  if (Gu(t) && (Ju(t), Ku(t))) {
    jg(t);
    return;
  }
  Zu(t, () => (0, Hu.topBoolOrEmptySchema)(t));
}
ir.validateFunctionCode = Dg;
function Zu({ gen: t, validateName: e, schema: r, schemaEnv: n, opts: s }, i) {
  s.code.es5 ? t.func(e, (0, ve._)`${Ie.default.data}, ${Ie.default.valCxt}`, n.$async, () => {
    t.code((0, ve._)`"use strict"; ${dc(r, s)}`), Mg(t, s), t.code(i);
  }) : t.func(e, (0, ve._)`${Ie.default.data}, ${xg(s)}`, n.$async, () => t.code(dc(r, s)).code(i));
}
function xg(t) {
  return (0, ve._)`{${Ie.default.instancePath}="", ${Ie.default.parentData}, ${Ie.default.parentDataProperty}, ${Ie.default.rootData}=${Ie.default.data}${t.dynamicRef ? (0, ve._)`, ${Ie.default.dynamicAnchors}={}` : ve.nil}}={}`;
}
function Mg(t, e) {
  t.if(Ie.default.valCxt, () => {
    t.var(Ie.default.instancePath, (0, ve._)`${Ie.default.valCxt}.${Ie.default.instancePath}`), t.var(Ie.default.parentData, (0, ve._)`${Ie.default.valCxt}.${Ie.default.parentData}`), t.var(Ie.default.parentDataProperty, (0, ve._)`${Ie.default.valCxt}.${Ie.default.parentDataProperty}`), t.var(Ie.default.rootData, (0, ve._)`${Ie.default.valCxt}.${Ie.default.rootData}`), e.dynamicRef && t.var(Ie.default.dynamicAnchors, (0, ve._)`${Ie.default.valCxt}.${Ie.default.dynamicAnchors}`);
  }, () => {
    t.var(Ie.default.instancePath, (0, ve._)`""`), t.var(Ie.default.parentData, (0, ve._)`undefined`), t.var(Ie.default.parentDataProperty, (0, ve._)`undefined`), t.var(Ie.default.rootData, Ie.default.data), e.dynamicRef && t.var(Ie.default.dynamicAnchors, (0, ve._)`{}`);
  });
}
function jg(t) {
  const { schema: e, opts: r, gen: n } = t;
  Zu(t, () => {
    r.$comment && e.$comment && Xu(t), qg(t), n.let(Ie.default.vErrors, null), n.let(Ie.default.errors, 0), r.unevaluated && Lg(t), Yu(t), Wg(t);
  });
}
function Lg(t) {
  const { gen: e, validateName: r } = t;
  t.evaluated = e.const("evaluated", (0, ve._)`${r}.evaluated`), e.if((0, ve._)`${t.evaluated}.dynamicProps`, () => e.assign((0, ve._)`${t.evaluated}.props`, (0, ve._)`undefined`)), e.if((0, ve._)`${t.evaluated}.dynamicItems`, () => e.assign((0, ve._)`${t.evaluated}.items`, (0, ve._)`undefined`));
}
function dc(t, e) {
  const r = typeof t == "object" && t[e.schemaId];
  return r && (e.code.source || e.code.process) ? (0, ve._)`/*# sourceURL=${r} */` : ve.nil;
}
function Ug(t, e) {
  if (Gu(t) && (Ju(t), Ku(t))) {
    Fg(t, e);
    return;
  }
  (0, Hu.boolOrEmptySchema)(t, e);
}
function Ku({ schema: t, self: e }) {
  if (typeof t == "boolean")
    return !t;
  for (const r in t)
    if (e.RULES.all[r])
      return !0;
  return !1;
}
function Gu(t) {
  return typeof t.schema != "boolean";
}
function Fg(t, e) {
  const { schema: r, gen: n, opts: s } = t;
  s.$comment && r.$comment && Xu(t), Bg(t), zg(t);
  const i = n.const("_errs", Ie.default.errors);
  Yu(t, i), n.var(e, (0, ve._)`${i} === ${Ie.default.errors}`);
}
function Ju(t) {
  (0, kr.checkUnknownRules)(t), Vg(t);
}
function Yu(t, e) {
  if (t.opts.jtd)
    return fc(t, [], !1, e);
  const r = (0, lc.getSchemaTypes)(t.schema), n = (0, lc.coerceAndCheckDataType)(t, r);
  fc(t, r, !n, e);
}
function Vg(t) {
  const { schema: e, errSchemaPath: r, opts: n, self: s } = t;
  e.$ref && n.ignoreKeywordsWithRef && (0, kr.schemaHasRulesButRef)(e, s.RULES) && s.logger.warn(`$ref: keywords ignored in schema at path "${r}"`);
}
function qg(t) {
  const { schema: e, opts: r } = t;
  e.default !== void 0 && r.useDefaults && r.strictSchema && (0, kr.checkStrictMode)(t, "default is ignored in the schema root");
}
function Bg(t) {
  const e = t.schema[t.opts.schemaId];
  e && (t.baseId = (0, Rg.resolveUrl)(t.opts.uriResolver, t.baseId, e));
}
function zg(t) {
  if (t.schema.$async && !t.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function Xu({ gen: t, schemaEnv: e, schema: r, errSchemaPath: n, opts: s }) {
  const i = r.$comment;
  if (s.$comment === !0)
    t.code((0, ve._)`${Ie.default.self}.logger.log(${i})`);
  else if (typeof s.$comment == "function") {
    const a = (0, ve.str)`${n}/$comment`, o = t.scopeValue("root", { ref: e.root });
    t.code((0, ve._)`${Ie.default.self}.opts.$comment(${i}, ${a}, ${o}.schema)`);
  }
}
function Wg(t) {
  const { gen: e, schemaEnv: r, validateName: n, ValidationError: s, opts: i } = t;
  r.$async ? e.if((0, ve._)`${Ie.default.errors} === 0`, () => e.return(Ie.default.data), () => e.throw((0, ve._)`new ${s}(${Ie.default.vErrors})`)) : (e.assign((0, ve._)`${n}.errors`, Ie.default.vErrors), i.unevaluated && Hg(t), e.return((0, ve._)`${Ie.default.errors} === 0`));
}
function Hg({ gen: t, evaluated: e, props: r, items: n }) {
  r instanceof ve.Name && t.assign((0, ve._)`${e}.props`, r), n instanceof ve.Name && t.assign((0, ve._)`${e}.items`, n);
}
function fc(t, e, r, n) {
  const { gen: s, schema: i, data: a, allErrors: o, opts: c, self: l } = t, { RULES: f } = l;
  if (i.$ref && (c.ignoreKeywordsWithRef || !(0, kr.schemaHasRulesButRef)(i, f))) {
    s.block(() => tl(t, "$ref", f.all.$ref.definition));
    return;
  }
  c.jtd || Zg(t, e), s.block(() => {
    for (const y of f.rules)
      h(y);
    h(f.post);
  });
  function h(y) {
    (0, Xa.shouldUseGroup)(i, y) && (y.type ? (s.if((0, bi.checkDataType)(y.type, a, c.strictNumbers)), hc(t, y), e.length === 1 && e[0] === y.type && r && (s.else(), (0, bi.reportTypeError)(t)), s.endIf()) : hc(t, y), o || s.if((0, ve._)`${Ie.default.errors} === ${n || 0}`));
  }
}
function hc(t, e) {
  const { gen: r, schema: n, opts: { useDefaults: s } } = t;
  s && (0, Cg.assignDefaults)(t, e.type), r.block(() => {
    for (const i of e.rules)
      (0, Xa.shouldUseRule)(n, i) && tl(t, i.keyword, i.definition, e.type);
  });
}
function Zg(t, e) {
  t.schemaEnv.meta || !t.opts.strictTypes || (Kg(t, e), t.opts.allowUnionTypes || Gg(t, e), Jg(t, t.dataTypes));
}
function Kg(t, e) {
  if (e.length) {
    if (!t.dataTypes.length) {
      t.dataTypes = e;
      return;
    }
    e.forEach((r) => {
      Qu(t.dataTypes, r) || Qa(t, `type "${r}" not allowed by context "${t.dataTypes.join(",")}"`);
    }), Xg(t, e);
  }
}
function Gg(t, e) {
  e.length > 1 && !(e.length === 2 && e.includes("null")) && Qa(t, "use allowUnionTypes to allow union type keyword");
}
function Jg(t, e) {
  const r = t.self.RULES.all;
  for (const n in r) {
    const s = r[n];
    if (typeof s == "object" && (0, Xa.shouldUseRule)(t.schema, s)) {
      const { type: i } = s.definition;
      i.length && !i.some((a) => Yg(e, a)) && Qa(t, `missing type "${i.join(",")}" for keyword "${n}"`);
    }
  }
}
function Yg(t, e) {
  return t.includes(e) || e === "number" && t.includes("integer");
}
function Qu(t, e) {
  return t.includes(e) || e === "integer" && t.includes("number");
}
function Xg(t, e) {
  const r = [];
  for (const n of t.dataTypes)
    Qu(e, n) ? r.push(n) : e.includes("integer") && n === "number" && r.push("integer");
  t.dataTypes = r;
}
function Qa(t, e) {
  const r = t.schemaEnv.baseId + t.errSchemaPath;
  e += ` at "${r}" (strictTypes)`, (0, kr.checkStrictMode)(t, e, t.opts.strictTypes);
}
class el {
  constructor(e, r, n) {
    if ((0, Gn.validateKeywordUsage)(e, r, n), this.gen = e.gen, this.allErrors = e.allErrors, this.keyword = n, this.data = e.data, this.schema = e.schema[n], this.$data = r.$data && e.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, kr.schemaRefOrVal)(e, this.schema, n, this.$data), this.schemaType = r.schemaType, this.parentSchema = e.schema, this.params = {}, this.it = e, this.def = r, this.$data)
      this.schemaCode = e.gen.const("vSchema", rl(this.$data, e));
    else if (this.schemaCode = this.schemaValue, !(0, Gn.validSchemaType)(this.schema, r.schemaType, r.allowUndefined))
      throw new Error(`${n} value must be ${JSON.stringify(r.schemaType)}`);
    ("code" in r ? r.trackErrors : r.errors !== !1) && (this.errsCount = e.gen.const("_errs", Ie.default.errors));
  }
  result(e, r, n) {
    this.failResult((0, ve.not)(e), r, n);
  }
  failResult(e, r, n) {
    this.gen.if(e), n ? n() : this.error(), r ? (this.gen.else(), r(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  pass(e, r) {
    this.failResult((0, ve.not)(e), void 0, r);
  }
  fail(e) {
    if (e === void 0) {
      this.error(), this.allErrors || this.gen.if(!1);
      return;
    }
    this.gen.if(e), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  fail$data(e) {
    if (!this.$data)
      return this.fail(e);
    const { schemaCode: r } = this;
    this.fail((0, ve._)`${r} !== undefined && (${(0, ve.or)(this.invalid$data(), e)})`);
  }
  error(e, r, n) {
    if (r) {
      this.setParams(r), this._error(e, n), this.setParams({});
      return;
    }
    this._error(e, n);
  }
  _error(e, r) {
    (e ? zn.reportExtraError : zn.reportError)(this, this.def.error, r);
  }
  $dataError() {
    (0, zn.reportError)(this, this.def.$dataError || zn.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    (0, zn.resetErrorsCount)(this.gen, this.errsCount);
  }
  ok(e) {
    this.allErrors || this.gen.if(e);
  }
  setParams(e, r) {
    r ? Object.assign(this.params, e) : this.params = e;
  }
  block$data(e, r, n = ve.nil) {
    this.gen.block(() => {
      this.check$data(e, n), r();
    });
  }
  check$data(e = ve.nil, r = ve.nil) {
    if (!this.$data)
      return;
    const { gen: n, schemaCode: s, schemaType: i, def: a } = this;
    n.if((0, ve.or)((0, ve._)`${s} === undefined`, r)), e !== ve.nil && n.assign(e, !0), (i.length || a.validateSchema) && (n.elseIf(this.invalid$data()), this.$dataError(), e !== ve.nil && n.assign(e, !1)), n.else();
  }
  invalid$data() {
    const { gen: e, schemaCode: r, schemaType: n, def: s, it: i } = this;
    return (0, ve.or)(a(), o());
    function a() {
      if (n.length) {
        if (!(r instanceof ve.Name))
          throw new Error("ajv implementation error");
        const c = Array.isArray(n) ? n : [n];
        return (0, ve._)`${(0, bi.checkDataTypes)(c, r, i.opts.strictNumbers, bi.DataType.Wrong)}`;
      }
      return ve.nil;
    }
    function o() {
      if (s.validateSchema) {
        const c = e.scopeValue("validate$data", { ref: s.validateSchema });
        return (0, ve._)`!${c}(${r})`;
      }
      return ve.nil;
    }
  }
  subschema(e, r) {
    const n = (0, Ji.getSubschema)(this.it, e);
    (0, Ji.extendSubschemaData)(n, this.it, e), (0, Ji.extendSubschemaMode)(n, e);
    const s = { ...this.it, ...n, items: void 0, props: void 0 };
    return Ug(s, r), s;
  }
  mergeEvaluated(e, r) {
    const { it: n, gen: s } = this;
    n.opts.unevaluated && (n.props !== !0 && e.props !== void 0 && (n.props = kr.mergeEvaluated.props(s, e.props, n.props, r)), n.items !== !0 && e.items !== void 0 && (n.items = kr.mergeEvaluated.items(s, e.items, n.items, r)));
  }
  mergeValidEvaluated(e, r) {
    const { it: n, gen: s } = this;
    if (n.opts.unevaluated && (n.props !== !0 || n.items !== !0))
      return s.if(r, () => this.mergeEvaluated(e, ve.Name)), !0;
  }
}
ir.KeywordCxt = el;
function tl(t, e, r, n) {
  const s = new el(t, r, e);
  "code" in r ? r.code(s, n) : s.$data && r.validate ? (0, Gn.funcKeywordCode)(s, r) : "macro" in r ? (0, Gn.macroKeywordCode)(s, r) : (r.compile || r.validate) && (0, Gn.funcKeywordCode)(s, r);
}
const Qg = /^\/(?:[^~]|~0|~1)*$/, ey = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function rl(t, { dataLevel: e, dataNames: r, dataPathArr: n }) {
  let s, i;
  if (t === "")
    return Ie.default.rootData;
  if (t[0] === "/") {
    if (!Qg.test(t))
      throw new Error(`Invalid JSON-pointer: ${t}`);
    s = t, i = Ie.default.rootData;
  } else {
    const l = ey.exec(t);
    if (!l)
      throw new Error(`Invalid JSON-pointer: ${t}`);
    const f = +l[1];
    if (s = l[2], s === "#") {
      if (f >= e)
        throw new Error(c("property/index", f));
      return n[e - f];
    }
    if (f > e)
      throw new Error(c("data", f));
    if (i = r[e - f], !s)
      return i;
  }
  let a = i;
  const o = s.split("/");
  for (const l of o)
    l && (i = (0, ve._)`${i}${(0, ve.getProperty)((0, kr.unescapeJsonPointer)(l))}`, a = (0, ve._)`${a} && ${i}`);
  return a;
  function c(l, f) {
    return `Cannot access ${l} ${f} levels up, current level is ${e}`;
  }
}
ir.getData = rl;
var ks = {};
Object.defineProperty(ks, "__esModule", { value: !0 });
class ty extends Error {
  constructor(e) {
    super("validation failed"), this.errors = e, this.ajv = this.validation = !0;
  }
}
ks.default = ty;
var Ts = {};
Object.defineProperty(Ts, "__esModule", { value: !0 });
const Yi = Tt;
class ry extends Error {
  constructor(e, r, n, s) {
    super(s || `can't resolve reference ${n} from id ${r}`), this.missingRef = (0, Yi.resolveUrl)(e, r, n), this.missingSchema = (0, Yi.normalizeId)((0, Yi.getFullPath)(e, this.missingRef));
  }
}
Ts.default = ry;
var Ut = {};
Object.defineProperty(Ut, "__esModule", { value: !0 });
Ut.resolveSchema = Ut.getCompilingSchema = Ut.resolveRef = Ut.compileSchema = Ut.SchemaEnv = void 0;
const Qt = qe, ny = ks, Kr = yr, tr = Tt, pc = He, sy = ir;
class Mi {
  constructor(e) {
    var r;
    this.refs = {}, this.dynamicAnchors = {};
    let n;
    typeof e.schema == "object" && (n = e.schema), this.schema = e.schema, this.schemaId = e.schemaId, this.root = e.root || this, this.baseId = (r = e.baseId) !== null && r !== void 0 ? r : (0, tr.normalizeId)(n?.[e.schemaId || "$id"]), this.schemaPath = e.schemaPath, this.localRefs = e.localRefs, this.meta = e.meta, this.$async = n?.$async, this.refs = {};
  }
}
Ut.SchemaEnv = Mi;
function eo(t) {
  const e = nl.call(this, t);
  if (e)
    return e;
  const r = (0, tr.getFullPath)(this.opts.uriResolver, t.root.baseId), { es5: n, lines: s } = this.opts.code, { ownProperties: i } = this.opts, a = new Qt.CodeGen(this.scope, { es5: n, lines: s, ownProperties: i });
  let o;
  t.$async && (o = a.scopeValue("Error", {
    ref: ny.default,
    code: (0, Qt._)`require("ajv/dist/runtime/validation_error").default`
  }));
  const c = a.scopeName("validate");
  t.validateName = c;
  const l = {
    gen: a,
    allErrors: this.opts.allErrors,
    data: Kr.default.data,
    parentData: Kr.default.parentData,
    parentDataProperty: Kr.default.parentDataProperty,
    dataNames: [Kr.default.data],
    dataPathArr: [Qt.nil],
    dataLevel: 0,
    dataTypes: [],
    definedProperties: /* @__PURE__ */ new Set(),
    topSchemaRef: a.scopeValue("schema", this.opts.code.source === !0 ? { ref: t.schema, code: (0, Qt.stringify)(t.schema) } : { ref: t.schema }),
    validateName: c,
    ValidationError: o,
    schema: t.schema,
    schemaEnv: t,
    rootId: r,
    baseId: t.baseId || r,
    schemaPath: Qt.nil,
    errSchemaPath: t.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, Qt._)`""`,
    opts: this.opts,
    self: this
  };
  let f;
  try {
    this._compilations.add(t), (0, sy.validateFunctionCode)(l), a.optimize(this.opts.code.optimize);
    const h = a.toString();
    f = `${a.scopeRefs(Kr.default.scope)}return ${h}`, this.opts.code.process && (f = this.opts.code.process(f, t));
    const S = new Function(`${Kr.default.self}`, `${Kr.default.scope}`, f)(this, this.scope.get());
    if (this.scope.value(c, { ref: S }), S.errors = null, S.schema = t.schema, S.schemaEnv = t, t.$async && (S.$async = !0), this.opts.code.source === !0 && (S.source = { validateName: c, validateCode: h, scopeValues: a._values }), this.opts.unevaluated) {
      const { props: E, items: M } = l;
      S.evaluated = {
        props: E instanceof Qt.Name ? void 0 : E,
        items: M instanceof Qt.Name ? void 0 : M,
        dynamicProps: E instanceof Qt.Name,
        dynamicItems: M instanceof Qt.Name
      }, S.source && (S.source.evaluated = (0, Qt.stringify)(S.evaluated));
    }
    return t.validate = S, t;
  } catch (h) {
    throw delete t.validate, delete t.validateName, f && this.logger.error("Error compiling schema, function code:", f), h;
  } finally {
    this._compilations.delete(t);
  }
}
Ut.compileSchema = eo;
function iy(t, e, r) {
  var n;
  r = (0, tr.resolveUrl)(this.opts.uriResolver, e, r);
  const s = t.refs[r];
  if (s)
    return s;
  let i = cy.call(this, t, r);
  if (i === void 0) {
    const a = (n = t.localRefs) === null || n === void 0 ? void 0 : n[r], { schemaId: o } = this.opts;
    a && (i = new Mi({ schema: a, schemaId: o, root: t, baseId: e }));
  }
  if (i !== void 0)
    return t.refs[r] = ay.call(this, i);
}
Ut.resolveRef = iy;
function ay(t) {
  return (0, tr.inlineRef)(t.schema, this.opts.inlineRefs) ? t.schema : t.validate ? t : eo.call(this, t);
}
function nl(t) {
  for (const e of this._compilations)
    if (oy(e, t))
      return e;
}
Ut.getCompilingSchema = nl;
function oy(t, e) {
  return t.schema === e.schema && t.root === e.root && t.baseId === e.baseId;
}
function cy(t, e) {
  let r;
  for (; typeof (r = this.refs[e]) == "string"; )
    e = r;
  return r || this.schemas[e] || ji.call(this, t, e);
}
function ji(t, e) {
  const r = this.opts.uriResolver.parse(e), n = (0, tr._getFullPath)(this.opts.uriResolver, r);
  let s = (0, tr.getFullPath)(this.opts.uriResolver, t.baseId, void 0);
  if (Object.keys(t.schema).length > 0 && n === s)
    return Xi.call(this, r, t);
  const i = (0, tr.normalizeId)(n), a = this.refs[i] || this.schemas[i];
  if (typeof a == "string") {
    const o = ji.call(this, t, a);
    return typeof o?.schema != "object" ? void 0 : Xi.call(this, r, o);
  }
  if (typeof a?.schema == "object") {
    if (a.validate || eo.call(this, a), i === (0, tr.normalizeId)(e)) {
      const { schema: o } = a, { schemaId: c } = this.opts, l = o[c];
      return l && (s = (0, tr.resolveUrl)(this.opts.uriResolver, s, l)), new Mi({ schema: o, schemaId: c, root: t, baseId: s });
    }
    return Xi.call(this, r, a);
  }
}
Ut.resolveSchema = ji;
const uy = /* @__PURE__ */ new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function Xi(t, { baseId: e, schema: r, root: n }) {
  var s;
  if (((s = t.fragment) === null || s === void 0 ? void 0 : s[0]) !== "/")
    return;
  for (const o of t.fragment.slice(1).split("/")) {
    if (typeof r == "boolean")
      return;
    const c = r[(0, pc.unescapeFragment)(o)];
    if (c === void 0)
      return;
    r = c;
    const l = typeof r == "object" && r[this.opts.schemaId];
    !uy.has(o) && l && (e = (0, tr.resolveUrl)(this.opts.uriResolver, e, l));
  }
  let i;
  if (typeof r != "boolean" && r.$ref && !(0, pc.schemaHasRulesButRef)(r, this.RULES)) {
    const o = (0, tr.resolveUrl)(this.opts.uriResolver, e, r.$ref);
    i = ji.call(this, n, o);
  }
  const { schemaId: a } = this.opts;
  if (i = i || new Mi({ schema: r, schemaId: a, root: n, baseId: e }), i.schema !== i.root.schema)
    return i;
}
const ly = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", dy = "Meta-schema for $data reference (JSON AnySchema extension proposal)", fy = "object", hy = [
  "$data"
], py = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
}, my = !1, gy = {
  $id: ly,
  description: dy,
  type: fy,
  required: hy,
  properties: py,
  additionalProperties: my
};
var to = {}, $a = { exports: {} };
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function(t, e) {
  (function(r, n) {
    n(e);
  })(wa, function(r) {
    function n() {
      for (var T = arguments.length, _ = Array(T), I = 0; I < T; I++)
        _[I] = arguments[I];
      if (_.length > 1) {
        _[0] = _[0].slice(0, -1);
        for (var q = _.length - 1, W = 1; W < q; ++W)
          _[W] = _[W].slice(1, -1);
        return _[q] = _[q].slice(1), _.join("");
      } else
        return _[0];
    }
    function s(T) {
      return "(?:" + T + ")";
    }
    function i(T) {
      return T === void 0 ? "undefined" : T === null ? "null" : Object.prototype.toString.call(T).split(" ").pop().split("]").shift().toLowerCase();
    }
    function a(T) {
      return T.toUpperCase();
    }
    function o(T) {
      return T != null ? T instanceof Array ? T : typeof T.length != "number" || T.split || T.setInterval || T.call ? [T] : Array.prototype.slice.call(T) : [];
    }
    function c(T, _) {
      var I = T;
      if (_)
        for (var q in _)
          I[q] = _[q];
      return I;
    }
    function l(T) {
      var _ = "[A-Za-z]", I = "[0-9]", q = n(I, "[A-Fa-f]"), W = s(s("%[EFef]" + q + "%" + q + q + "%" + q + q) + "|" + s("%[89A-Fa-f]" + q + "%" + q + q) + "|" + s("%" + q + q)), ie = "[\\:\\/\\?\\#\\[\\]\\@]", ge = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", _e = n(ie, ge), Ye = T ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", et = T ? "[\\uE000-\\uF8FF]" : "[]", Ce = n(_, I, "[\\-\\.\\_\\~]", Ye);
      s(_ + n(_, I, "[\\+\\-\\.]") + "*"), s(s(W + "|" + n(Ce, ge, "[\\:]")) + "*");
      var tt = s(s("25[0-5]") + "|" + s("2[0-4]" + I) + "|" + s("1" + I + I) + "|" + s("0?[1-9]" + I) + "|0?0?" + I), ct = s(tt + "\\." + tt + "\\." + tt + "\\." + tt), Pe = s(q + "{1,4}"), st = s(s(Pe + "\\:" + Pe) + "|" + ct), ye = s(s(Pe + "\\:") + "{6}" + st), xe = s("\\:\\:" + s(Pe + "\\:") + "{5}" + st), jt = s(s(Pe) + "?\\:\\:" + s(Pe + "\\:") + "{4}" + st), Vt = s(s(s(Pe + "\\:") + "{0,1}" + Pe) + "?\\:\\:" + s(Pe + "\\:") + "{3}" + st), Bt = s(s(s(Pe + "\\:") + "{0,2}" + Pe) + "?\\:\\:" + s(Pe + "\\:") + "{2}" + st), Yt = s(s(s(Pe + "\\:") + "{0,3}" + Pe) + "?\\:\\:" + Pe + "\\:" + st), zt = s(s(s(Pe + "\\:") + "{0,4}" + Pe) + "?\\:\\:" + st), me = s(s(s(Pe + "\\:") + "{0,5}" + Pe) + "?\\:\\:" + Pe), Be = s(s(s(Pe + "\\:") + "{0,6}" + Pe) + "?\\:\\:"), ot = s([ye, xe, jt, Vt, Bt, Yt, zt, me, Be].join("|")), ze = s(s(Ce + "|" + W) + "+");
      s("[vV]" + q + "+\\." + n(Ce, ge, "[\\:]") + "+"), s(s(W + "|" + n(Ce, ge)) + "*");
      var yt = s(W + "|" + n(Ce, ge, "[\\:\\@]"));
      return s(s(W + "|" + n(Ce, ge, "[\\@]")) + "+"), s(s(yt + "|" + n("[\\/\\?]", et)) + "*"), {
        NOT_SCHEME: new RegExp(n("[^]", _, I, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(n("[^\\%\\:]", Ce, ge), "g"),
        NOT_HOST: new RegExp(n("[^\\%\\[\\]\\:]", Ce, ge), "g"),
        NOT_PATH: new RegExp(n("[^\\%\\/\\:\\@]", Ce, ge), "g"),
        NOT_PATH_NOSCHEME: new RegExp(n("[^\\%\\/\\@]", Ce, ge), "g"),
        NOT_QUERY: new RegExp(n("[^\\%]", Ce, ge, "[\\:\\@\\/\\?]", et), "g"),
        NOT_FRAGMENT: new RegExp(n("[^\\%]", Ce, ge, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(n("[^]", Ce, ge), "g"),
        UNRESERVED: new RegExp(Ce, "g"),
        OTHER_CHARS: new RegExp(n("[^\\%]", Ce, _e), "g"),
        PCT_ENCODED: new RegExp(W, "g"),
        IPV4ADDRESS: new RegExp("^(" + ct + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + ot + ")" + s(s("\\%25|\\%(?!" + q + "{2})") + "(" + ze + ")") + "?\\]?$")
        //RFC 6874, with relaxed parsing rules
      };
    }
    var f = l(!1), h = l(!0), y = /* @__PURE__ */ function() {
      function T(_, I) {
        var q = [], W = !0, ie = !1, ge = void 0;
        try {
          for (var _e = _[Symbol.iterator](), Ye; !(W = (Ye = _e.next()).done) && (q.push(Ye.value), !(I && q.length === I)); W = !0)
            ;
        } catch (et) {
          ie = !0, ge = et;
        } finally {
          try {
            !W && _e.return && _e.return();
          } finally {
            if (ie)
              throw ge;
          }
        }
        return q;
      }
      return function(_, I) {
        if (Array.isArray(_))
          return _;
        if (Symbol.iterator in Object(_))
          return T(_, I);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    }(), S = function(T) {
      if (Array.isArray(T)) {
        for (var _ = 0, I = Array(T.length); _ < T.length; _++)
          I[_] = T[_];
        return I;
      } else
        return Array.from(T);
    }, E = 2147483647, M = 36, A = 1, $ = 26, x = 38, P = 700, U = 72, B = 128, w = "-", R = /^xn--/, z = /[^\0-\x7E]/, re = /[\x2E\u3002\uFF0E\uFF61]/g, oe = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, Ee = M - A, he = Math.floor, ke = String.fromCharCode;
    function Oe(T) {
      throw new RangeError(oe[T]);
    }
    function ht(T, _) {
      for (var I = [], q = T.length; q--; )
        I[q] = _(T[q]);
      return I;
    }
    function Me(T, _) {
      var I = T.split("@"), q = "";
      I.length > 1 && (q = I[0] + "@", T = I[1]), T = T.replace(re, ".");
      var W = T.split("."), ie = ht(W, _).join(".");
      return q + ie;
    }
    function Te(T) {
      for (var _ = [], I = 0, q = T.length; I < q; ) {
        var W = T.charCodeAt(I++);
        if (W >= 55296 && W <= 56319 && I < q) {
          var ie = T.charCodeAt(I++);
          (ie & 64512) == 56320 ? _.push(((W & 1023) << 10) + (ie & 1023) + 65536) : (_.push(W), I--);
        } else
          _.push(W);
      }
      return _;
    }
    var vt = function(_) {
      return String.fromCodePoint.apply(String, S(_));
    }, Se = function(_) {
      return _ - 48 < 10 ? _ - 22 : _ - 65 < 26 ? _ - 65 : _ - 97 < 26 ? _ - 97 : M;
    }, Y = function(_, I) {
      return _ + 22 + 75 * (_ < 26) - ((I != 0) << 5);
    }, F = function(_, I, q) {
      var W = 0;
      for (
        _ = q ? he(_ / P) : _ >> 1, _ += he(_ / I);
        /* no initialization */
        _ > Ee * $ >> 1;
        W += M
      )
        _ = he(_ / Ee);
      return he(W + (Ee + 1) * _ / (_ + x));
    }, g = function(_) {
      var I = [], q = _.length, W = 0, ie = B, ge = U, _e = _.lastIndexOf(w);
      _e < 0 && (_e = 0);
      for (var Ye = 0; Ye < _e; ++Ye)
        _.charCodeAt(Ye) >= 128 && Oe("not-basic"), I.push(_.charCodeAt(Ye));
      for (var et = _e > 0 ? _e + 1 : 0; et < q; ) {
        for (
          var Ce = W, tt = 1, ct = M;
          ;
          /* no condition */
          ct += M
        ) {
          et >= q && Oe("invalid-input");
          var Pe = Se(_.charCodeAt(et++));
          (Pe >= M || Pe > he((E - W) / tt)) && Oe("overflow"), W += Pe * tt;
          var st = ct <= ge ? A : ct >= ge + $ ? $ : ct - ge;
          if (Pe < st)
            break;
          var ye = M - st;
          tt > he(E / ye) && Oe("overflow"), tt *= ye;
        }
        var xe = I.length + 1;
        ge = F(W - Ce, xe, Ce == 0), he(W / xe) > E - ie && Oe("overflow"), ie += he(W / xe), W %= xe, I.splice(W++, 0, ie);
      }
      return String.fromCodePoint.apply(String, I);
    }, m = function(_) {
      var I = [];
      _ = Te(_);
      var q = _.length, W = B, ie = 0, ge = U, _e = !0, Ye = !1, et = void 0;
      try {
        for (var Ce = _[Symbol.iterator](), tt; !(_e = (tt = Ce.next()).done); _e = !0) {
          var ct = tt.value;
          ct < 128 && I.push(ke(ct));
        }
      } catch (Ar) {
        Ye = !0, et = Ar;
      } finally {
        try {
          !_e && Ce.return && Ce.return();
        } finally {
          if (Ye)
            throw et;
        }
      }
      var Pe = I.length, st = Pe;
      for (Pe && I.push(w); st < q; ) {
        var ye = E, xe = !0, jt = !1, Vt = void 0;
        try {
          for (var Bt = _[Symbol.iterator](), Yt; !(xe = (Yt = Bt.next()).done); xe = !0) {
            var zt = Yt.value;
            zt >= W && zt < ye && (ye = zt);
          }
        } catch (Ar) {
          jt = !0, Vt = Ar;
        } finally {
          try {
            !xe && Bt.return && Bt.return();
          } finally {
            if (jt)
              throw Vt;
          }
        }
        var me = st + 1;
        ye - W > he((E - ie) / me) && Oe("overflow"), ie += (ye - W) * me, W = ye;
        var Be = !0, ot = !1, ze = void 0;
        try {
          for (var yt = _[Symbol.iterator](), Xt; !(Be = (Xt = yt.next()).done); Be = !0) {
            var St = Xt.value;
            if (St < W && ++ie > E && Oe("overflow"), St == W) {
              for (
                var Wt = ie, _t = M;
                ;
                /* no condition */
                _t += M
              ) {
                var Pt = _t <= ge ? A : _t >= ge + $ ? $ : _t - ge;
                if (Wt < Pt)
                  break;
                var ft = Wt - Pt, It = M - Pt;
                I.push(ke(Y(Pt + ft % It, 0))), Wt = he(ft / It);
              }
              I.push(ke(Y(Wt, 0))), ge = F(ie, me, st == Pe), ie = 0, ++st;
            }
          }
        } catch (Ar) {
          ot = !0, ze = Ar;
        } finally {
          try {
            !Be && yt.return && yt.return();
          } finally {
            if (ot)
              throw ze;
          }
        }
        ++ie, ++W;
      }
      return I.join("");
    }, p = function(_) {
      return Me(_, function(I) {
        return R.test(I) ? g(I.slice(4).toLowerCase()) : I;
      });
    }, k = function(_) {
      return Me(_, function(I) {
        return z.test(I) ? "xn--" + m(I) : I;
      });
    }, H = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      version: "2.1.0",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      ucs2: {
        decode: Te,
        encode: vt
      },
      decode: g,
      encode: m,
      toASCII: k,
      toUnicode: p
    }, J = {};
    function O(T) {
      var _ = T.charCodeAt(0), I = void 0;
      return _ < 16 ? I = "%0" + _.toString(16).toUpperCase() : _ < 128 ? I = "%" + _.toString(16).toUpperCase() : _ < 2048 ? I = "%" + (_ >> 6 | 192).toString(16).toUpperCase() + "%" + (_ & 63 | 128).toString(16).toUpperCase() : I = "%" + (_ >> 12 | 224).toString(16).toUpperCase() + "%" + (_ >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (_ & 63 | 128).toString(16).toUpperCase(), I;
    }
    function V(T) {
      for (var _ = "", I = 0, q = T.length; I < q; ) {
        var W = parseInt(T.substr(I + 1, 2), 16);
        if (W < 128)
          _ += String.fromCharCode(W), I += 3;
        else if (W >= 194 && W < 224) {
          if (q - I >= 6) {
            var ie = parseInt(T.substr(I + 4, 2), 16);
            _ += String.fromCharCode((W & 31) << 6 | ie & 63);
          } else
            _ += T.substr(I, 6);
          I += 6;
        } else if (W >= 224) {
          if (q - I >= 9) {
            var ge = parseInt(T.substr(I + 4, 2), 16), _e = parseInt(T.substr(I + 7, 2), 16);
            _ += String.fromCharCode((W & 15) << 12 | (ge & 63) << 6 | _e & 63);
          } else
            _ += T.substr(I, 9);
          I += 9;
        } else
          _ += T.substr(I, 3), I += 3;
      }
      return _;
    }
    function L(T, _) {
      function I(q) {
        var W = V(q);
        return W.match(_.UNRESERVED) ? W : q;
      }
      return T.scheme && (T.scheme = String(T.scheme).replace(_.PCT_ENCODED, I).toLowerCase().replace(_.NOT_SCHEME, "")), T.userinfo !== void 0 && (T.userinfo = String(T.userinfo).replace(_.PCT_ENCODED, I).replace(_.NOT_USERINFO, O).replace(_.PCT_ENCODED, a)), T.host !== void 0 && (T.host = String(T.host).replace(_.PCT_ENCODED, I).toLowerCase().replace(_.NOT_HOST, O).replace(_.PCT_ENCODED, a)), T.path !== void 0 && (T.path = String(T.path).replace(_.PCT_ENCODED, I).replace(T.scheme ? _.NOT_PATH : _.NOT_PATH_NOSCHEME, O).replace(_.PCT_ENCODED, a)), T.query !== void 0 && (T.query = String(T.query).replace(_.PCT_ENCODED, I).replace(_.NOT_QUERY, O).replace(_.PCT_ENCODED, a)), T.fragment !== void 0 && (T.fragment = String(T.fragment).replace(_.PCT_ENCODED, I).replace(_.NOT_FRAGMENT, O).replace(_.PCT_ENCODED, a)), T;
    }
    function G(T) {
      return T.replace(/^0*(.*)/, "$1") || "0";
    }
    function Q(T, _) {
      var I = T.match(_.IPV4ADDRESS) || [], q = y(I, 2), W = q[1];
      return W ? W.split(".").map(G).join(".") : T;
    }
    function X(T, _) {
      var I = T.match(_.IPV6ADDRESS) || [], q = y(I, 3), W = q[1], ie = q[2];
      if (W) {
        for (var ge = W.toLowerCase().split("::").reverse(), _e = y(ge, 2), Ye = _e[0], et = _e[1], Ce = et ? et.split(":").map(G) : [], tt = Ye.split(":").map(G), ct = _.IPV4ADDRESS.test(tt[tt.length - 1]), Pe = ct ? 7 : 8, st = tt.length - Pe, ye = Array(Pe), xe = 0; xe < Pe; ++xe)
          ye[xe] = Ce[xe] || tt[st + xe] || "";
        ct && (ye[Pe - 1] = Q(ye[Pe - 1], _));
        var jt = ye.reduce(function(me, Be, ot) {
          if (!Be || Be === "0") {
            var ze = me[me.length - 1];
            ze && ze.index + ze.length === ot ? ze.length++ : me.push({ index: ot, length: 1 });
          }
          return me;
        }, []), Vt = jt.sort(function(me, Be) {
          return Be.length - me.length;
        })[0], Bt = void 0;
        if (Vt && Vt.length > 1) {
          var Yt = ye.slice(0, Vt.index), zt = ye.slice(Vt.index + Vt.length);
          Bt = Yt.join(":") + "::" + zt.join(":");
        } else
          Bt = ye.join(":");
        return ie && (Bt += "%" + ie), Bt;
      } else
        return T;
    }
    var K = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i, se = "".match(/(){0}/)[1] === void 0;
    function ue(T) {
      var _ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, I = {}, q = _.iri !== !1 ? h : f;
      _.reference === "suffix" && (T = (_.scheme ? _.scheme + ":" : "") + "//" + T);
      var W = T.match(K);
      if (W) {
        se ? (I.scheme = W[1], I.userinfo = W[3], I.host = W[4], I.port = parseInt(W[5], 10), I.path = W[6] || "", I.query = W[7], I.fragment = W[8], isNaN(I.port) && (I.port = W[5])) : (I.scheme = W[1] || void 0, I.userinfo = T.indexOf("@") !== -1 ? W[3] : void 0, I.host = T.indexOf("//") !== -1 ? W[4] : void 0, I.port = parseInt(W[5], 10), I.path = W[6] || "", I.query = T.indexOf("?") !== -1 ? W[7] : void 0, I.fragment = T.indexOf("#") !== -1 ? W[8] : void 0, isNaN(I.port) && (I.port = T.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? W[4] : void 0)), I.host && (I.host = X(Q(I.host, q), q)), I.scheme === void 0 && I.userinfo === void 0 && I.host === void 0 && I.port === void 0 && !I.path && I.query === void 0 ? I.reference = "same-document" : I.scheme === void 0 ? I.reference = "relative" : I.fragment === void 0 ? I.reference = "absolute" : I.reference = "uri", _.reference && _.reference !== "suffix" && _.reference !== I.reference && (I.error = I.error || "URI is not a " + _.reference + " reference.");
        var ie = J[(_.scheme || I.scheme || "").toLowerCase()];
        if (!_.unicodeSupport && (!ie || !ie.unicodeSupport)) {
          if (I.host && (_.domainHost || ie && ie.domainHost))
            try {
              I.host = H.toASCII(I.host.replace(q.PCT_ENCODED, V).toLowerCase());
            } catch (ge) {
              I.error = I.error || "Host's domain name can not be converted to ASCII via punycode: " + ge;
            }
          L(I, f);
        } else
          L(I, q);
        ie && ie.parse && ie.parse(I, _);
      } else
        I.error = I.error || "URI can not be parsed.";
      return I;
    }
    function Re(T, _) {
      var I = _.iri !== !1 ? h : f, q = [];
      return T.userinfo !== void 0 && (q.push(T.userinfo), q.push("@")), T.host !== void 0 && q.push(X(Q(String(T.host), I), I).replace(I.IPV6ADDRESS, function(W, ie, ge) {
        return "[" + ie + (ge ? "%25" + ge : "") + "]";
      })), (typeof T.port == "number" || typeof T.port == "string") && (q.push(":"), q.push(String(T.port))), q.length ? q.join("") : void 0;
    }
    var je = /^\.\.?\//, pe = /^\/\.(\/|$)/, we = /^\/\.\.(\/|$)/, Fe = /^\/?(?:.|\n)*?(?=\/|$)/;
    function ce(T) {
      for (var _ = []; T.length; )
        if (T.match(je))
          T = T.replace(je, "");
        else if (T.match(pe))
          T = T.replace(pe, "/");
        else if (T.match(we))
          T = T.replace(we, "/"), _.pop();
        else if (T === "." || T === "..")
          T = "";
        else {
          var I = T.match(Fe);
          if (I) {
            var q = I[0];
            T = T.slice(q.length), _.push(q);
          } else
            throw new Error("Unexpected dot segment condition");
        }
      return _.join("");
    }
    function We(T) {
      var _ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, I = _.iri ? h : f, q = [], W = J[(_.scheme || T.scheme || "").toLowerCase()];
      if (W && W.serialize && W.serialize(T, _), T.host && !I.IPV6ADDRESS.test(T.host)) {
        if (_.domainHost || W && W.domainHost)
          try {
            T.host = _.iri ? H.toUnicode(T.host) : H.toASCII(T.host.replace(I.PCT_ENCODED, V).toLowerCase());
          } catch (_e) {
            T.error = T.error || "Host's domain name can not be converted to " + (_.iri ? "Unicode" : "ASCII") + " via punycode: " + _e;
          }
      }
      L(T, I), _.reference !== "suffix" && T.scheme && (q.push(T.scheme), q.push(":"));
      var ie = Re(T, _);
      if (ie !== void 0 && (_.reference !== "suffix" && q.push("//"), q.push(ie), T.path && T.path.charAt(0) !== "/" && q.push("/")), T.path !== void 0) {
        var ge = T.path;
        !_.absolutePath && (!W || !W.absolutePath) && (ge = ce(ge)), ie === void 0 && (ge = ge.replace(/^\/\//, "/%2F")), q.push(ge);
      }
      return T.query !== void 0 && (q.push("?"), q.push(T.query)), T.fragment !== void 0 && (q.push("#"), q.push(T.fragment)), q.join("");
    }
    function bt(T, _) {
      var I = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, q = arguments[3], W = {};
      return q || (T = ue(We(T, I), I), _ = ue(We(_, I), I)), I = I || {}, !I.tolerant && _.scheme ? (W.scheme = _.scheme, W.userinfo = _.userinfo, W.host = _.host, W.port = _.port, W.path = ce(_.path || ""), W.query = _.query) : (_.userinfo !== void 0 || _.host !== void 0 || _.port !== void 0 ? (W.userinfo = _.userinfo, W.host = _.host, W.port = _.port, W.path = ce(_.path || ""), W.query = _.query) : (_.path ? (_.path.charAt(0) === "/" ? W.path = ce(_.path) : ((T.userinfo !== void 0 || T.host !== void 0 || T.port !== void 0) && !T.path ? W.path = "/" + _.path : T.path ? W.path = T.path.slice(0, T.path.lastIndexOf("/") + 1) + _.path : W.path = _.path, W.path = ce(W.path)), W.query = _.query) : (W.path = T.path, _.query !== void 0 ? W.query = _.query : W.query = T.query), W.userinfo = T.userinfo, W.host = T.host, W.port = T.port), W.scheme = T.scheme), W.fragment = _.fragment, W;
    }
    function lt(T, _, I) {
      var q = c({ scheme: "null" }, I);
      return We(bt(ue(T, q), ue(_, q), q, !0), q);
    }
    function nt(T, _) {
      return typeof T == "string" ? T = We(ue(T, _), _) : i(T) === "object" && (T = ue(We(T, _), _)), T;
    }
    function dt(T, _, I) {
      return typeof T == "string" ? T = We(ue(T, I), I) : i(T) === "object" && (T = We(T, I)), typeof _ == "string" ? _ = We(ue(_, I), I) : i(_) === "object" && (_ = We(_, I)), T === _;
    }
    function Mt(T, _) {
      return T && T.toString().replace(!_ || !_.iri ? f.ESCAPE : h.ESCAPE, O);
    }
    function pt(T, _) {
      return T && T.toString().replace(!_ || !_.iri ? f.PCT_ENCODED : h.PCT_ENCODED, V);
    }
    var qt = {
      scheme: "http",
      domainHost: !0,
      parse: function(_, I) {
        return _.host || (_.error = _.error || "HTTP URIs must have a host."), _;
      },
      serialize: function(_, I) {
        var q = String(_.scheme).toLowerCase() === "https";
        return (_.port === (q ? 443 : 80) || _.port === "") && (_.port = void 0), _.path || (_.path = "/"), _;
      }
    }, Jt = {
      scheme: "https",
      domainHost: qt.domainHost,
      parse: qt.parse,
      serialize: qt.serialize
    };
    function ae(T) {
      return typeof T.secure == "boolean" ? T.secure : String(T.scheme).toLowerCase() === "wss";
    }
    var or = {
      scheme: "ws",
      domainHost: !0,
      parse: function(_, I) {
        var q = _;
        return q.secure = ae(q), q.resourceName = (q.path || "/") + (q.query ? "?" + q.query : ""), q.path = void 0, q.query = void 0, q;
      },
      serialize: function(_, I) {
        if ((_.port === (ae(_) ? 443 : 80) || _.port === "") && (_.port = void 0), typeof _.secure == "boolean" && (_.scheme = _.secure ? "wss" : "ws", _.secure = void 0), _.resourceName) {
          var q = _.resourceName.split("?"), W = y(q, 2), ie = W[0], ge = W[1];
          _.path = ie && ie !== "/" ? ie : void 0, _.query = ge, _.resourceName = void 0;
        }
        return _.fragment = void 0, _;
      }
    }, Or = {
      scheme: "wss",
      domainHost: or.domainHost,
      parse: or.parse,
      serialize: or.serialize
    }, Ft = {}, vr = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]", mt = "[0-9A-Fa-f]", Je = s(s("%[EFef]" + mt + "%" + mt + mt + "%" + mt + mt) + "|" + s("%[89A-Fa-f]" + mt + "%" + mt + mt) + "|" + s("%" + mt + mt)), v = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]", N = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]", D = n(N, '[\\"\\\\]'), u = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]", d = new RegExp(vr, "g"), b = new RegExp(Je, "g"), j = new RegExp(n("[^]", v, "[\\.]", '[\\"]', D), "g"), C = new RegExp(n("[^]", vr, u), "g"), Z = C;
    function te(T) {
      var _ = V(T);
      return _.match(d) ? _ : T;
    }
    var fe = {
      scheme: "mailto",
      parse: function(_, I) {
        var q = _, W = q.to = q.path ? q.path.split(",") : [];
        if (q.path = void 0, q.query) {
          for (var ie = !1, ge = {}, _e = q.query.split("&"), Ye = 0, et = _e.length; Ye < et; ++Ye) {
            var Ce = _e[Ye].split("=");
            switch (Ce[0]) {
              case "to":
                for (var tt = Ce[1].split(","), ct = 0, Pe = tt.length; ct < Pe; ++ct)
                  W.push(tt[ct]);
                break;
              case "subject":
                q.subject = pt(Ce[1], I);
                break;
              case "body":
                q.body = pt(Ce[1], I);
                break;
              default:
                ie = !0, ge[pt(Ce[0], I)] = pt(Ce[1], I);
                break;
            }
          }
          ie && (q.headers = ge);
        }
        q.query = void 0;
        for (var st = 0, ye = W.length; st < ye; ++st) {
          var xe = W[st].split("@");
          if (xe[0] = pt(xe[0]), I.unicodeSupport)
            xe[1] = pt(xe[1], I).toLowerCase();
          else
            try {
              xe[1] = H.toASCII(pt(xe[1], I).toLowerCase());
            } catch (jt) {
              q.error = q.error || "Email address's domain name can not be converted to ASCII via punycode: " + jt;
            }
          W[st] = xe.join("@");
        }
        return q;
      },
      serialize: function(_, I) {
        var q = _, W = o(_.to);
        if (W) {
          for (var ie = 0, ge = W.length; ie < ge; ++ie) {
            var _e = String(W[ie]), Ye = _e.lastIndexOf("@"), et = _e.slice(0, Ye).replace(b, te).replace(b, a).replace(j, O), Ce = _e.slice(Ye + 1);
            try {
              Ce = I.iri ? H.toUnicode(Ce) : H.toASCII(pt(Ce, I).toLowerCase());
            } catch (st) {
              q.error = q.error || "Email address's domain name can not be converted to " + (I.iri ? "Unicode" : "ASCII") + " via punycode: " + st;
            }
            W[ie] = et + "@" + Ce;
          }
          q.path = W.join(",");
        }
        var tt = _.headers = _.headers || {};
        _.subject && (tt.subject = _.subject), _.body && (tt.body = _.body);
        var ct = [];
        for (var Pe in tt)
          tt[Pe] !== Ft[Pe] && ct.push(Pe.replace(b, te).replace(b, a).replace(C, O) + "=" + tt[Pe].replace(b, te).replace(b, a).replace(Z, O));
        return ct.length && (q.query = ct.join("&")), q;
      }
    }, be = /^([^\:]+)\:(.*)/, Ze = {
      scheme: "urn",
      parse: function(_, I) {
        var q = _.path && _.path.match(be), W = _;
        if (q) {
          var ie = I.scheme || W.scheme || "urn", ge = q[1].toLowerCase(), _e = q[2], Ye = ie + ":" + (I.nid || ge), et = J[Ye];
          W.nid = ge, W.nss = _e, W.path = void 0, et && (W = et.parse(W, I));
        } else
          W.error = W.error || "URN can not be parsed.";
        return W;
      },
      serialize: function(_, I) {
        var q = I.scheme || _.scheme || "urn", W = _.nid, ie = q + ":" + (I.nid || W), ge = J[ie];
        ge && (_ = ge.serialize(_, I));
        var _e = _, Ye = _.nss;
        return _e.path = (W || I.nid) + ":" + Ye, _e;
      }
    }, Ue = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/, Qe = {
      scheme: "urn:uuid",
      parse: function(_, I) {
        var q = _;
        return q.uuid = q.nss, q.nss = void 0, !I.tolerant && (!q.uuid || !q.uuid.match(Ue)) && (q.error = q.error || "UUID is not valid."), q;
      },
      serialize: function(_, I) {
        var q = _;
        return q.nss = (_.uuid || "").toLowerCase(), q;
      }
    };
    J[qt.scheme] = qt, J[Jt.scheme] = Jt, J[or.scheme] = or, J[Or.scheme] = Or, J[fe.scheme] = fe, J[Ze.scheme] = Ze, J[Qe.scheme] = Qe, r.SCHEMES = J, r.pctEncChar = O, r.pctDecChars = V, r.parse = ue, r.removeDotSegments = ce, r.serialize = We, r.resolveComponents = bt, r.resolve = lt, r.normalize = nt, r.equal = dt, r.escapeComponent = Mt, r.unescapeComponent = pt, Object.defineProperty(r, "__esModule", { value: !0 });
  });
})($a, $a.exports);
var yy = $a.exports;
Object.defineProperty(to, "__esModule", { value: !0 });
const sl = yy;
sl.code = 'require("ajv/dist/runtime/uri").default';
to.default = sl;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = void 0;
  var e = ir;
  Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
    return e.KeywordCxt;
  } });
  var r = qe;
  Object.defineProperty(t, "_", { enumerable: !0, get: function() {
    return r._;
  } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
    return r.str;
  } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
    return r.stringify;
  } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
    return r.nil;
  } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
    return r.Name;
  } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
    return r.CodeGen;
  } });
  const n = ks, s = Ts, i = un, a = Ut, o = qe, c = Tt, l = $s, f = He, h = gy, y = to, S = (Y, F) => new RegExp(Y, F);
  S.code = "new RegExp";
  const E = ["removeAdditional", "useDefaults", "coerceTypes"], M = /* @__PURE__ */ new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]), A = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  }, $ = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  }, x = 200;
  function P(Y) {
    var F, g, m, p, k, H, J, O, V, L, G, Q, X, K, se, ue, Re, je, pe, we, Fe, ce, We, bt, lt;
    const nt = Y.strict, dt = (F = Y.code) === null || F === void 0 ? void 0 : F.optimize, Mt = dt === !0 || dt === void 0 ? 1 : dt || 0, pt = (m = (g = Y.code) === null || g === void 0 ? void 0 : g.regExp) !== null && m !== void 0 ? m : S, qt = (p = Y.uriResolver) !== null && p !== void 0 ? p : y.default;
    return {
      strictSchema: (H = (k = Y.strictSchema) !== null && k !== void 0 ? k : nt) !== null && H !== void 0 ? H : !0,
      strictNumbers: (O = (J = Y.strictNumbers) !== null && J !== void 0 ? J : nt) !== null && O !== void 0 ? O : !0,
      strictTypes: (L = (V = Y.strictTypes) !== null && V !== void 0 ? V : nt) !== null && L !== void 0 ? L : "log",
      strictTuples: (Q = (G = Y.strictTuples) !== null && G !== void 0 ? G : nt) !== null && Q !== void 0 ? Q : "log",
      strictRequired: (K = (X = Y.strictRequired) !== null && X !== void 0 ? X : nt) !== null && K !== void 0 ? K : !1,
      code: Y.code ? { ...Y.code, optimize: Mt, regExp: pt } : { optimize: Mt, regExp: pt },
      loopRequired: (se = Y.loopRequired) !== null && se !== void 0 ? se : x,
      loopEnum: (ue = Y.loopEnum) !== null && ue !== void 0 ? ue : x,
      meta: (Re = Y.meta) !== null && Re !== void 0 ? Re : !0,
      messages: (je = Y.messages) !== null && je !== void 0 ? je : !0,
      inlineRefs: (pe = Y.inlineRefs) !== null && pe !== void 0 ? pe : !0,
      schemaId: (we = Y.schemaId) !== null && we !== void 0 ? we : "$id",
      addUsedSchema: (Fe = Y.addUsedSchema) !== null && Fe !== void 0 ? Fe : !0,
      validateSchema: (ce = Y.validateSchema) !== null && ce !== void 0 ? ce : !0,
      validateFormats: (We = Y.validateFormats) !== null && We !== void 0 ? We : !0,
      unicodeRegExp: (bt = Y.unicodeRegExp) !== null && bt !== void 0 ? bt : !0,
      int32range: (lt = Y.int32range) !== null && lt !== void 0 ? lt : !0,
      uriResolver: qt
    };
  }
  class U {
    constructor(F = {}) {
      this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), F = this.opts = { ...F, ...P(F) };
      const { es5: g, lines: m } = this.opts.code;
      this.scope = new o.ValueScope({ scope: {}, prefixes: M, es5: g, lines: m }), this.logger = he(F.logger);
      const p = F.validateFormats;
      F.validateFormats = !1, this.RULES = (0, i.getRules)(), B.call(this, A, F, "NOT SUPPORTED"), B.call(this, $, F, "DEPRECATED", "warn"), this._metaOpts = oe.call(this), F.formats && z.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), F.keywords && re.call(this, F.keywords), typeof F.meta == "object" && this.addMetaSchema(F.meta), R.call(this), F.validateFormats = p;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data: F, meta: g, schemaId: m } = this.opts;
      let p = h;
      m === "id" && (p = { ...h }, p.id = p.$id, delete p.$id), g && F && this.addMetaSchema(p, p[m], !1);
    }
    defaultMeta() {
      const { meta: F, schemaId: g } = this.opts;
      return this.opts.defaultMeta = typeof F == "object" ? F[g] || F : void 0;
    }
    validate(F, g) {
      let m;
      if (typeof F == "string") {
        if (m = this.getSchema(F), !m)
          throw new Error(`no schema with key or ref "${F}"`);
      } else
        m = this.compile(F);
      const p = m(g);
      return "$async" in m || (this.errors = m.errors), p;
    }
    compile(F, g) {
      const m = this._addSchema(F, g);
      return m.validate || this._compileSchemaEnv(m);
    }
    compileAsync(F, g) {
      if (typeof this.opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      const { loadSchema: m } = this.opts;
      return p.call(this, F, g);
      async function p(L, G) {
        await k.call(this, L.$schema);
        const Q = this._addSchema(L, G);
        return Q.validate || H.call(this, Q);
      }
      async function k(L) {
        L && !this.getSchema(L) && await p.call(this, { $ref: L }, !0);
      }
      async function H(L) {
        try {
          return this._compileSchemaEnv(L);
        } catch (G) {
          if (!(G instanceof s.default))
            throw G;
          return J.call(this, G), await O.call(this, G.missingSchema), H.call(this, L);
        }
      }
      function J({ missingSchema: L, missingRef: G }) {
        if (this.refs[L])
          throw new Error(`AnySchema ${L} is loaded but ${G} cannot be resolved`);
      }
      async function O(L) {
        const G = await V.call(this, L);
        this.refs[L] || await k.call(this, G.$schema), this.refs[L] || this.addSchema(G, L, g);
      }
      async function V(L) {
        const G = this._loading[L];
        if (G)
          return G;
        try {
          return await (this._loading[L] = m(L));
        } finally {
          delete this._loading[L];
        }
      }
    }
    // Adds schema to the instance
    addSchema(F, g, m, p = this.opts.validateSchema) {
      if (Array.isArray(F)) {
        for (const H of F)
          this.addSchema(H, void 0, m, p);
        return this;
      }
      let k;
      if (typeof F == "object") {
        const { schemaId: H } = this.opts;
        if (k = F[H], k !== void 0 && typeof k != "string")
          throw new Error(`schema ${H} must be string`);
      }
      return g = (0, c.normalizeId)(g || k), this._checkUnique(g), this.schemas[g] = this._addSchema(F, m, g, p, !0), this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(F, g, m = this.opts.validateSchema) {
      return this.addSchema(F, g, !0, m), this;
    }
    //  Validate schema against its meta-schema
    validateSchema(F, g) {
      if (typeof F == "boolean")
        return !0;
      let m;
      if (m = F.$schema, m !== void 0 && typeof m != "string")
        throw new Error("$schema must be a string");
      if (m = m || this.opts.defaultMeta || this.defaultMeta(), !m)
        return this.logger.warn("meta-schema not available"), this.errors = null, !0;
      const p = this.validate(m, F);
      if (!p && g) {
        const k = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(k);
        else
          throw new Error(k);
      }
      return p;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(F) {
      let g;
      for (; typeof (g = w.call(this, F)) == "string"; )
        F = g;
      if (g === void 0) {
        const { schemaId: m } = this.opts, p = new a.SchemaEnv({ schema: {}, schemaId: m });
        if (g = a.resolveSchema.call(this, p, F), !g)
          return;
        this.refs[F] = g;
      }
      return g.validate || this._compileSchemaEnv(g);
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(F) {
      if (F instanceof RegExp)
        return this._removeAllSchemas(this.schemas, F), this._removeAllSchemas(this.refs, F), this;
      switch (typeof F) {
        case "undefined":
          return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
        case "string": {
          const g = w.call(this, F);
          return typeof g == "object" && this._cache.delete(g.schema), delete this.schemas[F], delete this.refs[F], this;
        }
        case "object": {
          const g = F;
          this._cache.delete(g);
          let m = F[this.opts.schemaId];
          return m && (m = (0, c.normalizeId)(m), delete this.schemas[m], delete this.refs[m]), this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(F) {
      for (const g of F)
        this.addKeyword(g);
      return this;
    }
    addKeyword(F, g) {
      let m;
      if (typeof F == "string")
        m = F, typeof g == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), g.keyword = m);
      else if (typeof F == "object" && g === void 0) {
        if (g = F, m = g.keyword, Array.isArray(m) && !m.length)
          throw new Error("addKeywords: keyword must be string or non-empty array");
      } else
        throw new Error("invalid addKeywords parameters");
      if (Oe.call(this, m, g), !g)
        return (0, f.eachItem)(m, (k) => ht.call(this, k)), this;
      Te.call(this, g);
      const p = {
        ...g,
        type: (0, l.getJSONTypes)(g.type),
        schemaType: (0, l.getJSONTypes)(g.schemaType)
      };
      return (0, f.eachItem)(m, p.type.length === 0 ? (k) => ht.call(this, k, p) : (k) => p.type.forEach((H) => ht.call(this, k, p, H))), this;
    }
    getKeyword(F) {
      const g = this.RULES.all[F];
      return typeof g == "object" ? g.definition : !!g;
    }
    // Remove keyword
    removeKeyword(F) {
      const { RULES: g } = this;
      delete g.keywords[F], delete g.all[F];
      for (const m of g.rules) {
        const p = m.rules.findIndex((k) => k.keyword === F);
        p >= 0 && m.rules.splice(p, 1);
      }
      return this;
    }
    // Add format
    addFormat(F, g) {
      return typeof g == "string" && (g = new RegExp(g)), this.formats[F] = g, this;
    }
    errorsText(F = this.errors, { separator: g = ", ", dataVar: m = "data" } = {}) {
      return !F || F.length === 0 ? "No errors" : F.map((p) => `${m}${p.instancePath} ${p.message}`).reduce((p, k) => p + g + k);
    }
    $dataMetaSchema(F, g) {
      const m = this.RULES.all;
      F = JSON.parse(JSON.stringify(F));
      for (const p of g) {
        const k = p.split("/").slice(1);
        let H = F;
        for (const J of k)
          H = H[J];
        for (const J in m) {
          const O = m[J];
          if (typeof O != "object")
            continue;
          const { $data: V } = O.definition, L = H[J];
          V && L && (H[J] = Se(L));
        }
      }
      return F;
    }
    _removeAllSchemas(F, g) {
      for (const m in F) {
        const p = F[m];
        (!g || g.test(m)) && (typeof p == "string" ? delete F[m] : p && !p.meta && (this._cache.delete(p.schema), delete F[m]));
      }
    }
    _addSchema(F, g, m, p = this.opts.validateSchema, k = this.opts.addUsedSchema) {
      let H;
      const { schemaId: J } = this.opts;
      if (typeof F == "object")
        H = F[J];
      else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        if (typeof F != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let O = this._cache.get(F);
      if (O !== void 0)
        return O;
      m = (0, c.normalizeId)(H || m);
      const V = c.getSchemaRefs.call(this, F, m);
      return O = new a.SchemaEnv({ schema: F, schemaId: J, meta: g, baseId: m, localRefs: V }), this._cache.set(O.schema, O), k && !m.startsWith("#") && (m && this._checkUnique(m), this.refs[m] = O), p && this.validateSchema(F, !0), O;
    }
    _checkUnique(F) {
      if (this.schemas[F] || this.refs[F])
        throw new Error(`schema with key or id "${F}" already exists`);
    }
    _compileSchemaEnv(F) {
      if (F.meta ? this._compileMetaSchema(F) : a.compileSchema.call(this, F), !F.validate)
        throw new Error("ajv implementation error");
      return F.validate;
    }
    _compileMetaSchema(F) {
      const g = this.opts;
      this.opts = this._metaOpts;
      try {
        a.compileSchema.call(this, F);
      } finally {
        this.opts = g;
      }
    }
  }
  t.default = U, U.ValidationError = n.default, U.MissingRefError = s.default;
  function B(Y, F, g, m = "error") {
    for (const p in Y) {
      const k = p;
      k in F && this.logger[m](`${g}: option ${p}. ${Y[k]}`);
    }
  }
  function w(Y) {
    return Y = (0, c.normalizeId)(Y), this.schemas[Y] || this.refs[Y];
  }
  function R() {
    const Y = this.opts.schemas;
    if (Y)
      if (Array.isArray(Y))
        this.addSchema(Y);
      else
        for (const F in Y)
          this.addSchema(Y[F], F);
  }
  function z() {
    for (const Y in this.opts.formats) {
      const F = this.opts.formats[Y];
      F && this.addFormat(Y, F);
    }
  }
  function re(Y) {
    if (Array.isArray(Y)) {
      this.addVocabulary(Y);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const F in Y) {
      const g = Y[F];
      g.keyword || (g.keyword = F), this.addKeyword(g);
    }
  }
  function oe() {
    const Y = { ...this.opts };
    for (const F of E)
      delete Y[F];
    return Y;
  }
  const Ee = { log() {
  }, warn() {
  }, error() {
  } };
  function he(Y) {
    if (Y === !1)
      return Ee;
    if (Y === void 0)
      return console;
    if (Y.log && Y.warn && Y.error)
      return Y;
    throw new Error("logger must implement log, warn and error methods");
  }
  const ke = /^[a-z_$][a-z0-9_$:-]*$/i;
  function Oe(Y, F) {
    const { RULES: g } = this;
    if ((0, f.eachItem)(Y, (m) => {
      if (g.keywords[m])
        throw new Error(`Keyword ${m} is already defined`);
      if (!ke.test(m))
        throw new Error(`Keyword ${m} has invalid name`);
    }), !!F && F.$data && !("code" in F || "validate" in F))
      throw new Error('$data keyword must have "code" or "validate" function');
  }
  function ht(Y, F, g) {
    var m;
    const p = F?.post;
    if (g && p)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES: k } = this;
    let H = p ? k.post : k.rules.find(({ type: O }) => O === g);
    if (H || (H = { type: g, rules: [] }, k.rules.push(H)), k.keywords[Y] = !0, !F)
      return;
    const J = {
      keyword: Y,
      definition: {
        ...F,
        type: (0, l.getJSONTypes)(F.type),
        schemaType: (0, l.getJSONTypes)(F.schemaType)
      }
    };
    F.before ? Me.call(this, H, J, F.before) : H.rules.push(J), k.all[Y] = J, (m = F.implements) === null || m === void 0 || m.forEach((O) => this.addKeyword(O));
  }
  function Me(Y, F, g) {
    const m = Y.rules.findIndex((p) => p.keyword === g);
    m >= 0 ? Y.rules.splice(m, 0, F) : (Y.rules.push(F), this.logger.warn(`rule ${g} is not defined`));
  }
  function Te(Y) {
    let { metaSchema: F } = Y;
    F !== void 0 && (Y.$data && this.opts.$data && (F = Se(F)), Y.validateSchema = this.compile(F, !0));
  }
  const vt = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function Se(Y) {
    return { anyOf: [Y, vt] };
  }
})(Ru);
var ro = {}, no = {}, so = {};
Object.defineProperty(so, "__esModule", { value: !0 });
const vy = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
so.default = vy;
var ln = {};
Object.defineProperty(ln, "__esModule", { value: !0 });
ln.callRef = ln.getValidate = void 0;
const by = Ts, mc = Ve, Lt = qe, mn = yr, gc = Ut, Ls = He, wy = {
  keyword: "$ref",
  schemaType: "string",
  code(t) {
    const { gen: e, schema: r, it: n } = t, { baseId: s, schemaEnv: i, validateName: a, opts: o, self: c } = n, { root: l } = i;
    if ((r === "#" || r === "#/") && s === l.baseId)
      return h();
    const f = gc.resolveRef.call(c, l, s, r);
    if (f === void 0)
      throw new by.default(n.opts.uriResolver, s, r);
    if (f instanceof gc.SchemaEnv)
      return y(f);
    return S(f);
    function h() {
      if (i === l)
        return Ys(t, a, i, i.$async);
      const E = e.scopeValue("root", { ref: l });
      return Ys(t, (0, Lt._)`${E}.validate`, l, l.$async);
    }
    function y(E) {
      const M = il(t, E);
      Ys(t, M, E, E.$async);
    }
    function S(E) {
      const M = e.scopeValue("schema", o.code.source === !0 ? { ref: E, code: (0, Lt.stringify)(E) } : { ref: E }), A = e.name("valid"), $ = t.subschema({
        schema: E,
        dataTypes: [],
        schemaPath: Lt.nil,
        topSchemaRef: M,
        errSchemaPath: r
      }, A);
      t.mergeEvaluated($), t.ok(A);
    }
  }
};
function il(t, e) {
  const { gen: r } = t;
  return e.validate ? r.scopeValue("validate", { ref: e.validate }) : (0, Lt._)`${r.scopeValue("wrapper", { ref: e })}.validate`;
}
ln.getValidate = il;
function Ys(t, e, r, n) {
  const { gen: s, it: i } = t, { allErrors: a, schemaEnv: o, opts: c } = i, l = c.passContext ? mn.default.this : Lt.nil;
  n ? f() : h();
  function f() {
    if (!o.$async)
      throw new Error("async schema referenced by sync schema");
    const E = s.let("valid");
    s.try(() => {
      s.code((0, Lt._)`await ${(0, mc.callValidateCode)(t, e, l)}`), S(e), a || s.assign(E, !0);
    }, (M) => {
      s.if((0, Lt._)`!(${M} instanceof ${i.ValidationError})`, () => s.throw(M)), y(M), a || s.assign(E, !1);
    }), t.ok(E);
  }
  function h() {
    t.result((0, mc.callValidateCode)(t, e, l), () => S(e), () => y(e));
  }
  function y(E) {
    const M = (0, Lt._)`${E}.errors`;
    s.assign(mn.default.vErrors, (0, Lt._)`${mn.default.vErrors} === null ? ${M} : ${mn.default.vErrors}.concat(${M})`), s.assign(mn.default.errors, (0, Lt._)`${mn.default.vErrors}.length`);
  }
  function S(E) {
    var M;
    if (!i.opts.unevaluated)
      return;
    const A = (M = r?.validate) === null || M === void 0 ? void 0 : M.evaluated;
    if (i.props !== !0)
      if (A && !A.dynamicProps)
        A.props !== void 0 && (i.props = Ls.mergeEvaluated.props(s, A.props, i.props));
      else {
        const $ = s.var("props", (0, Lt._)`${E}.evaluated.props`);
        i.props = Ls.mergeEvaluated.props(s, $, i.props, Lt.Name);
      }
    if (i.items !== !0)
      if (A && !A.dynamicItems)
        A.items !== void 0 && (i.items = Ls.mergeEvaluated.items(s, A.items, i.items));
      else {
        const $ = s.var("items", (0, Lt._)`${E}.evaluated.items`);
        i.items = Ls.mergeEvaluated.items(s, $, i.items, Lt.Name);
      }
  }
}
ln.callRef = Ys;
ln.default = wy;
Object.defineProperty(no, "__esModule", { value: !0 });
const _y = so, Ey = ln, Sy = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  _y.default,
  Ey.default
];
no.default = Sy;
var io = {}, ao = {};
Object.defineProperty(ao, "__esModule", { value: !0 });
const wi = qe, Cr = wi.operators, _i = {
  maximum: { okStr: "<=", ok: Cr.LTE, fail: Cr.GT },
  minimum: { okStr: ">=", ok: Cr.GTE, fail: Cr.LT },
  exclusiveMaximum: { okStr: "<", ok: Cr.LT, fail: Cr.GTE },
  exclusiveMinimum: { okStr: ">", ok: Cr.GT, fail: Cr.LTE }
}, $y = {
  message: ({ keyword: t, schemaCode: e }) => (0, wi.str)`must be ${_i[t].okStr} ${e}`,
  params: ({ keyword: t, schemaCode: e }) => (0, wi._)`{comparison: ${_i[t].okStr}, limit: ${e}}`
}, ky = {
  keyword: Object.keys(_i),
  type: "number",
  schemaType: "number",
  $data: !0,
  error: $y,
  code(t) {
    const { keyword: e, data: r, schemaCode: n } = t;
    t.fail$data((0, wi._)`${r} ${_i[e].fail} ${n} || isNaN(${r})`);
  }
};
ao.default = ky;
var oo = {};
Object.defineProperty(oo, "__esModule", { value: !0 });
const Jn = qe, Ty = {
  message: ({ schemaCode: t }) => (0, Jn.str)`must be multiple of ${t}`,
  params: ({ schemaCode: t }) => (0, Jn._)`{multipleOf: ${t}}`
}, Py = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: !0,
  error: Ty,
  code(t) {
    const { gen: e, data: r, schemaCode: n, it: s } = t, i = s.opts.multipleOfPrecision, a = e.let("res"), o = i ? (0, Jn._)`Math.abs(Math.round(${a}) - ${a}) > 1e-${i}` : (0, Jn._)`${a} !== parseInt(${a})`;
    t.fail$data((0, Jn._)`(${n} === 0 || (${a} = ${r}/${n}, ${o}))`);
  }
};
oo.default = Py;
var co = {}, uo = {};
Object.defineProperty(uo, "__esModule", { value: !0 });
function al(t) {
  const e = t.length;
  let r = 0, n = 0, s;
  for (; n < e; )
    r++, s = t.charCodeAt(n++), s >= 55296 && s <= 56319 && n < e && (s = t.charCodeAt(n), (s & 64512) === 56320 && n++);
  return r;
}
uo.default = al;
al.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(co, "__esModule", { value: !0 });
const Xr = qe, Iy = He, Oy = uo, Ay = {
  message({ keyword: t, schemaCode: e }) {
    const r = t === "maxLength" ? "more" : "fewer";
    return (0, Xr.str)`must NOT have ${r} than ${e} characters`;
  },
  params: ({ schemaCode: t }) => (0, Xr._)`{limit: ${t}}`
}, Ny = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: !0,
  error: Ay,
  code(t) {
    const { keyword: e, data: r, schemaCode: n, it: s } = t, i = e === "maxLength" ? Xr.operators.GT : Xr.operators.LT, a = s.opts.unicode === !1 ? (0, Xr._)`${r}.length` : (0, Xr._)`${(0, Iy.useFunc)(t.gen, Oy.default)}(${r})`;
    t.fail$data((0, Xr._)`${a} ${i} ${n}`);
  }
};
co.default = Ny;
var lo = {};
Object.defineProperty(lo, "__esModule", { value: !0 });
const Cy = Ve, Ei = qe, Ry = {
  message: ({ schemaCode: t }) => (0, Ei.str)`must match pattern "${t}"`,
  params: ({ schemaCode: t }) => (0, Ei._)`{pattern: ${t}}`
}, Dy = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: !0,
  error: Ry,
  code(t) {
    const { data: e, $data: r, schema: n, schemaCode: s, it: i } = t, a = i.opts.unicodeRegExp ? "u" : "", o = r ? (0, Ei._)`(new RegExp(${s}, ${a}))` : (0, Cy.usePattern)(t, n);
    t.fail$data((0, Ei._)`!${o}.test(${e})`);
  }
};
lo.default = Dy;
var fo = {};
Object.defineProperty(fo, "__esModule", { value: !0 });
const Yn = qe, xy = {
  message({ keyword: t, schemaCode: e }) {
    const r = t === "maxProperties" ? "more" : "fewer";
    return (0, Yn.str)`must NOT have ${r} than ${e} properties`;
  },
  params: ({ schemaCode: t }) => (0, Yn._)`{limit: ${t}}`
}, My = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: !0,
  error: xy,
  code(t) {
    const { keyword: e, data: r, schemaCode: n } = t, s = e === "maxProperties" ? Yn.operators.GT : Yn.operators.LT;
    t.fail$data((0, Yn._)`Object.keys(${r}).length ${s} ${n}`);
  }
};
fo.default = My;
var ho = {};
Object.defineProperty(ho, "__esModule", { value: !0 });
const Wn = Ve, Xn = qe, jy = He, Ly = {
  message: ({ params: { missingProperty: t } }) => (0, Xn.str)`must have required property '${t}'`,
  params: ({ params: { missingProperty: t } }) => (0, Xn._)`{missingProperty: ${t}}`
}, Uy = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: !0,
  error: Ly,
  code(t) {
    const { gen: e, schema: r, schemaCode: n, data: s, $data: i, it: a } = t, { opts: o } = a;
    if (!i && r.length === 0)
      return;
    const c = r.length >= o.loopRequired;
    if (a.allErrors ? l() : f(), o.strictRequired) {
      const S = t.parentSchema.properties, { definedProperties: E } = t.it;
      for (const M of r)
        if (S?.[M] === void 0 && !E.has(M)) {
          const A = a.schemaEnv.baseId + a.errSchemaPath, $ = `required property "${M}" is not defined at "${A}" (strictRequired)`;
          (0, jy.checkStrictMode)(a, $, a.opts.strictRequired);
        }
    }
    function l() {
      if (c || i)
        t.block$data(Xn.nil, h);
      else
        for (const S of r)
          (0, Wn.checkReportMissingProp)(t, S);
    }
    function f() {
      const S = e.let("missing");
      if (c || i) {
        const E = e.let("valid", !0);
        t.block$data(E, () => y(S, E)), t.ok(E);
      } else
        e.if((0, Wn.checkMissingProp)(t, r, S)), (0, Wn.reportMissingProp)(t, S), e.else();
    }
    function h() {
      e.forOf("prop", n, (S) => {
        t.setParams({ missingProperty: S }), e.if((0, Wn.noPropertyInData)(e, s, S, o.ownProperties), () => t.error());
      });
    }
    function y(S, E) {
      t.setParams({ missingProperty: S }), e.forOf(S, n, () => {
        e.assign(E, (0, Wn.propertyInData)(e, s, S, o.ownProperties)), e.if((0, Xn.not)(E), () => {
          t.error(), e.break();
        });
      }, Xn.nil);
    }
  }
};
ho.default = Uy;
var po = {};
Object.defineProperty(po, "__esModule", { value: !0 });
const Qn = qe, Fy = {
  message({ keyword: t, schemaCode: e }) {
    const r = t === "maxItems" ? "more" : "fewer";
    return (0, Qn.str)`must NOT have ${r} than ${e} items`;
  },
  params: ({ schemaCode: t }) => (0, Qn._)`{limit: ${t}}`
}, Vy = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: !0,
  error: Fy,
  code(t) {
    const { keyword: e, data: r, schemaCode: n } = t, s = e === "maxItems" ? Qn.operators.GT : Qn.operators.LT;
    t.fail$data((0, Qn._)`${r}.length ${s} ${n}`);
  }
};
po.default = Vy;
var mo = {}, Ps = {};
Object.defineProperty(Ps, "__esModule", { value: !0 });
const ol = Vu;
ol.code = 'require("ajv/dist/runtime/equal").default';
Ps.default = ol;
Object.defineProperty(mo, "__esModule", { value: !0 });
const Qi = $s, kt = qe, qy = He, By = Ps, zy = {
  message: ({ params: { i: t, j: e } }) => (0, kt.str)`must NOT have duplicate items (items ## ${e} and ${t} are identical)`,
  params: ({ params: { i: t, j: e } }) => (0, kt._)`{i: ${t}, j: ${e}}`
}, Wy = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: !0,
  error: zy,
  code(t) {
    const { gen: e, data: r, $data: n, schema: s, parentSchema: i, schemaCode: a, it: o } = t;
    if (!n && !s)
      return;
    const c = e.let("valid"), l = i.items ? (0, Qi.getSchemaTypes)(i.items) : [];
    t.block$data(c, f, (0, kt._)`${a} === false`), t.ok(c);
    function f() {
      const E = e.let("i", (0, kt._)`${r}.length`), M = e.let("j");
      t.setParams({ i: E, j: M }), e.assign(c, !0), e.if((0, kt._)`${E} > 1`, () => (h() ? y : S)(E, M));
    }
    function h() {
      return l.length > 0 && !l.some((E) => E === "object" || E === "array");
    }
    function y(E, M) {
      const A = e.name("item"), $ = (0, Qi.checkDataTypes)(l, A, o.opts.strictNumbers, Qi.DataType.Wrong), x = e.const("indices", (0, kt._)`{}`);
      e.for((0, kt._)`;${E}--;`, () => {
        e.let(A, (0, kt._)`${r}[${E}]`), e.if($, (0, kt._)`continue`), l.length > 1 && e.if((0, kt._)`typeof ${A} == "string"`, (0, kt._)`${A} += "_"`), e.if((0, kt._)`typeof ${x}[${A}] == "number"`, () => {
          e.assign(M, (0, kt._)`${x}[${A}]`), t.error(), e.assign(c, !1).break();
        }).code((0, kt._)`${x}[${A}] = ${E}`);
      });
    }
    function S(E, M) {
      const A = (0, qy.useFunc)(e, By.default), $ = e.name("outer");
      e.label($).for((0, kt._)`;${E}--;`, () => e.for((0, kt._)`${M} = ${E}; ${M}--;`, () => e.if((0, kt._)`${A}(${r}[${E}], ${r}[${M}])`, () => {
        t.error(), e.assign(c, !1).break($);
      })));
    }
  }
};
mo.default = Wy;
var go = {};
Object.defineProperty(go, "__esModule", { value: !0 });
const ka = qe, Hy = He, Zy = Ps, Ky = {
  message: "must be equal to constant",
  params: ({ schemaCode: t }) => (0, ka._)`{allowedValue: ${t}}`
}, Gy = {
  keyword: "const",
  $data: !0,
  error: Ky,
  code(t) {
    const { gen: e, data: r, $data: n, schemaCode: s, schema: i } = t;
    n || i && typeof i == "object" ? t.fail$data((0, ka._)`!${(0, Hy.useFunc)(e, Zy.default)}(${r}, ${s})`) : t.fail((0, ka._)`${i} !== ${r}`);
  }
};
go.default = Gy;
var yo = {};
Object.defineProperty(yo, "__esModule", { value: !0 });
const Zn = qe, Jy = He, Yy = Ps, Xy = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode: t }) => (0, Zn._)`{allowedValues: ${t}}`
}, Qy = {
  keyword: "enum",
  schemaType: "array",
  $data: !0,
  error: Xy,
  code(t) {
    const { gen: e, data: r, $data: n, schema: s, schemaCode: i, it: a } = t;
    if (!n && s.length === 0)
      throw new Error("enum must have non-empty array");
    const o = s.length >= a.opts.loopEnum;
    let c;
    const l = () => c ?? (c = (0, Jy.useFunc)(e, Yy.default));
    let f;
    if (o || n)
      f = e.let("valid"), t.block$data(f, h);
    else {
      if (!Array.isArray(s))
        throw new Error("ajv implementation error");
      const S = e.const("vSchema", i);
      f = (0, Zn.or)(...s.map((E, M) => y(S, M)));
    }
    t.pass(f);
    function h() {
      e.assign(f, !1), e.forOf("v", i, (S) => e.if((0, Zn._)`${l()}(${r}, ${S})`, () => e.assign(f, !0).break()));
    }
    function y(S, E) {
      const M = s[E];
      return typeof M == "object" && M !== null ? (0, Zn._)`${l()}(${r}, ${S}[${E}])` : (0, Zn._)`${r} === ${M}`;
    }
  }
};
yo.default = Qy;
Object.defineProperty(io, "__esModule", { value: !0 });
const ev = ao, tv = oo, rv = co, nv = lo, sv = fo, iv = ho, av = po, ov = mo, cv = go, uv = yo, lv = [
  // number
  ev.default,
  tv.default,
  // string
  rv.default,
  nv.default,
  // object
  sv.default,
  iv.default,
  // array
  av.default,
  ov.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  cv.default,
  uv.default
];
io.default = lv;
var vo = {}, Mn = {};
Object.defineProperty(Mn, "__esModule", { value: !0 });
Mn.validateAdditionalItems = void 0;
const Qr = qe, Ta = He, dv = {
  message: ({ params: { len: t } }) => (0, Qr.str)`must NOT have more than ${t} items`,
  params: ({ params: { len: t } }) => (0, Qr._)`{limit: ${t}}`
}, fv = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: dv,
  code(t) {
    const { parentSchema: e, it: r } = t, { items: n } = e;
    if (!Array.isArray(n)) {
      (0, Ta.checkStrictMode)(r, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    cl(t, n);
  }
};
function cl(t, e) {
  const { gen: r, schema: n, data: s, keyword: i, it: a } = t;
  a.items = !0;
  const o = r.const("len", (0, Qr._)`${s}.length`);
  if (n === !1)
    t.setParams({ len: e.length }), t.pass((0, Qr._)`${o} <= ${e.length}`);
  else if (typeof n == "object" && !(0, Ta.alwaysValidSchema)(a, n)) {
    const l = r.var("valid", (0, Qr._)`${o} <= ${e.length}`);
    r.if((0, Qr.not)(l), () => c(l)), t.ok(l);
  }
  function c(l) {
    r.forRange("i", e.length, o, (f) => {
      t.subschema({ keyword: i, dataProp: f, dataPropType: Ta.Type.Num }, l), a.allErrors || r.if((0, Qr.not)(l), () => r.break());
    });
  }
}
Mn.validateAdditionalItems = cl;
Mn.default = fv;
var bo = {}, jn = {};
Object.defineProperty(jn, "__esModule", { value: !0 });
jn.validateTuple = void 0;
const yc = qe, Xs = He, hv = Ve, pv = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(t) {
    const { schema: e, it: r } = t;
    if (Array.isArray(e))
      return ul(t, "additionalItems", e);
    r.items = !0, !(0, Xs.alwaysValidSchema)(r, e) && t.ok((0, hv.validateArray)(t));
  }
};
function ul(t, e, r = t.schema) {
  const { gen: n, parentSchema: s, data: i, keyword: a, it: o } = t;
  f(s), o.opts.unevaluated && r.length && o.items !== !0 && (o.items = Xs.mergeEvaluated.items(n, r.length, o.items));
  const c = n.name("valid"), l = n.const("len", (0, yc._)`${i}.length`);
  r.forEach((h, y) => {
    (0, Xs.alwaysValidSchema)(o, h) || (n.if((0, yc._)`${l} > ${y}`, () => t.subschema({
      keyword: a,
      schemaProp: y,
      dataProp: y
    }, c)), t.ok(c));
  });
  function f(h) {
    const { opts: y, errSchemaPath: S } = o, E = r.length, M = E === h.minItems && (E === h.maxItems || h[e] === !1);
    if (y.strictTuples && !M) {
      const A = `"${a}" is ${E}-tuple, but minItems or maxItems/${e} are not specified or different at path "${S}"`;
      (0, Xs.checkStrictMode)(o, A, y.strictTuples);
    }
  }
}
jn.validateTuple = ul;
jn.default = pv;
Object.defineProperty(bo, "__esModule", { value: !0 });
const mv = jn, gv = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (t) => (0, mv.validateTuple)(t, "items")
};
bo.default = gv;
var wo = {};
Object.defineProperty(wo, "__esModule", { value: !0 });
const vc = qe, yv = He, vv = Ve, bv = Mn, wv = {
  message: ({ params: { len: t } }) => (0, vc.str)`must NOT have more than ${t} items`,
  params: ({ params: { len: t } }) => (0, vc._)`{limit: ${t}}`
}, _v = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: wv,
  code(t) {
    const { schema: e, parentSchema: r, it: n } = t, { prefixItems: s } = r;
    n.items = !0, !(0, yv.alwaysValidSchema)(n, e) && (s ? (0, bv.validateAdditionalItems)(t, s) : t.ok((0, vv.validateArray)(t)));
  }
};
wo.default = _v;
var _o = {};
Object.defineProperty(_o, "__esModule", { value: !0 });
const Ht = qe, Us = He, Ev = {
  message: ({ params: { min: t, max: e } }) => e === void 0 ? (0, Ht.str)`must contain at least ${t} valid item(s)` : (0, Ht.str)`must contain at least ${t} and no more than ${e} valid item(s)`,
  params: ({ params: { min: t, max: e } }) => e === void 0 ? (0, Ht._)`{minContains: ${t}}` : (0, Ht._)`{minContains: ${t}, maxContains: ${e}}`
}, Sv = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: !0,
  error: Ev,
  code(t) {
    const { gen: e, schema: r, parentSchema: n, data: s, it: i } = t;
    let a, o;
    const { minContains: c, maxContains: l } = n;
    i.opts.next ? (a = c === void 0 ? 1 : c, o = l) : a = 1;
    const f = e.const("len", (0, Ht._)`${s}.length`);
    if (t.setParams({ min: a, max: o }), o === void 0 && a === 0) {
      (0, Us.checkStrictMode)(i, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
      return;
    }
    if (o !== void 0 && a > o) {
      (0, Us.checkStrictMode)(i, '"minContains" > "maxContains" is always invalid'), t.fail();
      return;
    }
    if ((0, Us.alwaysValidSchema)(i, r)) {
      let M = (0, Ht._)`${f} >= ${a}`;
      o !== void 0 && (M = (0, Ht._)`${M} && ${f} <= ${o}`), t.pass(M);
      return;
    }
    i.items = !0;
    const h = e.name("valid");
    o === void 0 && a === 1 ? S(h, () => e.if(h, () => e.break())) : a === 0 ? (e.let(h, !0), o !== void 0 && e.if((0, Ht._)`${s}.length > 0`, y)) : (e.let(h, !1), y()), t.result(h, () => t.reset());
    function y() {
      const M = e.name("_valid"), A = e.let("count", 0);
      S(M, () => e.if(M, () => E(A)));
    }
    function S(M, A) {
      e.forRange("i", 0, f, ($) => {
        t.subschema({
          keyword: "contains",
          dataProp: $,
          dataPropType: Us.Type.Num,
          compositeRule: !0
        }, M), A();
      });
    }
    function E(M) {
      e.code((0, Ht._)`${M}++`), o === void 0 ? e.if((0, Ht._)`${M} >= ${a}`, () => e.assign(h, !0).break()) : (e.if((0, Ht._)`${M} > ${o}`, () => e.assign(h, !1).break()), a === 1 ? e.assign(h, !0) : e.if((0, Ht._)`${M} >= ${a}`, () => e.assign(h, !0)));
    }
  }
};
_o.default = Sv;
var ll = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.validateSchemaDeps = t.validatePropertyDeps = t.error = void 0;
  const e = qe, r = He, n = Ve;
  t.error = {
    message: ({ params: { property: c, depsCount: l, deps: f } }) => {
      const h = l === 1 ? "property" : "properties";
      return (0, e.str)`must have ${h} ${f} when property ${c} is present`;
    },
    params: ({ params: { property: c, depsCount: l, deps: f, missingProperty: h } }) => (0, e._)`{property: ${c},
    missingProperty: ${h},
    depsCount: ${l},
    deps: ${f}}`
    // TODO change to reference
  };
  const s = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: t.error,
    code(c) {
      const [l, f] = i(c);
      a(c, l), o(c, f);
    }
  };
  function i({ schema: c }) {
    const l = {}, f = {};
    for (const h in c) {
      if (h === "__proto__")
        continue;
      const y = Array.isArray(c[h]) ? l : f;
      y[h] = c[h];
    }
    return [l, f];
  }
  function a(c, l = c.schema) {
    const { gen: f, data: h, it: y } = c;
    if (Object.keys(l).length === 0)
      return;
    const S = f.let("missing");
    for (const E in l) {
      const M = l[E];
      if (M.length === 0)
        continue;
      const A = (0, n.propertyInData)(f, h, E, y.opts.ownProperties);
      c.setParams({
        property: E,
        depsCount: M.length,
        deps: M.join(", ")
      }), y.allErrors ? f.if(A, () => {
        for (const $ of M)
          (0, n.checkReportMissingProp)(c, $);
      }) : (f.if((0, e._)`${A} && (${(0, n.checkMissingProp)(c, M, S)})`), (0, n.reportMissingProp)(c, S), f.else());
    }
  }
  t.validatePropertyDeps = a;
  function o(c, l = c.schema) {
    const { gen: f, data: h, keyword: y, it: S } = c, E = f.name("valid");
    for (const M in l)
      (0, r.alwaysValidSchema)(S, l[M]) || (f.if(
        (0, n.propertyInData)(f, h, M, S.opts.ownProperties),
        () => {
          const A = c.subschema({ keyword: y, schemaProp: M }, E);
          c.mergeValidEvaluated(A, E);
        },
        () => f.var(E, !0)
        // TODO var
      ), c.ok(E));
  }
  t.validateSchemaDeps = o, t.default = s;
})(ll);
var Eo = {};
Object.defineProperty(Eo, "__esModule", { value: !0 });
const dl = qe, $v = He, kv = {
  message: "property name must be valid",
  params: ({ params: t }) => (0, dl._)`{propertyName: ${t.propertyName}}`
}, Tv = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: kv,
  code(t) {
    const { gen: e, schema: r, data: n, it: s } = t;
    if ((0, $v.alwaysValidSchema)(s, r))
      return;
    const i = e.name("valid");
    e.forIn("key", n, (a) => {
      t.setParams({ propertyName: a }), t.subschema({
        keyword: "propertyNames",
        data: a,
        dataTypes: ["string"],
        propertyName: a,
        compositeRule: !0
      }, i), e.if((0, dl.not)(i), () => {
        t.error(!0), s.allErrors || e.break();
      });
    }), t.ok(i);
  }
};
Eo.default = Tv;
var Li = {};
Object.defineProperty(Li, "__esModule", { value: !0 });
const Fs = Ve, er = qe, Pv = yr, Vs = He, Iv = {
  message: "must NOT have additional properties",
  params: ({ params: t }) => (0, er._)`{additionalProperty: ${t.additionalProperty}}`
}, Ov = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: !0,
  trackErrors: !0,
  error: Iv,
  code(t) {
    const { gen: e, schema: r, parentSchema: n, data: s, errsCount: i, it: a } = t;
    if (!i)
      throw new Error("ajv implementation error");
    const { allErrors: o, opts: c } = a;
    if (a.props = !0, c.removeAdditional !== "all" && (0, Vs.alwaysValidSchema)(a, r))
      return;
    const l = (0, Fs.allSchemaProperties)(n.properties), f = (0, Fs.allSchemaProperties)(n.patternProperties);
    h(), t.ok((0, er._)`${i} === ${Pv.default.errors}`);
    function h() {
      e.forIn("key", s, (A) => {
        !l.length && !f.length ? E(A) : e.if(y(A), () => E(A));
      });
    }
    function y(A) {
      let $;
      if (l.length > 8) {
        const x = (0, Vs.schemaRefOrVal)(a, n.properties, "properties");
        $ = (0, Fs.isOwnProperty)(e, x, A);
      } else
        l.length ? $ = (0, er.or)(...l.map((x) => (0, er._)`${A} === ${x}`)) : $ = er.nil;
      return f.length && ($ = (0, er.or)($, ...f.map((x) => (0, er._)`${(0, Fs.usePattern)(t, x)}.test(${A})`))), (0, er.not)($);
    }
    function S(A) {
      e.code((0, er._)`delete ${s}[${A}]`);
    }
    function E(A) {
      if (c.removeAdditional === "all" || c.removeAdditional && r === !1) {
        S(A);
        return;
      }
      if (r === !1) {
        t.setParams({ additionalProperty: A }), t.error(), o || e.break();
        return;
      }
      if (typeof r == "object" && !(0, Vs.alwaysValidSchema)(a, r)) {
        const $ = e.name("valid");
        c.removeAdditional === "failing" ? (M(A, $, !1), e.if((0, er.not)($), () => {
          t.reset(), S(A);
        })) : (M(A, $), o || e.if((0, er.not)($), () => e.break()));
      }
    }
    function M(A, $, x) {
      const P = {
        keyword: "additionalProperties",
        dataProp: A,
        dataPropType: Vs.Type.Str
      };
      x === !1 && Object.assign(P, {
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }), t.subschema(P, $);
    }
  }
};
Li.default = Ov;
var So = {};
Object.defineProperty(So, "__esModule", { value: !0 });
const Av = ir, bc = Ve, ea = He, wc = Li, Nv = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(t) {
    const { gen: e, schema: r, parentSchema: n, data: s, it: i } = t;
    i.opts.removeAdditional === "all" && n.additionalProperties === void 0 && wc.default.code(new Av.KeywordCxt(i, wc.default, "additionalProperties"));
    const a = (0, bc.allSchemaProperties)(r);
    for (const h of a)
      i.definedProperties.add(h);
    i.opts.unevaluated && a.length && i.props !== !0 && (i.props = ea.mergeEvaluated.props(e, (0, ea.toHash)(a), i.props));
    const o = a.filter((h) => !(0, ea.alwaysValidSchema)(i, r[h]));
    if (o.length === 0)
      return;
    const c = e.name("valid");
    for (const h of o)
      l(h) ? f(h) : (e.if((0, bc.propertyInData)(e, s, h, i.opts.ownProperties)), f(h), i.allErrors || e.else().var(c, !0), e.endIf()), t.it.definedProperties.add(h), t.ok(c);
    function l(h) {
      return i.opts.useDefaults && !i.compositeRule && r[h].default !== void 0;
    }
    function f(h) {
      t.subschema({
        keyword: "properties",
        schemaProp: h,
        dataProp: h
      }, c);
    }
  }
};
So.default = Nv;
var $o = {};
Object.defineProperty($o, "__esModule", { value: !0 });
const _c = Ve, qs = qe, Ec = He, Sc = He, Cv = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(t) {
    const { gen: e, schema: r, data: n, parentSchema: s, it: i } = t, { opts: a } = i, o = (0, _c.allSchemaProperties)(r), c = o.filter((M) => (0, Ec.alwaysValidSchema)(i, r[M]));
    if (o.length === 0 || c.length === o.length && (!i.opts.unevaluated || i.props === !0))
      return;
    const l = a.strictSchema && !a.allowMatchingProperties && s.properties, f = e.name("valid");
    i.props !== !0 && !(i.props instanceof qs.Name) && (i.props = (0, Sc.evaluatedPropsToName)(e, i.props));
    const { props: h } = i;
    y();
    function y() {
      for (const M of o)
        l && S(M), i.allErrors ? E(M) : (e.var(f, !0), E(M), e.if(f));
    }
    function S(M) {
      for (const A in l)
        new RegExp(M).test(A) && (0, Ec.checkStrictMode)(i, `property ${A} matches pattern ${M} (use allowMatchingProperties)`);
    }
    function E(M) {
      e.forIn("key", n, (A) => {
        e.if((0, qs._)`${(0, _c.usePattern)(t, M)}.test(${A})`, () => {
          const $ = c.includes(M);
          $ || t.subschema({
            keyword: "patternProperties",
            schemaProp: M,
            dataProp: A,
            dataPropType: Sc.Type.Str
          }, f), i.opts.unevaluated && h !== !0 ? e.assign((0, qs._)`${h}[${A}]`, !0) : !$ && !i.allErrors && e.if((0, qs.not)(f), () => e.break());
        });
      });
    }
  }
};
$o.default = Cv;
var ko = {};
Object.defineProperty(ko, "__esModule", { value: !0 });
const Rv = He, Dv = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: !0,
  code(t) {
    const { gen: e, schema: r, it: n } = t;
    if ((0, Rv.alwaysValidSchema)(n, r)) {
      t.fail();
      return;
    }
    const s = e.name("valid");
    t.subschema({
      keyword: "not",
      compositeRule: !0,
      createErrors: !1,
      allErrors: !1
    }, s), t.failResult(s, () => t.reset(), () => t.error());
  },
  error: { message: "must NOT be valid" }
};
ko.default = Dv;
var To = {};
Object.defineProperty(To, "__esModule", { value: !0 });
const xv = Ve, Mv = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: !0,
  code: xv.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
To.default = Mv;
var Po = {};
Object.defineProperty(Po, "__esModule", { value: !0 });
const Qs = qe, jv = He, Lv = {
  message: "must match exactly one schema in oneOf",
  params: ({ params: t }) => (0, Qs._)`{passingSchemas: ${t.passing}}`
}, Uv = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: !0,
  error: Lv,
  code(t) {
    const { gen: e, schema: r, parentSchema: n, it: s } = t;
    if (!Array.isArray(r))
      throw new Error("ajv implementation error");
    if (s.opts.discriminator && n.discriminator)
      return;
    const i = r, a = e.let("valid", !1), o = e.let("passing", null), c = e.name("_valid");
    t.setParams({ passing: o }), e.block(l), t.result(a, () => t.reset(), () => t.error(!0));
    function l() {
      i.forEach((f, h) => {
        let y;
        (0, jv.alwaysValidSchema)(s, f) ? e.var(c, !0) : y = t.subschema({
          keyword: "oneOf",
          schemaProp: h,
          compositeRule: !0
        }, c), h > 0 && e.if((0, Qs._)`${c} && ${a}`).assign(a, !1).assign(o, (0, Qs._)`[${o}, ${h}]`).else(), e.if(c, () => {
          e.assign(a, !0), e.assign(o, h), y && t.mergeEvaluated(y, Qs.Name);
        });
      });
    }
  }
};
Po.default = Uv;
var Io = {};
Object.defineProperty(Io, "__esModule", { value: !0 });
const Fv = He, Vv = {
  keyword: "allOf",
  schemaType: "array",
  code(t) {
    const { gen: e, schema: r, it: n } = t;
    if (!Array.isArray(r))
      throw new Error("ajv implementation error");
    const s = e.name("valid");
    r.forEach((i, a) => {
      if ((0, Fv.alwaysValidSchema)(n, i))
        return;
      const o = t.subschema({ keyword: "allOf", schemaProp: a }, s);
      t.ok(s), t.mergeEvaluated(o);
    });
  }
};
Io.default = Vv;
var Oo = {};
Object.defineProperty(Oo, "__esModule", { value: !0 });
const Si = qe, fl = He, qv = {
  message: ({ params: t }) => (0, Si.str)`must match "${t.ifClause}" schema`,
  params: ({ params: t }) => (0, Si._)`{failingKeyword: ${t.ifClause}}`
}, Bv = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: !0,
  error: qv,
  code(t) {
    const { gen: e, parentSchema: r, it: n } = t;
    r.then === void 0 && r.else === void 0 && (0, fl.checkStrictMode)(n, '"if" without "then" and "else" is ignored');
    const s = $c(n, "then"), i = $c(n, "else");
    if (!s && !i)
      return;
    const a = e.let("valid", !0), o = e.name("_valid");
    if (c(), t.reset(), s && i) {
      const f = e.let("ifClause");
      t.setParams({ ifClause: f }), e.if(o, l("then", f), l("else", f));
    } else
      s ? e.if(o, l("then")) : e.if((0, Si.not)(o), l("else"));
    t.pass(a, () => t.error(!0));
    function c() {
      const f = t.subschema({
        keyword: "if",
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }, o);
      t.mergeEvaluated(f);
    }
    function l(f, h) {
      return () => {
        const y = t.subschema({ keyword: f }, o);
        e.assign(a, o), t.mergeValidEvaluated(y, a), h ? e.assign(h, (0, Si._)`${f}`) : t.setParams({ ifClause: f });
      };
    }
  }
};
function $c(t, e) {
  const r = t.schema[e];
  return r !== void 0 && !(0, fl.alwaysValidSchema)(t, r);
}
Oo.default = Bv;
var Ao = {};
Object.defineProperty(Ao, "__esModule", { value: !0 });
const zv = He, Wv = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: t, parentSchema: e, it: r }) {
    e.if === void 0 && (0, zv.checkStrictMode)(r, `"${t}" without "if" is ignored`);
  }
};
Ao.default = Wv;
Object.defineProperty(vo, "__esModule", { value: !0 });
const Hv = Mn, Zv = bo, Kv = jn, Gv = wo, Jv = _o, Yv = ll, Xv = Eo, Qv = Li, eb = So, tb = $o, rb = ko, nb = To, sb = Po, ib = Io, ab = Oo, ob = Ao;
function cb(t = !1) {
  const e = [
    // any
    rb.default,
    nb.default,
    sb.default,
    ib.default,
    ab.default,
    ob.default,
    // object
    Xv.default,
    Qv.default,
    Yv.default,
    eb.default,
    tb.default
  ];
  return t ? e.push(Zv.default, Gv.default) : e.push(Hv.default, Kv.default), e.push(Jv.default), e;
}
vo.default = cb;
var No = {}, Co = {};
Object.defineProperty(Co, "__esModule", { value: !0 });
const gt = qe, ub = {
  message: ({ schemaCode: t }) => (0, gt.str)`must match format "${t}"`,
  params: ({ schemaCode: t }) => (0, gt._)`{format: ${t}}`
}, lb = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: !0,
  error: ub,
  code(t, e) {
    const { gen: r, data: n, $data: s, schema: i, schemaCode: a, it: o } = t, { opts: c, errSchemaPath: l, schemaEnv: f, self: h } = o;
    if (!c.validateFormats)
      return;
    s ? y() : S();
    function y() {
      const E = r.scopeValue("formats", {
        ref: h.formats,
        code: c.code.formats
      }), M = r.const("fDef", (0, gt._)`${E}[${a}]`), A = r.let("fType"), $ = r.let("format");
      r.if((0, gt._)`typeof ${M} == "object" && !(${M} instanceof RegExp)`, () => r.assign(A, (0, gt._)`${M}.type || "string"`).assign($, (0, gt._)`${M}.validate`), () => r.assign(A, (0, gt._)`"string"`).assign($, M)), t.fail$data((0, gt.or)(x(), P()));
      function x() {
        return c.strictSchema === !1 ? gt.nil : (0, gt._)`${a} && !${$}`;
      }
      function P() {
        const U = f.$async ? (0, gt._)`(${M}.async ? await ${$}(${n}) : ${$}(${n}))` : (0, gt._)`${$}(${n})`, B = (0, gt._)`(typeof ${$} == "function" ? ${U} : ${$}.test(${n}))`;
        return (0, gt._)`${$} && ${$} !== true && ${A} === ${e} && !${B}`;
      }
    }
    function S() {
      const E = h.formats[i];
      if (!E) {
        x();
        return;
      }
      if (E === !0)
        return;
      const [M, A, $] = P(E);
      M === e && t.pass(U());
      function x() {
        if (c.strictSchema === !1) {
          h.logger.warn(B());
          return;
        }
        throw new Error(B());
        function B() {
          return `unknown format "${i}" ignored in schema at path "${l}"`;
        }
      }
      function P(B) {
        const w = B instanceof RegExp ? (0, gt.regexpCode)(B) : c.code.formats ? (0, gt._)`${c.code.formats}${(0, gt.getProperty)(i)}` : void 0, R = r.scopeValue("formats", { key: i, ref: B, code: w });
        return typeof B == "object" && !(B instanceof RegExp) ? [B.type || "string", B.validate, (0, gt._)`${R}.validate`] : ["string", B, R];
      }
      function U() {
        if (typeof E == "object" && !(E instanceof RegExp) && E.async) {
          if (!f.$async)
            throw new Error("async format in sync schema");
          return (0, gt._)`await ${$}(${n})`;
        }
        return typeof A == "function" ? (0, gt._)`${$}(${n})` : (0, gt._)`${$}.test(${n})`;
      }
    }
  }
};
Co.default = lb;
Object.defineProperty(No, "__esModule", { value: !0 });
const db = Co, fb = [db.default];
No.default = fb;
var Rn = {};
Object.defineProperty(Rn, "__esModule", { value: !0 });
Rn.contentVocabulary = Rn.metadataVocabulary = void 0;
Rn.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
Rn.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(ro, "__esModule", { value: !0 });
const hb = no, pb = io, mb = vo, gb = No, kc = Rn, yb = [
  hb.default,
  pb.default,
  (0, mb.default)(),
  gb.default,
  kc.metadataVocabulary,
  kc.contentVocabulary
];
ro.default = yb;
var Ro = {}, hl = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.DiscrError = void 0, function(e) {
    e.Tag = "tag", e.Mapping = "mapping";
  }(t.DiscrError || (t.DiscrError = {}));
})(hl);
Object.defineProperty(Ro, "__esModule", { value: !0 });
const bn = qe, Pa = hl, Tc = Ut, vb = He, bb = {
  message: ({ params: { discrError: t, tagName: e } }) => t === Pa.DiscrError.Tag ? `tag "${e}" must be string` : `value of tag "${e}" must be in oneOf`,
  params: ({ params: { discrError: t, tag: e, tagName: r } }) => (0, bn._)`{error: ${t}, tag: ${r}, tagValue: ${e}}`
}, wb = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error: bb,
  code(t) {
    const { gen: e, data: r, schema: n, parentSchema: s, it: i } = t, { oneOf: a } = s;
    if (!i.opts.discriminator)
      throw new Error("discriminator: requires discriminator option");
    const o = n.propertyName;
    if (typeof o != "string")
      throw new Error("discriminator: requires propertyName");
    if (n.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!a)
      throw new Error("discriminator: requires oneOf keyword");
    const c = e.let("valid", !1), l = e.const("tag", (0, bn._)`${r}${(0, bn.getProperty)(o)}`);
    e.if((0, bn._)`typeof ${l} == "string"`, () => f(), () => t.error(!1, { discrError: Pa.DiscrError.Tag, tag: l, tagName: o })), t.ok(c);
    function f() {
      const S = y();
      e.if(!1);
      for (const E in S)
        e.elseIf((0, bn._)`${l} === ${E}`), e.assign(c, h(S[E]));
      e.else(), t.error(!1, { discrError: Pa.DiscrError.Mapping, tag: l, tagName: o }), e.endIf();
    }
    function h(S) {
      const E = e.name("valid"), M = t.subschema({ keyword: "oneOf", schemaProp: S }, E);
      return t.mergeEvaluated(M, bn.Name), E;
    }
    function y() {
      var S;
      const E = {}, M = $(s);
      let A = !0;
      for (let U = 0; U < a.length; U++) {
        let B = a[U];
        B?.$ref && !(0, vb.schemaHasRulesButRef)(B, i.self.RULES) && (B = Tc.resolveRef.call(i.self, i.schemaEnv.root, i.baseId, B?.$ref), B instanceof Tc.SchemaEnv && (B = B.schema));
        const w = (S = B?.properties) === null || S === void 0 ? void 0 : S[o];
        if (typeof w != "object")
          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${o}"`);
        A = A && (M || $(B)), x(w, U);
      }
      if (!A)
        throw new Error(`discriminator: "${o}" must be required`);
      return E;
      function $({ required: U }) {
        return Array.isArray(U) && U.includes(o);
      }
      function x(U, B) {
        if (U.const)
          P(U.const, B);
        else if (U.enum)
          for (const w of U.enum)
            P(w, B);
        else
          throw new Error(`discriminator: "properties/${o}" must have "const" or "enum"`);
      }
      function P(U, B) {
        if (typeof U != "string" || U in E)
          throw new Error(`discriminator: "${o}" values must be unique strings`);
        E[U] = B;
      }
    }
  }
};
Ro.default = wb;
const _b = "http://json-schema.org/draft-07/schema#", Eb = "http://json-schema.org/draft-07/schema#", Sb = "Core schema meta-schema", $b = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        default: 0
      }
    ]
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: !0,
    default: []
  }
}, kb = [
  "object",
  "boolean"
], Tb = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: !0,
  readOnly: {
    type: "boolean",
    default: !1
  },
  examples: {
    type: "array",
    items: !0
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    default: !0
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    default: {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  const: !0,
  enum: {
    type: "array",
    items: !0,
    minItems: 1,
    uniqueItems: !0
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  if: {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  else: {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
}, Pb = {
  $schema: _b,
  $id: Eb,
  title: Sb,
  definitions: $b,
  type: kb,
  properties: Tb,
  default: !0
};
(function(t, e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MissingRefError = e.ValidationError = e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
  const r = Ru, n = ro, s = Ro, i = Pb, a = ["/properties"], o = "http://json-schema.org/draft-07/schema";
  class c extends r.default {
    _addVocabularies() {
      super._addVocabularies(), n.default.forEach((E) => this.addVocabulary(E)), this.opts.discriminator && this.addKeyword(s.default);
    }
    _addDefaultMetaSchema() {
      if (super._addDefaultMetaSchema(), !this.opts.meta)
        return;
      const E = this.opts.$data ? this.$dataMetaSchema(i, a) : i;
      this.addMetaSchema(E, o, !1), this.refs["http://json-schema.org/schema"] = o;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(o) ? o : void 0);
    }
  }
  t.exports = e = c, Object.defineProperty(e, "__esModule", { value: !0 }), e.default = c;
  var l = ir;
  Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
    return l.KeywordCxt;
  } });
  var f = qe;
  Object.defineProperty(e, "_", { enumerable: !0, get: function() {
    return f._;
  } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
    return f.str;
  } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
    return f.stringify;
  } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
    return f.nil;
  } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
    return f.Name;
  } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
    return f.CodeGen;
  } });
  var h = ks;
  Object.defineProperty(e, "ValidationError", { enumerable: !0, get: function() {
    return h.default;
  } });
  var y = Ts;
  Object.defineProperty(e, "MissingRefError", { enumerable: !0, get: function() {
    return y.default;
  } });
})(_a, _a.exports);
var Ib = _a.exports;
const Ob = /* @__PURE__ */ Cu(Ib);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Ab = (t) => t.replace(/(?:```(?:json)?\n+)(.*)(?:\n+```)/gms, "$1"), Pc = (t) => {
  try {
    return JSON.parse(Ab(t));
  } catch (e) {
    return {
      $error: {
        kind: "error",
        error: { type: "parsing", message: e.message }
      }
    };
  }
}, Nb = (t, e) => {
  const r = { json: t };
  if (!e)
    return r;
  const n = new Ob.default(), s = n.compile(e);
  return s(t) ? r : {
    $error: {
      kind: "error",
      error: {
        type: "validation",
        message: n.errorsText(s.errors)
      }
    }
  };
}, Cb = async (t) => {
  const { json: e, schema: r } = t;
  if (!e)
    throw new Error("The `json` input is required.");
  const n = Pc(e), s = n;
  if (s?.$error)
    return s;
  let i = r;
  if (r && typeof r == "string")
    try {
      i = Pc(r);
    } catch {
      throw new Error("The `schema` input is not valid JSON.");
    }
  return Nb(n, i);
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Ia = (t) => {
  if (!t.type)
    return "Any JSON object";
  if (t.type === "string" || t.type === "number") {
    const e = `${t.type}, ${t.description}`, { enum: r } = t;
    return r ? `${e} (one of: ${r.map((n) => `"${n}"`).join(", ")})` : e;
  }
  if (t.type === "object") {
    const e = {}, r = t.properties;
    for (const [n, s] of Object.entries(r))
      e[n] = Ia(s);
    return e;
  }
  if (t.type === "array") {
    const e = t.items || {};
    return [Ia(e)];
  }
  throw new Error(`Failed to translate this schema to schemish:
${JSON.stringify(t, null, 2)}`);
}, Rb = async (t) => {
  const { schema: e } = t;
  return { schemish: Ia(e) };
};
function Bs(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var pl = { exports: {} };
(function(t, e) {
  (function(r) {
    t.exports = r();
  })(function() {
    return (/* @__PURE__ */ function() {
      function r(n, s, i) {
        function a(l, f) {
          if (!s[l]) {
            if (!n[l]) {
              var h = typeof Bs == "function" && Bs;
              if (!f && h)
                return h(l, !0);
              if (o)
                return o(l, !0);
              var y = new Error("Cannot find module '" + l + "'");
              throw y.code = "MODULE_NOT_FOUND", y;
            }
            var S = s[l] = { exports: {} };
            n[l][0].call(S.exports, function(E) {
              var M = n[l][1][E];
              return a(M || E);
            }, S, S.exports, r, n, s, i);
          }
          return s[l].exports;
        }
        for (var o = typeof Bs == "function" && Bs, c = 0; c < i.length; c++)
          a(i[c]);
        return a;
      }
      return r;
    }())({ 1: [function(r, n, s) {
      const i = r("./utils"), a = function() {
        const o = i.stringToArray, c = [
          "Zero",
          "One",
          "Two",
          "Three",
          "Four",
          "Five",
          "Six",
          "Seven",
          "Eight",
          "Nine",
          "Ten",
          "Eleven",
          "Twelve",
          "Thirteen",
          "Fourteen",
          "Fifteen",
          "Sixteen",
          "Seventeen",
          "Eighteen",
          "Nineteen"
        ], l = [
          "Zeroth",
          "First",
          "Second",
          "Third",
          "Fourth",
          "Fifth",
          "Sixth",
          "Seventh",
          "Eighth",
          "Ninth",
          "Tenth",
          "Eleventh",
          "Twelfth",
          "Thirteenth",
          "Fourteenth",
          "Fifteenth",
          "Sixteenth",
          "Seventeenth",
          "Eighteenth",
          "Nineteenth"
        ], f = ["Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety", "Hundred"], h = ["Thousand", "Million", "Billion", "Trillion"];
        function y(O, V) {
          var L = function(Q, X, K) {
            var se = "";
            if (Q <= 19)
              se = (X ? " and " : "") + (K ? l[Q] : c[Q]);
            else if (Q < 100) {
              const Re = Math.floor(Q / 10), je = Q % 10;
              se = (X ? " and " : "") + f[Re - 2], je > 0 ? se += "-" + L(je, !1, K) : K && (se = se.substring(0, se.length - 1) + "ieth");
            } else if (Q < 1e3) {
              const Re = Math.floor(Q / 100), je = Q % 100;
              se = (X ? ", " : "") + c[Re] + " Hundred", je > 0 ? se += L(je, !0, K) : K && (se += "th");
            } else {
              var ue = Math.floor(Math.log10(Q) / 3);
              ue > h.length && (ue = h.length);
              const Re = Math.pow(10, ue * 3), je = Math.floor(Q / Re), pe = Q - je * Re;
              se = (X ? ", " : "") + L(je, !1, !1) + " " + h[ue - 1], pe > 0 ? se += L(pe, !0, K) : K && (se += "th");
            }
            return se;
          }, G = L(O, !1, V);
          return G;
        }
        const S = {};
        c.forEach(function(O, V) {
          S[O.toLowerCase()] = V;
        }), l.forEach(function(O, V) {
          S[O.toLowerCase()] = V;
        }), f.forEach(function(O, V) {
          const L = O.toLowerCase();
          S[L] = (V + 2) * 10, S[L.substring(0, O.length - 1) + "ieth"] = S[L];
        }), S.hundredth = 100, h.forEach(function(O, V) {
          const L = O.toLowerCase(), G = Math.pow(10, (V + 1) * 3);
          S[L] = G, S[L + "th"] = G;
        });
        function E(O) {
          const L = O.split(/,\s|\sand\s|[\s\\-]/).map((X) => S[X]);
          let G = [0];
          return L.forEach((X) => {
            if (X < 100) {
              let K = G.pop();
              K >= 1e3 && (G.push(K), K = 0), G.push(K + X);
            } else
              G.push(G.pop() * X);
          }), G.reduce((X, K) => X + K, 0);
        }
        const M = [
          [1e3, "m"],
          [900, "cm"],
          [500, "d"],
          [400, "cd"],
          [100, "c"],
          [90, "xc"],
          [50, "l"],
          [40, "xl"],
          [10, "x"],
          [9, "ix"],
          [5, "v"],
          [4, "iv"],
          [1, "i"]
        ], A = { M: 1e3, D: 500, C: 100, L: 50, X: 10, V: 5, I: 1 };
        function $(O) {
          for (var V = 0; V < M.length; V++) {
            const L = M[V];
            if (O >= L[0])
              return L[1] + $(O - L[0]);
          }
          return "";
        }
        function x(O) {
          for (var V = 0, L = 1, G = O.length - 1; G >= 0; G--) {
            const Q = O[G], X = A[Q];
            X < L ? V -= X : (L = X, V += X);
          }
          return V;
        }
        function P(O, V) {
          for (var L = [], G = V.charCodeAt(0); O > 0; )
            L.unshift(String.fromCharCode((O - 1) % 26 + G)), O = Math.floor((O - 1) / 26);
          return L.join("");
        }
        function U(O, V) {
          for (var L = V.charCodeAt(0), G = 0, Q = 0; Q < O.length; Q++)
            G += (O.charCodeAt(O.length - Q - 1) - L + 1) * Math.pow(26, Q);
          return G;
        }
        function B(O, V) {
          if (typeof O > "u")
            return;
          O = Math.floor(O);
          const L = oe(V);
          return z(O, L);
        }
        const w = {
          DECIMAL: "decimal",
          LETTERS: "letters",
          ROMAN: "roman",
          WORDS: "words",
          SEQUENCE: "sequence"
        }, R = {
          UPPER: "upper",
          LOWER: "lower",
          TITLE: "title"
        };
        function z(O, V) {
          let L;
          const G = O < 0;
          switch (O = Math.abs(O), V.primary) {
            case w.LETTERS:
              L = P(O, V.case === R.UPPER ? "A" : "a");
              break;
            case w.ROMAN:
              L = $(O), V.case === R.UPPER && (L = L.toUpperCase());
              break;
            case w.WORDS:
              L = y(O, V.ordinal), V.case === R.UPPER ? L = L.toUpperCase() : V.case === R.LOWER && (L = L.toLowerCase());
              break;
            case w.DECIMAL:
              L = "" + O;
              var Q = V.mandatoryDigits - L.length;
              if (Q > 0) {
                var X = new Array(Q + 1).join("0");
                L = X + L;
              }
              if (V.zeroCode !== 48 && (L = o(L).map((Re) => String.fromCodePoint(Re.codePointAt(0) + V.zeroCode - 48)).join("")), V.regular) {
                const Re = Math.floor((L.length - 1) / V.groupingSeparators.position);
                for (let je = Re; je > 0; je--) {
                  const pe = L.length - je * V.groupingSeparators.position;
                  L = L.substr(0, pe) + V.groupingSeparators.character + L.substr(pe);
                }
              } else
                V.groupingSeparators.reverse().forEach((Re) => {
                  const je = L.length - Re.position;
                  L = L.substr(0, je) + Re.character + L.substr(je);
                });
              if (V.ordinal) {
                var K = { 1: "st", 2: "nd", 3: "rd" }, se = L[L.length - 1], ue = K[se];
                (!ue || L.length > 1 && L[L.length - 2] === "1") && (ue = "th"), L = L + ue;
              }
              break;
            case w.SEQUENCE:
              throw {
                code: "D3130",
                value: V.token
              };
          }
          return G && (L = "-" + L), L;
        }
        const re = [48, 1632, 1776, 1984, 2406, 2534, 2662, 2790, 2918, 3046, 3174, 3302, 3430, 3558, 3664, 3792, 3872, 4160, 4240, 6112, 6160, 6470, 6608, 6784, 6800, 6992, 7088, 7232, 7248, 42528, 43216, 43264, 43472, 43504, 43600, 44016, 65296];
        function oe(O) {
          const V = {
            type: "integer",
            primary: w.DECIMAL,
            case: R.LOWER,
            ordinal: !1
          };
          let L, G;
          const Q = O.lastIndexOf(";");
          switch (Q === -1 ? L = O : (L = O.substring(0, Q), G = O.substring(Q + 1), G[0] === "o" && (V.ordinal = !0)), L) {
            case "A":
              V.case = R.UPPER;
            case "a":
              V.primary = w.LETTERS;
              break;
            case "I":
              V.case = R.UPPER;
            case "i":
              V.primary = w.ROMAN;
              break;
            case "W":
              V.case = R.UPPER, V.primary = w.WORDS;
              break;
            case "Ww":
              V.case = R.TITLE, V.primary = w.WORDS;
              break;
            case "w":
              V.primary = w.WORDS;
              break;
            default: {
              let X = null, K = 0, se = 0, ue = [], Re = 0;
              if (o(L).map((pe) => pe.codePointAt(0)).reverse().forEach((pe) => {
                let we = !1;
                for (let Fe = 0; Fe < re.length; Fe++) {
                  const ce = re[Fe];
                  if (pe >= ce && pe <= ce + 9) {
                    if (we = !0, K++, Re++, X === null)
                      X = ce;
                    else if (ce !== X)
                      throw {
                        code: "D3131"
                      };
                    break;
                  }
                }
                we || (pe === 35 ? (Re++, se++) : ue.push({
                  position: Re,
                  character: String.fromCodePoint(pe)
                }));
              }), K > 0) {
                V.primary = w.DECIMAL, V.zeroCode = X, V.mandatoryDigits = K, V.optionalDigits = se;
                const we = function(Fe) {
                  if (Fe.length === 0)
                    return 0;
                  const ce = Fe[0].character;
                  for (let nt = 1; nt < Fe.length; nt++)
                    if (Fe[nt].character !== ce)
                      return 0;
                  const We = Fe.map((nt) => nt.position), bt = function(nt, dt) {
                    return dt === 0 ? nt : bt(dt, nt % dt);
                  }, lt = We.reduce(bt);
                  for (let nt = 1; nt <= We.length; nt++)
                    if (We.indexOf(nt * lt) === -1)
                      return 0;
                  return lt;
                }(ue);
                we > 0 ? (V.regular = !0, V.groupingSeparators = {
                  position: we,
                  character: ue[0].character
                }) : (V.regular = !1, V.groupingSeparators = ue);
              } else
                V.primary = w.SEQUENCE, V.token = L;
            }
          }
          return V;
        }
        const Ee = {
          Y: "1",
          M: "1",
          D: "1",
          d: "1",
          F: "n",
          W: "1",
          w: "1",
          X: "1",
          x: "1",
          H: "1",
          h: "1",
          P: "n",
          m: "01",
          s: "01",
          f: "1",
          Z: "01:01",
          z: "01:01",
          C: "n",
          E: "n"
        };
        function he(O) {
          var V = [];
          const L = {
            type: "datetime",
            parts: V
          }, G = function(we, Fe) {
            if (Fe > we) {
              let ce = O.substring(we, Fe);
              ce = ce.split("]]").join("]"), V.push({ type: "literal", value: ce });
            }
          };
          for (var Q = 0, X = 0; X < O.length; ) {
            if (O.charAt(X) === "[") {
              if (O.charAt(X + 1) === "[") {
                G(Q, X), V.push({ type: "literal", value: "[" }), X += 2, Q = X;
                continue;
              }
              if (G(Q, X), Q = X, X = O.indexOf("]", Q), X === -1)
                throw {
                  code: "D3135"
                };
              let we = O.substring(Q + 1, X);
              we = we.split(/\s+/).join("");
              var K = {
                type: "marker",
                component: we.charAt(0)
                // 1. The component specifier is always present and is always a single letter.
              }, se = we.lastIndexOf(","), ue;
              if (se !== -1) {
                const Fe = we.substring(se + 1), ce = Fe.indexOf("-");
                let We, bt;
                const lt = function(dt) {
                  if (!(typeof dt > "u" || dt === "*"))
                    return parseInt(dt);
                };
                ce === -1 ? We = Fe : (We = Fe.substring(0, ce), bt = Fe.substring(ce + 1));
                const nt = {
                  min: lt(We),
                  max: lt(bt)
                };
                K.width = nt, ue = we.substring(1, se);
              } else
                ue = we.substring(1);
              if (ue.length === 1)
                K.presentation1 = ue;
              else if (ue.length > 1) {
                var Re = ue.charAt(ue.length - 1);
                "atco".indexOf(Re) !== -1 ? (K.presentation2 = Re, Re === "o" && (K.ordinal = !0), K.presentation1 = ue.substring(0, ue.length - 1)) : K.presentation1 = ue;
              } else
                K.presentation1 = Ee[K.component];
              if (typeof K.presentation1 > "u")
                throw {
                  code: "D3132",
                  value: K.component
                };
              if (K.presentation1[0] === "n")
                K.names = R.LOWER;
              else if (K.presentation1[0] === "N")
                K.presentation1[1] === "n" ? K.names = R.TITLE : K.names = R.UPPER;
              else if ("YMDdFWwXxHhmsf".indexOf(K.component) !== -1) {
                var je = K.presentation1;
                if (K.presentation2 && (je += ";" + K.presentation2), K.integerFormat = oe(je), K.width && K.width.min !== void 0 && K.integerFormat.mandatoryDigits < K.width.min && (K.integerFormat.mandatoryDigits = K.width.min), "YMD".indexOf(K.component) !== -1)
                  if (K.n = -1, K.width && K.width.max !== void 0)
                    K.n = K.width.max, K.integerFormat.mandatoryDigits = K.n;
                  else {
                    var pe = K.integerFormat.mandatoryDigits + K.integerFormat.optionalDigits;
                    pe >= 2 && (K.n = pe);
                  }
              }
              (K.component === "Z" || K.component === "z") && (K.integerFormat = oe(K.presentation1)), V.push(K), Q = X + 1;
            }
            X++;
          }
          return G(Q, X), L;
        }
        const ke = ["", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"], Oe = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], ht = 1e3 * 60 * 60 * 24, Me = function(O) {
          const V = Date.UTC(O.year, O.month);
          var L = new Date(V).getUTCDay();
          return L === 0 && (L = 7), L > 4 ? V + (8 - L) * ht : V - (L - 1) * ht;
        }, Te = function(O, V) {
          return {
            year: O,
            month: V,
            nextMonth: function() {
              return V === 11 ? Te(O + 1, 0) : Te(O, V + 1);
            },
            previousMonth: function() {
              return V === 0 ? Te(O - 1, 11) : Te(O, V - 1);
            },
            nextYear: function() {
              return Te(O + 1, V);
            },
            previousYear: function() {
              return Te(O - 1, V);
            }
          };
        }, vt = function(O, V) {
          return (V - O) / (ht * 7) + 1;
        }, Se = (O, V) => {
          let L;
          switch (V) {
            case "Y":
              L = O.getUTCFullYear();
              break;
            case "M":
              L = O.getUTCMonth() + 1;
              break;
            case "D":
              L = O.getUTCDate();
              break;
            case "d": {
              const G = Date.UTC(O.getUTCFullYear(), O.getUTCMonth(), O.getUTCDate()), Q = Date.UTC(O.getUTCFullYear(), 0);
              L = (G - Q) / ht + 1;
              break;
            }
            case "F":
              L = O.getUTCDay(), L === 0 && (L = 7);
              break;
            case "W": {
              const G = Te(O.getUTCFullYear(), 0), Q = Me(G), X = Date.UTC(G.year, O.getUTCMonth(), O.getUTCDate());
              let K = vt(Q, X);
              if (K > 52) {
                const se = Me(G.nextYear());
                X >= se && (K = 1);
              } else if (K < 1) {
                const se = Me(G.previousYear());
                K = vt(se, X);
              }
              L = Math.floor(K);
              break;
            }
            case "w": {
              const G = Te(O.getUTCFullYear(), O.getUTCMonth()), Q = Me(G), X = Date.UTC(G.year, G.month, O.getUTCDate());
              let K = vt(Q, X);
              if (K > 4) {
                const se = Me(G.nextMonth());
                X >= se && (K = 1);
              } else if (K < 1) {
                const se = Me(G.previousMonth());
                K = vt(se, X);
              }
              L = Math.floor(K);
              break;
            }
            case "X": {
              const G = Te(O.getUTCFullYear(), 0), Q = Me(G), X = Me(G.nextYear()), K = O.getTime();
              K < Q ? L = G.year - 1 : K >= X ? L = G.year + 1 : L = G.year;
              break;
            }
            case "x": {
              const G = Te(O.getUTCFullYear(), O.getUTCMonth()), Q = Me(G), X = G.nextMonth(), K = Me(X), se = O.getTime();
              se < Q ? L = G.previousMonth().month + 1 : se >= K ? L = X.month + 1 : L = G.month + 1;
              break;
            }
            case "H":
              L = O.getUTCHours();
              break;
            case "h":
              L = O.getUTCHours(), L = L % 12, L === 0 && (L = 12);
              break;
            case "P":
              L = O.getUTCHours() >= 12 ? "pm" : "am";
              break;
            case "m":
              L = O.getUTCMinutes();
              break;
            case "s":
              L = O.getUTCSeconds();
              break;
            case "f":
              L = O.getUTCMilliseconds();
              break;
            case "Z":
            case "z":
              break;
            case "C":
              L = "ISO";
              break;
            case "E":
              L = "ISO";
              break;
          }
          return L;
        };
        let Y = null;
        function F(O, V, L) {
          var G = 0, Q = 0;
          if (typeof L < "u") {
            const je = parseInt(L);
            G = Math.floor(je / 100), Q = je % 100;
          }
          var X = function(je, pe) {
            var we = Se(je, pe.component);
            if ("YMDdFWwXxHhms".indexOf(pe.component) !== -1)
              if (pe.component === "Y" && pe.n !== -1 && (we = we % Math.pow(10, pe.n)), pe.names) {
                if (pe.component === "M" || pe.component === "x")
                  we = Oe[we - 1];
                else if (pe.component === "F")
                  we = ke[we];
                else
                  throw {
                    code: "D3133",
                    value: pe.component
                  };
                pe.names === R.UPPER ? we = we.toUpperCase() : pe.names === R.LOWER && (we = we.toLowerCase()), pe.width && we.length > pe.width.max && (we = we.substring(0, pe.width.max));
              } else
                we = z(we, pe.integerFormat);
            else if (pe.component === "f")
              we = z(we, pe.integerFormat);
            else if (pe.component === "Z" || pe.component === "z") {
              const Fe = G * 100 + Q;
              if (pe.integerFormat.regular)
                we = z(Fe, pe.integerFormat);
              else {
                const ce = pe.integerFormat.mandatoryDigits;
                if (ce === 1 || ce === 2)
                  we = z(G, pe.integerFormat), Q !== 0 && (we += ":" + B(Q, "00"));
                else if (ce === 3 || ce === 4)
                  we = z(Fe, pe.integerFormat);
                else
                  throw {
                    code: "D3134",
                    value: ce
                  };
              }
              Fe >= 0 && (we = "+" + we), pe.component === "z" && (we = "GMT" + we), Fe === 0 && pe.presentation2 === "t" && (we = "Z");
            }
            return we;
          };
          let K;
          typeof V > "u" ? (Y === null && (Y = he("[Y0001]-[M01]-[D01]T[H01]:[m01]:[s01].[f001][Z01:01t]")), K = Y) : K = he(V);
          const se = (60 * G + Q) * 60 * 1e3, ue = new Date(O + se);
          let Re = "";
          return K.parts.forEach(function(je) {
            je.type === "literal" ? Re += je.value : Re += X(ue, je);
          }), Re;
        }
        function g(O) {
          var V = {};
          if (O.type === "datetime")
            V.type = "datetime", V.parts = O.parts.map(function(L) {
              var G = {};
              if (L.type === "literal")
                G.regex = L.value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
              else if (L.component === "Z" || L.component === "z") {
                let X;
                Array.isArray(L.integerFormat.groupingSeparators) || (X = L.integerFormat.groupingSeparators), G.regex = "", L.component === "z" && (G.regex = "GMT"), G.regex += "[-+][0-9]+", X && (G.regex += X.character + "[0-9]+"), G.parse = function(K) {
                  L.component === "z" && (K = K.substring(3));
                  let se = 0, ue = 0;
                  return X ? (se = Number.parseInt(K.substring(0, K.indexOf(X.character))), ue = Number.parseInt(K.substring(K.indexOf(X.character) + 1))) : K.length - 1 <= 2 ? se = Number.parseInt(K) : (se = Number.parseInt(K.substring(0, 3)), ue = Number.parseInt(K.substring(3))), se * 60 + ue;
                };
              } else if (L.integerFormat)
                L.integerFormat.n = L.n, G = g(L.integerFormat);
              else {
                G.regex = "[a-zA-Z]+";
                var Q = {};
                if (L.component === "M" || L.component === "x")
                  Oe.forEach(function(X, K) {
                    L.width && L.width.max ? Q[X.substring(0, L.width.max)] = K + 1 : Q[X] = K + 1;
                  });
                else if (L.component === "F")
                  ke.forEach(function(X, K) {
                    K > 0 && (L.width && L.width.max ? Q[X.substring(0, L.width.max)] = K : Q[X] = K);
                  });
                else if (L.component === "P")
                  Q = { am: 0, AM: 0, pm: 1, PM: 1 };
                else
                  throw {
                    code: "D3133",
                    value: L.component
                  };
                G.parse = function(X) {
                  return Q[X];
                };
              }
              return G.component = L.component, G;
            });
          else {
            V.type = "integer";
            const L = O.case === R.UPPER;
            let G;
            switch (O.n && O.n > 0 ? O.optionalDigits === 0 ? G = `{${O.n}}` : G = `{${O.n - O.optionalDigits},${O.n}}` : G = "+", O.primary) {
              case w.LETTERS:
                V.regex = L ? "[A-Z]+" : "[a-z]+", V.parse = function(Q) {
                  return U(Q, L ? "A" : "a");
                };
                break;
              case w.ROMAN:
                V.regex = L ? "[MDCLXVI]+" : "[mdclxvi]+", V.parse = function(Q) {
                  return x(L ? Q : Q.toUpperCase());
                };
                break;
              case w.WORDS:
                V.regex = "(?:" + Object.keys(S).concat("and", "[\\-, ]").join("|") + ")+", V.parse = function(Q) {
                  return E(Q.toLowerCase());
                };
                break;
              case w.DECIMAL:
                V.regex = `[0-9]${G}`, O.ordinal && (V.regex += "(?:th|st|nd|rd)"), V.parse = function(Q) {
                  let X = Q;
                  return O.ordinal && (X = Q.substring(0, Q.length - 2)), O.regular ? X = X.split(",").join("") : O.groupingSeparators.forEach((K) => {
                    X = X.split(K.character).join("");
                  }), O.zeroCode !== 48 && (X = X.split("").map((K) => String.fromCodePoint(K.codePointAt(0) - O.zeroCode + 48)).join("")), parseInt(X);
                };
                break;
              case w.SEQUENCE:
                throw {
                  code: "D3130",
                  value: O.token
                };
            }
          }
          return V;
        }
        function m(O, V) {
          if (typeof O > "u")
            return;
          const L = oe(V);
          return g(L).parse(O);
        }
        function p(O, V) {
          const L = he(V), G = g(L), Q = "^" + G.parts.map((ue) => "(" + ue.regex + ")").join("") + "$";
          var K = new RegExp(Q, "i").exec(O);
          if (K !== null) {
            const ce = {};
            for (let Je = 1; Je < K.length; Je++) {
              const v = G.parts[Je - 1];
              v.parse && (ce[v.component] = v.parse(K[Je]));
            }
            if (Object.getOwnPropertyNames(ce).length === 0)
              return;
            let We = 0;
            const bt = (Je) => {
              We <<= 1, We += Je ? 1 : 0;
            }, lt = (Je) => !(~Je & We) && !!(Je & We);
            "YXMxWwdD".split("").forEach((Je) => bt(ce[Je]));
            const dt = !lt(161) && lt(130), Mt = lt(84), pt = !Mt && lt(72);
            We = 0, "PHhmsf".split("").forEach((Je) => bt(ce[Je]));
            const Jt = !lt(23) && lt(47), Or = (dt ? "YD" : Mt ? "XxwF" : pt ? "XWF" : "YMD") + (Jt ? "Phmsf" : "Hmsf"), Ft = this.environment.timestamp;
            let vr = !1, mt = !1;
            if (Or.split("").forEach((Je) => {
              if (typeof ce[Je] > "u")
                vr ? (ce[Je] = "MDd".indexOf(Je) !== -1 ? 1 : 0, mt = !0) : ce[Je] = Se(Ft, Je);
              else if (vr = !0, mt)
                throw {
                  code: "D3136"
                };
            }), ce.M > 0 ? ce.M -= 1 : ce.M = 0, dt) {
              const Je = Date.UTC(ce.Y, 0), v = (ce.d - 1) * 1e3 * 60 * 60 * 24, N = new Date(Je + v);
              ce.M = N.getUTCMonth(), ce.D = N.getUTCDate();
            }
            if (Mt)
              throw {
                code: "D3136"
              };
            if (pt)
              throw {
                code: "D3136"
              };
            Jt && (ce.H = ce.h === 12 ? 0 : ce.h, ce.P === 1 && (ce.H += 12));
            var se = Date.UTC(ce.Y, ce.M, ce.D, ce.H, ce.m, ce.s, ce.f);
            return (ce.Z || ce.z) && (se -= (ce.Z || ce.z) * 60 * 1e3), se;
          }
        }
        var k = new RegExp("^\\d{4}(-[01]\\d)*(-[0-3]\\d)*(T[0-2]\\d:[0-5]\\d:[0-5]\\d)*(\\.\\d+)?([+-][0-2]\\d:?[0-5]\\d|Z)?$");
        function H(O, V) {
          if (!(typeof O > "u"))
            if (typeof V > "u") {
              if (!k.test(O))
                throw {
                  stack: new Error().stack,
                  code: "D3110",
                  value: O
                };
              return Date.parse(O);
            } else
              return p.call(this, O, V);
        }
        function J(O, V, L) {
          if (!(typeof O > "u"))
            return F.call(this, O, V, L);
        }
        return {
          formatInteger: B,
          parseInteger: m,
          fromMillis: J,
          toMillis: H
        };
      }();
      n.exports = a;
    }, { "./utils": 6 }], 2: [function(r, n, s) {
      (function(i) {
        (function() {
          var a = r("./utils");
          const o = (() => {
            var c = a.isNumeric, l = a.isArrayOfStrings, f = a.isArrayOfNumbers, h = a.createSequence, y = a.isSequence, S = a.isFunction, E = a.isLambda, M = a.isPromise, A = a.getFunctionArity, $ = a.isDeepEqual, x = a.stringToArray;
            function P(u) {
              if (!(typeof u > "u")) {
                var d = 0;
                return u.forEach(function(b) {
                  d += b;
                }), d;
              }
            }
            function U(u) {
              return typeof u > "u" ? 0 : u.length;
            }
            function B(u) {
              if (!(typeof u > "u" || u.length === 0))
                return Math.max.apply(Math, u);
            }
            function w(u) {
              if (!(typeof u > "u" || u.length === 0))
                return Math.min.apply(Math, u);
            }
            function R(u) {
              if (!(typeof u > "u" || u.length === 0)) {
                var d = 0;
                return u.forEach(function(b) {
                  d += b;
                }), d / u.length;
              }
            }
            function z(u, d = !1) {
              if (!(typeof u > "u")) {
                var b;
                if (typeof u == "string")
                  b = u;
                else if (S(u))
                  b = "";
                else {
                  if (typeof u == "number" && !isFinite(u))
                    throw {
                      code: "D3001",
                      value: u,
                      stack: new Error().stack
                    };
                  var j = d ? 2 : 0;
                  Array.isArray(u) && u.outerWrapper && (u = u[0]), b = JSON.stringify(u, function(C, Z) {
                    return typeof Z < "u" && Z !== null && Z.toPrecision && c(Z) ? Number(Z.toPrecision(15)) : Z && S(Z) ? "" : Z;
                  }, j);
                }
                return b;
              }
            }
            function re(u, d, b) {
              if (!(typeof u > "u")) {
                var j = x(u), C = j.length;
                if (C + d < 0 && (d = 0), typeof b < "u") {
                  if (b <= 0)
                    return "";
                  var Z = d >= 0 ? d + b : C + d + b;
                  return j.slice(d, Z).join("");
                }
                return j.slice(d).join("");
              }
            }
            function oe(u, d) {
              if (!(typeof u > "u")) {
                var b = u.indexOf(d);
                return b > -1 ? u.substr(0, b) : u;
              }
            }
            function Ee(u, d) {
              if (!(typeof u > "u")) {
                var b = u.indexOf(d);
                return b > -1 ? u.substr(b + d.length) : u;
              }
            }
            function he(u) {
              if (!(typeof u > "u"))
                return u.toLowerCase();
            }
            function ke(u) {
              if (!(typeof u > "u"))
                return u.toUpperCase();
            }
            function Oe(u) {
              if (!(typeof u > "u"))
                return x(u).length;
            }
            function ht(u) {
              if (!(typeof u > "u")) {
                var d = u.replace(/[ \t\n\r]+/gm, " ");
                return d.charAt(0) === " " && (d = d.substring(1)), d.charAt(d.length - 1) === " " && (d = d.substring(0, d.length - 1)), d;
              }
            }
            function Me(u, d, b) {
              if (!(typeof u > "u")) {
                (typeof b > "u" || b.length === 0) && (b = " ");
                var j, C = Math.abs(d) - Oe(u);
                if (C > 0) {
                  var Z = new Array(C + 1).join(b);
                  b.length > 1 && (Z = re(Z, 0, C)), d > 0 ? j = u + Z : j = Z + u;
                } else
                  j = u;
                return j;
              }
            }
            async function Te(u, d) {
              var b = u.apply(this, [d]);
              if (M(b) && (b = await b), b && !(typeof b.start == "number" || b.end === "number" || Array.isArray(b.groups) || S(b.next)))
                throw {
                  code: "T1010",
                  stack: new Error().stack
                };
              return b;
            }
            async function vt(u, d) {
              if (!(typeof u > "u")) {
                var b;
                if (typeof d == "string")
                  b = u.indexOf(d) !== -1;
                else {
                  var j = await Te(d, u);
                  b = typeof j < "u";
                }
                return b;
              }
            }
            async function Se(u, d, b) {
              if (!(typeof u > "u")) {
                if (b < 0)
                  throw {
                    stack: new Error().stack,
                    value: b,
                    code: "D3040",
                    index: 3
                  };
                var j = h();
                if (typeof b > "u" || b > 0) {
                  var C = 0, Z = await Te(d, u);
                  if (typeof Z < "u")
                    for (; typeof Z < "u" && (typeof b > "u" || C < b); )
                      j.push({
                        match: Z.match,
                        index: Z.start,
                        groups: Z.groups
                      }), Z = await Te(Z.next), C++;
                }
                return j;
              }
            }
            async function Y(u, d, b, j) {
              if (!(typeof u > "u")) {
                var C = this;
                if (d === "")
                  throw {
                    code: "D3010",
                    stack: new Error().stack,
                    value: d,
                    index: 2
                  };
                if (j < 0)
                  throw {
                    code: "D3011",
                    stack: new Error().stack,
                    value: j,
                    index: 4
                  };
                var Z;
                typeof b == "string" ? Z = function(T) {
                  for (var _ = "", I = 0, q = b.indexOf("$", I); q !== -1 && I < b.length; ) {
                    _ += b.substring(I, q), I = q + 1;
                    var W = b.charAt(I);
                    if (W === "$")
                      _ += "$", I++;
                    else if (W === "0")
                      _ += T.match, I++;
                    else {
                      var ie;
                      if (T.groups.length === 0 ? ie = 1 : ie = Math.floor(Math.log(T.groups.length) * Math.LOG10E) + 1, q = parseInt(b.substring(I, I + ie), 10), ie > 1 && q > T.groups.length && (q = parseInt(b.substring(I, I + ie - 1), 10)), isNaN(q))
                        _ += "$";
                      else {
                        if (T.groups.length > 0) {
                          var ge = T.groups[q - 1];
                          typeof ge < "u" && (_ += ge);
                        }
                        I += q.toString().length;
                      }
                    }
                    q = b.indexOf("$", I);
                  }
                  return _ += b.substring(I), _;
                } : Z = b;
                var te = "", fe = 0;
                if (typeof j > "u" || j > 0) {
                  var be = 0;
                  if (typeof d == "string") {
                    for (var Ze = u.indexOf(d, fe); Ze !== -1 && (typeof j > "u" || be < j); )
                      te += u.substring(fe, Ze), te += b, fe = Ze + d.length, be++, Ze = u.indexOf(d, fe);
                    te += u.substring(fe);
                  } else {
                    var Ue = await Te(d, u);
                    if (typeof Ue < "u") {
                      for (; typeof Ue < "u" && (typeof j > "u" || be < j); ) {
                        te += u.substring(fe, Ue.start);
                        var Qe = Z.apply(C, [Ue]);
                        if (M(Qe) && (Qe = await Qe), typeof Qe == "string")
                          te += Qe;
                        else
                          throw {
                            code: "D3012",
                            stack: new Error().stack,
                            value: Qe
                          };
                        fe = Ue.start + Ue.match.length, be++, Ue = await Te(Ue.next);
                      }
                      te += u.substring(fe);
                    } else
                      te = u;
                  }
                } else
                  te = u;
                return te;
              }
            }
            function F(u) {
              if (!(typeof u > "u")) {
                var d = typeof window < "u" ? (
                  /* istanbul ignore next */
                  window.btoa
                ) : function(b) {
                  return new i.Buffer.from(b, "binary").toString("base64");
                };
                return d(u);
              }
            }
            function g(u) {
              if (!(typeof u > "u")) {
                var d = typeof window < "u" ? (
                  /* istanbul ignore next */
                  window.atob
                ) : function(b) {
                  return new i.Buffer.from(b, "base64").toString("binary");
                };
                return d(u);
              }
            }
            function m(u) {
              if (!(typeof u > "u")) {
                var d;
                try {
                  d = encodeURIComponent(u);
                } catch {
                  throw {
                    code: "D3140",
                    stack: new Error().stack,
                    value: u,
                    functionName: "encodeUrlComponent"
                  };
                }
                return d;
              }
            }
            function p(u) {
              if (!(typeof u > "u")) {
                var d;
                try {
                  d = encodeURI(u);
                } catch {
                  throw {
                    code: "D3140",
                    stack: new Error().stack,
                    value: u,
                    functionName: "encodeUrl"
                  };
                }
                return d;
              }
            }
            function k(u) {
              if (!(typeof u > "u")) {
                var d;
                try {
                  d = decodeURIComponent(u);
                } catch {
                  throw {
                    code: "D3140",
                    stack: new Error().stack,
                    value: u,
                    functionName: "decodeUrlComponent"
                  };
                }
                return d;
              }
            }
            function H(u) {
              if (!(typeof u > "u")) {
                var d;
                try {
                  d = decodeURI(u);
                } catch {
                  throw {
                    code: "D3140",
                    stack: new Error().stack,
                    value: u,
                    functionName: "decodeUrl"
                  };
                }
                return d;
              }
            }
            async function J(u, d, b) {
              if (!(typeof u > "u")) {
                if (b < 0)
                  throw {
                    code: "D3020",
                    stack: new Error().stack,
                    value: b,
                    index: 3
                  };
                var j = [];
                if (typeof b > "u" || b > 0)
                  if (typeof d == "string")
                    j = u.split(d, b);
                  else {
                    var C = 0, Z = await Te(d, u);
                    if (typeof Z < "u") {
                      for (var te = 0; typeof Z < "u" && (typeof b > "u" || C < b); )
                        j.push(u.substring(te, Z.start)), te = Z.end, Z = await Te(Z.next), C++;
                      (typeof b > "u" || C < b) && j.push(u.substring(te));
                    } else
                      j.push(u);
                  }
                return j;
              }
            }
            function O(u, d) {
              if (!(typeof u > "u"))
                return typeof d > "u" && (d = ""), u.join(d);
            }
            function V(u, d, b) {
              if (!(typeof u > "u")) {
                var j = {
                  "decimal-separator": ".",
                  "grouping-separator": ",",
                  "exponent-separator": "e",
                  infinity: "Infinity",
                  "minus-sign": "-",
                  NaN: "NaN",
                  percent: "%",
                  "per-mille": "‰",
                  "zero-digit": "0",
                  digit: "#",
                  "pattern-separator": ";"
                }, C = j;
                typeof b < "u" && Object.keys(b).forEach(function(me) {
                  C[me] = b[me];
                });
                for (var Z = [], te = C["zero-digit"].charCodeAt(0), fe = te; fe < te + 10; fe++)
                  Z.push(String.fromCharCode(fe));
                var be = Z.concat([C["decimal-separator"], C["exponent-separator"], C["grouping-separator"], C.digit, C["pattern-separator"]]), Ze = d.split(C["pattern-separator"]);
                if (Ze.length > 2)
                  throw {
                    code: "D3080",
                    stack: new Error().stack
                  };
                var Ue = function(me) {
                  var Be = function() {
                    for (var ft, It = 0; It < me.length; It++)
                      if (ft = me.charAt(It), be.indexOf(ft) !== -1 && ft !== C["exponent-separator"])
                        return me.substring(0, It);
                  }(), ot = function() {
                    for (var ft, It = me.length - 1; It >= 0; It--)
                      if (ft = me.charAt(It), be.indexOf(ft) !== -1 && ft !== C["exponent-separator"])
                        return me.substring(It + 1);
                  }(), ze = me.substring(Be.length, me.length - ot.length), yt, Xt, St, Wt, _t = me.indexOf(C["exponent-separator"], Be.length);
                  _t === -1 || _t > me.length - ot.length ? (yt = ze, Xt = void 0) : (yt = ze.substring(0, _t), Xt = ze.substring(_t + 1));
                  var Pt = yt.indexOf(C["decimal-separator"]);
                  return Pt === -1 ? (St = yt, Wt = ot) : (St = yt.substring(0, Pt), Wt = yt.substring(Pt + 1)), {
                    prefix: Be,
                    suffix: ot,
                    activePart: ze,
                    mantissaPart: yt,
                    exponentPart: Xt,
                    integerPart: St,
                    fractionalPart: Wt,
                    subpicture: me
                  };
                }, Qe = function(me) {
                  var Be, ot, ze = me.subpicture, yt = ze.indexOf(C["decimal-separator"]);
                  yt !== ze.lastIndexOf(C["decimal-separator"]) && (Be = "D3081"), ze.indexOf(C.percent) !== ze.lastIndexOf(C.percent) && (Be = "D3082"), ze.indexOf(C["per-mille"]) !== ze.lastIndexOf(C["per-mille"]) && (Be = "D3083"), ze.indexOf(C.percent) !== -1 && ze.indexOf(C["per-mille"]) !== -1 && (Be = "D3084");
                  var Xt = !1;
                  for (ot = 0; ot < me.mantissaPart.length; ot++) {
                    var St = me.mantissaPart.charAt(ot);
                    if (Z.indexOf(St) !== -1 || St === C.digit) {
                      Xt = !0;
                      break;
                    }
                  }
                  Xt || (Be = "D3085");
                  var Wt = me.activePart.split("").map(function(ft) {
                    return be.indexOf(ft) === -1 ? "p" : "a";
                  }).join("");
                  Wt.indexOf("p") !== -1 && (Be = "D3086"), yt !== -1 ? (ze.charAt(yt - 1) === C["grouping-separator"] || ze.charAt(yt + 1) === C["grouping-separator"]) && (Be = "D3087") : me.integerPart.charAt(me.integerPart.length - 1) === C["grouping-separator"] && (Be = "D3088"), ze.indexOf(C["grouping-separator"] + C["grouping-separator"]) !== -1 && (Be = "D3089");
                  var _t = me.integerPart.indexOf(C.digit);
                  _t !== -1 && me.integerPart.substring(0, _t).split("").filter(function(ft) {
                    return Z.indexOf(ft) > -1;
                  }).length > 0 && (Be = "D3090"), _t = me.fractionalPart.lastIndexOf(C.digit), _t !== -1 && me.fractionalPart.substring(_t).split("").filter(function(ft) {
                    return Z.indexOf(ft) > -1;
                  }).length > 0 && (Be = "D3091");
                  var Pt = typeof me.exponentPart == "string";
                  if (Pt && me.exponentPart.length > 0 && (ze.indexOf(C.percent) !== -1 || ze.indexOf(C["per-mille"]) !== -1) && (Be = "D3092"), Pt && (me.exponentPart.length === 0 || me.exponentPart.split("").filter(function(ft) {
                    return Z.indexOf(ft) === -1;
                  }).length > 0) && (Be = "D3093"), Be)
                    throw {
                      code: Be,
                      stack: new Error().stack
                    };
                }, T = function(me) {
                  var Be = function($t, Ds) {
                    for (var qn = [], br = $t.indexOf(C["grouping-separator"]); br !== -1; ) {
                      var xs = (Ds ? $t.substring(0, br) : $t.substring(br)).split("").filter(function(hn) {
                        return Z.indexOf(hn) !== -1 || hn === C.digit;
                      }).length;
                      qn.push(xs), br = me.integerPart.indexOf(C["grouping-separator"], br + 1);
                    }
                    return qn;
                  }, ot = Be(me.integerPart), ze = function($t) {
                    if ($t.length === 0)
                      return 0;
                    for (var Ds = function(xs, hn) {
                      return hn === 0 ? xs : Ds(hn, xs % hn);
                    }, qn = $t.reduce(Ds), br = 1; br <= $t.length; br++)
                      if ($t.indexOf(br * qn) === -1)
                        return 0;
                    return qn;
                  }, yt = ze(ot), Xt = Be(me.fractionalPart, !0), St = me.integerPart.split("").filter(function($t) {
                    return Z.indexOf($t) !== -1;
                  }).length, Wt = St, _t = me.fractionalPart.split(""), Pt = _t.filter(function($t) {
                    return Z.indexOf($t) !== -1;
                  }).length, ft = _t.filter(function($t) {
                    return Z.indexOf($t) !== -1 || $t === C.digit;
                  }).length, It = typeof me.exponentPart == "string";
                  St === 0 && ft === 0 && (It ? (Pt = 1, ft = 1) : St = 1), It && St === 0 && me.integerPart.indexOf(C.digit) !== -1 && (St = 1), St === 0 && Pt === 0 && (Pt = 1);
                  var Ar = 0;
                  return It && (Ar = me.exponentPart.split("").filter(function($t) {
                    return Z.indexOf($t) !== -1;
                  }).length), {
                    integerPartGroupingPositions: ot,
                    regularGrouping: yt,
                    minimumIntegerPartSize: St,
                    scalingFactor: Wt,
                    prefix: me.prefix,
                    fractionalPartGroupingPositions: Xt,
                    minimumFactionalPartSize: Pt,
                    maximumFactionalPartSize: ft,
                    minimumExponentSize: Ar,
                    suffix: me.suffix,
                    picture: me.subpicture
                  };
                }, _ = Ze.map(Ue);
                _.forEach(Qe);
                var I = _.map(T), q = C["minus-sign"], W = C["zero-digit"], ie = C["decimal-separator"], ge = C["grouping-separator"];
                I.length === 1 && (I.push(JSON.parse(JSON.stringify(I[0]))), I[1].prefix = q + I[1].prefix);
                var _e;
                u >= 0 ? _e = I[0] : _e = I[1];
                var Ye;
                _e.picture.indexOf(C.percent) !== -1 ? Ye = u * 100 : _e.picture.indexOf(C["per-mille"]) !== -1 ? Ye = u * 1e3 : Ye = u;
                var et, Ce;
                if (_e.minimumExponentSize === 0)
                  et = Ye;
                else {
                  var tt = Math.pow(10, _e.scalingFactor), ct = Math.pow(10, _e.scalingFactor - 1);
                  for (et = Ye, Ce = 0; et < ct; )
                    et *= 10, Ce -= 1;
                  for (; et > tt; )
                    et /= 10, Ce += 1;
                }
                var Pe = se(et, _e.maximumFactionalPartSize), st = function(me, Be) {
                  var ot = Math.abs(me).toFixed(Be);
                  return W !== "0" && (ot = ot.split("").map(function(ze) {
                    return ze >= "0" && ze <= "9" ? Z[ze.charCodeAt(0) - 48] : ze;
                  }).join("")), ot;
                }, ye = st(Pe, _e.maximumFactionalPartSize), xe = ye.indexOf(".");
                for (xe === -1 ? ye = ye + ie : ye = ye.replace(".", ie); ye.charAt(0) === W; )
                  ye = ye.substring(1);
                for (; ye.charAt(ye.length - 1) === W; )
                  ye = ye.substring(0, ye.length - 1);
                xe = ye.indexOf(ie);
                var jt = _e.minimumIntegerPartSize - xe, Vt = _e.minimumFactionalPartSize - (ye.length - xe - 1);
                if (ye = (jt > 0 ? new Array(jt + 1).join(W) : "") + ye, ye = ye + (Vt > 0 ? new Array(Vt + 1).join(W) : ""), xe = ye.indexOf(ie), _e.regularGrouping > 0)
                  for (var Bt = Math.floor((xe - 1) / _e.regularGrouping), Yt = 1; Yt <= Bt; Yt++)
                    ye = [ye.slice(0, xe - Yt * _e.regularGrouping), ge, ye.slice(xe - Yt * _e.regularGrouping)].join("");
                else
                  _e.integerPartGroupingPositions.forEach(function(me) {
                    ye = [ye.slice(0, xe - me), ge, ye.slice(xe - me)].join(""), xe++;
                  });
                if (xe = ye.indexOf(ie), _e.fractionalPartGroupingPositions.forEach(function(me) {
                  ye = [ye.slice(0, me + xe + 1), ge, ye.slice(me + xe + 1)].join("");
                }), xe = ye.indexOf(ie), (_e.picture.indexOf(ie) === -1 || xe === ye.length - 1) && (ye = ye.substring(0, ye.length - 1)), typeof Ce < "u") {
                  var zt = st(Ce, 0);
                  jt = _e.minimumExponentSize - zt.length, jt > 0 && (zt = new Array(jt + 1).join(W) + zt), ye = ye + C["exponent-separator"] + (Ce < 0 ? q : "") + zt;
                }
                return ye = _e.prefix + ye + _e.suffix, ye;
              }
            }
            function L(u, d) {
              if (!(typeof u > "u")) {
                if (u = se(u), typeof d > "u" ? d = 10 : d = se(d), d < 2 || d > 36)
                  throw {
                    code: "D3100",
                    stack: new Error().stack,
                    value: d
                  };
                var b = u.toString(d);
                return b;
              }
            }
            function G(u) {
              var d;
              if (!(typeof u > "u")) {
                if (typeof u == "number")
                  d = u;
                else if (typeof u == "string" && /^-?[0-9]+(\.[0-9]+)?([Ee][-+]?[0-9]+)?$/.test(u) && !isNaN(parseFloat(u)) && isFinite(u))
                  d = parseFloat(u);
                else if (typeof u == "string" && /^(0[xX][0-9A-Fa-f]+)|(0[oO][0-7]+)|(0[bB][0-1]+)$/.test(u))
                  d = Number(u);
                else if (u === !0)
                  d = 1;
                else if (u === !1)
                  d = 0;
                else
                  throw {
                    code: "D3030",
                    value: u,
                    stack: new Error().stack,
                    index: 1
                  };
                return d;
              }
            }
            function Q(u) {
              var d;
              if (!(typeof u > "u"))
                return d = Math.abs(u), d;
            }
            function X(u) {
              var d;
              if (!(typeof u > "u"))
                return d = Math.floor(u), d;
            }
            function K(u) {
              var d;
              if (!(typeof u > "u"))
                return d = Math.ceil(u), d;
            }
            function se(u, d) {
              var b;
              if (!(typeof u > "u")) {
                if (d) {
                  var j = u.toString().split("e");
                  u = +(j[0] + "e" + (j[1] ? +j[1] + d : d));
                }
                b = Math.round(u);
                var C = b - u;
                return Math.abs(C) === 0.5 && Math.abs(b % 2) === 1 && (b = b - 1), d && (j = b.toString().split("e"), b = +(j[0] + "e" + (j[1] ? +j[1] - d : -d))), Object.is(b, -0) && (b = 0), b;
              }
            }
            function ue(u) {
              var d;
              if (!(typeof u > "u")) {
                if (u < 0)
                  throw {
                    stack: new Error().stack,
                    code: "D3060",
                    index: 1,
                    value: u
                  };
                return d = Math.sqrt(u), d;
              }
            }
            function Re(u, d) {
              var b;
              if (!(typeof u > "u")) {
                if (b = Math.pow(u, d), !isFinite(b))
                  throw {
                    stack: new Error().stack,
                    code: "D3061",
                    index: 1,
                    value: u,
                    exp: d
                  };
                return b;
              }
            }
            function je() {
              return Math.random();
            }
            function pe(u) {
              if (!(typeof u > "u")) {
                var d = !1;
                if (Array.isArray(u)) {
                  if (u.length === 1)
                    d = pe(u[0]);
                  else if (u.length > 1) {
                    var b = u.filter(function(j) {
                      return pe(j);
                    });
                    d = b.length > 0;
                  }
                } else
                  typeof u == "string" ? u.length > 0 && (d = !0) : c(u) ? u !== 0 && (d = !0) : u !== null && typeof u == "object" ? Object.keys(u).length > 0 && (d = !0) : typeof u == "boolean" && u === !0 && (d = !0);
                return d;
              }
            }
            function we(u) {
              if (!(typeof u > "u"))
                return !pe(u);
            }
            function Fe(u, d, b, j) {
              var C = [d], Z = A(u);
              return Z >= 2 && C.push(b), Z >= 3 && C.push(j), C;
            }
            async function ce(u, d) {
              if (!(typeof u > "u")) {
                for (var b = h(), j = 0; j < u.length; j++) {
                  var C = Fe(d, u[j], j, u), Z = await d.apply(this, C);
                  typeof Z < "u" && b.push(Z);
                }
                return b;
              }
            }
            async function We(u, d) {
              if (!(typeof u > "u")) {
                for (var b = h(), j = 0; j < u.length; j++) {
                  var C = u[j], Z = Fe(d, C, j, u), te = await d.apply(this, Z);
                  pe(te) && b.push(C);
                }
                return b;
              }
            }
            async function bt(u, d) {
              if (!(typeof u > "u")) {
                for (var b = !1, j, C = 0; C < u.length; C++) {
                  var Z = u[C], te = !0;
                  if (typeof d < "u") {
                    var fe = Fe(d, Z, C, u), be = await d.apply(this, fe);
                    te = pe(be);
                  }
                  if (te)
                    if (!b)
                      j = Z, b = !0;
                    else
                      throw {
                        stack: new Error().stack,
                        code: "D3138",
                        index: C
                      };
                }
                if (!b)
                  throw {
                    stack: new Error().stack,
                    code: "D3139"
                  };
                return j;
              }
            }
            function lt() {
              for (var u = [], d = Array.prototype.slice.call(arguments), b = Math.min.apply(Math, d.map(function(Z) {
                return Array.isArray(Z) ? Z.length : 0;
              })), j = 0; j < b; j++) {
                var C = d.map((Z) => Z[j]);
                u.push(C);
              }
              return u;
            }
            async function nt(u, d, b) {
              if (!(typeof u > "u")) {
                var j, C = A(d);
                if (C < 2)
                  throw {
                    stack: new Error().stack,
                    code: "D3050",
                    index: 1
                  };
                var Z;
                for (typeof b > "u" && u.length > 0 ? (j = u[0], Z = 1) : (j = b, Z = 0); Z < u.length; ) {
                  var te = [j, u[Z]];
                  C >= 3 && te.push(Z), C >= 4 && te.push(u), j = await d.apply(this, te), Z++;
                }
                return j;
              }
            }
            function dt(u) {
              var d = h();
              if (Array.isArray(u)) {
                var b = {};
                u.forEach(function(j) {
                  var C = dt(j);
                  C.forEach(function(Z) {
                    b[Z] = !0;
                  });
                }), d = dt(b);
              } else
                u !== null && typeof u == "object" && !E(u) && Object.keys(u).forEach((j) => d.push(j));
              return d;
            }
            function Mt(u, d) {
              var b;
              if (Array.isArray(u)) {
                b = h();
                for (var j = 0; j < u.length; j++) {
                  var C = Mt(u[j], d);
                  typeof C < "u" && (Array.isArray(C) ? C.forEach((Z) => b.push(Z)) : b.push(C));
                }
              } else
                u !== null && typeof u == "object" && (b = u[d]);
              return b;
            }
            function pt(u, d) {
              return typeof u > "u" ? d : typeof d > "u" ? u : (Array.isArray(u) || (u = h(u)), Array.isArray(d) || (d = [d]), u.concat(d));
            }
            function qt(u) {
              return !(typeof u > "u");
            }
            function Jt(u) {
              var d = h();
              if (Array.isArray(u))
                u.forEach(function(C) {
                  d = pt(d, Jt(C));
                });
              else if (u !== null && typeof u == "object" && !E(u))
                for (var b in u) {
                  var j = {};
                  j[b] = u[b], d.push(j);
                }
              else
                d = u;
              return d;
            }
            function ae(u) {
              if (!(typeof u > "u")) {
                var d = {};
                return u.forEach(function(b) {
                  for (var j in b)
                    d[j] = b[j];
                }), d;
              }
            }
            function or(u) {
              if (!(typeof u > "u")) {
                if (u.length <= 1)
                  return u;
                for (var d = u.length, b = new Array(d), j = 0; j < d; j++)
                  b[d - j - 1] = u[j];
                return b;
              }
            }
            async function Or(u, d) {
              var b = h();
              for (var j in u) {
                var C = Fe(d, u[j], j, u), Z = await d.apply(this, C);
                typeof Z < "u" && b.push(Z);
              }
              return b;
            }
            function Ft(u) {
              throw {
                code: "D3137",
                stack: new Error().stack,
                message: u || "$error() function evaluated"
              };
            }
            function vr(u, d) {
              if (!u)
                throw {
                  code: "D3141",
                  stack: new Error().stack,
                  message: d || "$assert() statement failed"
                };
            }
            function mt(u) {
              if (u !== void 0)
                return u === null ? "null" : c(u) ? "number" : typeof u == "string" ? "string" : typeof u == "boolean" ? "boolean" : Array.isArray(u) ? "array" : S(u) ? "function" : "object";
            }
            async function Je(u, d) {
              if (!(typeof u > "u")) {
                if (u.length <= 1)
                  return u;
                var b;
                if (typeof d > "u") {
                  if (!f(u) && !l(u))
                    throw {
                      stack: new Error().stack,
                      code: "D3070",
                      index: 1
                    };
                  b = async function(te, fe) {
                    return te > fe;
                  };
                } else
                  b = d;
                var j = async function(te, fe) {
                  var be = async function(Ue, Qe, T) {
                    Qe.length === 0 ? Array.prototype.push.apply(Ue, T) : T.length === 0 ? Array.prototype.push.apply(Ue, Qe) : await b(Qe[0], T[0]) ? (Ue.push(T[0]), await be(Ue, Qe, T.slice(1))) : (Ue.push(Qe[0]), await be(Ue, Qe.slice(1), T));
                  }, Ze = [];
                  return await be(Ze, te, fe), Ze;
                }, C = async function(te) {
                  if (!Array.isArray(te) || te.length <= 1)
                    return te;
                  var fe = Math.floor(te.length / 2), be = te.slice(0, fe), Ze = te.slice(fe);
                  return be = await C(be), Ze = await C(Ze), await j(be, Ze);
                }, Z = await C(u);
                return Z;
              }
            }
            function v(u) {
              if (!(typeof u > "u")) {
                if (u.length <= 1)
                  return u;
                for (var d = new Array(u.length), b = 0; b < u.length; b++) {
                  var j = Math.floor(Math.random() * (b + 1));
                  b !== j && (d[b] = d[j]), d[j] = u[b];
                }
                return d;
              }
            }
            function N(u) {
              if (!(typeof u > "u")) {
                if (!Array.isArray(u) || u.length <= 1)
                  return u;
                for (var d = y(u) ? h() : [], b = 0; b < u.length; b++) {
                  for (var j = u[b], C = !1, Z = 0; Z < d.length; Z++)
                    if ($(j, d[Z])) {
                      C = !0;
                      break;
                    }
                  C || d.push(j);
                }
                return d;
              }
            }
            async function D(u, d) {
              var b = {};
              for (var j in u) {
                var C = u[j], Z = Fe(d, C, j, u), te = await d.apply(this, Z);
                pe(te) && (b[j] = C);
              }
              return Object.keys(b).length === 0 && (b = void 0), b;
            }
            return {
              sum: P,
              count: U,
              max: B,
              min: w,
              average: R,
              string: z,
              substring: re,
              substringBefore: oe,
              substringAfter: Ee,
              lowercase: he,
              uppercase: ke,
              length: Oe,
              trim: ht,
              pad: Me,
              match: Se,
              contains: vt,
              replace: Y,
              split: J,
              join: O,
              formatNumber: V,
              formatBase: L,
              number: G,
              floor: X,
              ceil: K,
              round: se,
              abs: Q,
              sqrt: ue,
              power: Re,
              random: je,
              boolean: pe,
              not: we,
              map: ce,
              zip: lt,
              filter: We,
              single: bt,
              foldLeft: nt,
              sift: D,
              keys: dt,
              lookup: Mt,
              append: pt,
              exists: qt,
              spread: Jt,
              merge: ae,
              reverse: or,
              each: Or,
              error: Ft,
              assert: vr,
              type: mt,
              sort: Je,
              shuffle: v,
              distinct: N,
              base64encode: F,
              base64decode: g,
              encodeUrlComponent: m,
              encodeUrl: p,
              decodeUrlComponent: k,
              decodeUrl: H
            };
          })();
          n.exports = o;
        }).call(this);
      }).call(this, typeof wa < "u" ? wa : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "./utils": 6 }], 3: [function(r, n, s) {
      var i = r("./datetime"), a = r("./functions"), o = r("./utils"), c = r("./parser"), l = r("./signature"), f = function() {
        var h = o.isNumeric, y = o.isArrayOfStrings, S = o.isArrayOfNumbers, E = o.createSequence, M = o.isSequence, A = o.isFunction, $ = o.isLambda, x = o.isIterable, P = o.isPromise, U = o.getFunctionArity, B = o.isDeepEqual, w = Ft(null);
        async function R(v, N, D) {
          var u, d = D.lookup("__evaluate_entry");
          switch (d && await d(v, N, D), v.type) {
            case "path":
              u = await z(v, N, D);
              break;
            case "binary":
              u = await Oe(v, N, D);
              break;
            case "unary":
              u = await ht(v, N, D);
              break;
            case "name":
              u = Me(v, N);
              break;
            case "string":
            case "number":
            case "value":
              u = Te(v);
              break;
            case "wildcard":
              u = vt(v, N);
              break;
            case "descendant":
              u = Y(v, N);
              break;
            case "parent":
              u = D.lookup(v.slot.label);
              break;
            case "condition":
              u = await X(v, N, D);
              break;
            case "block":
              u = await K(v, N, D);
              break;
            case "bind":
              u = await Q(v, N, D);
              break;
            case "regex":
              u = se(v);
              break;
            case "function":
              u = await Fe(v, N, D);
              break;
            case "variable":
              u = ue(v, N, D);
              break;
            case "lambda":
              u = bt(v, N, D);
              break;
            case "partial":
              u = await lt(v, N, D);
              break;
            case "apply":
              u = await we(v, N, D);
              break;
            case "transform":
              u = je(v, N, D);
              break;
          }
          if (Object.prototype.hasOwnProperty.call(v, "predicate"))
            for (var b = 0; b < v.predicate.length; b++)
              u = await ke(v.predicate[b].expr, u, D);
          v.type !== "path" && Object.prototype.hasOwnProperty.call(v, "group") && (u = await V(v.group, u, D));
          var j = D.lookup("__evaluate_exit");
          return j && await j(v, N, D, u), u && M(u) && !u.tupleStream && (v.keepArray && (u.keepSingleton = !0), u.length === 0 ? u = void 0 : u.length === 1 && (u = u.keepSingleton ? u : u[0])), u;
        }
        async function z(v, N, D) {
          var u;
          Array.isArray(N) && v.steps[0].type !== "variable" ? u = N : u = E(N);
          for (var d, b = !1, j = void 0, C = 0; C < v.steps.length; C++) {
            var Z = v.steps[C];
            if (Z.tuple && (b = !0), C === 0 && Z.consarray ? d = await R(Z, u, D) : b ? j = await he(Z, u, j, D) : d = await oe(Z, u, D, C === v.steps.length - 1), !b && (typeof d > "u" || d.length === 0))
              break;
            typeof Z.focus > "u" && (u = d);
          }
          if (b)
            if (v.tuple)
              d = j;
            else
              for (d = E(), C = 0; C < j.length; C++)
                d.push(j[C]["@"]);
          return v.keepSingletonArray && (Array.isArray(d) && d.cons && !d.sequence && (d = E(d)), d.keepSingleton = !0), v.hasOwnProperty("group") && (d = await V(v.group, b ? j : d, D)), d;
        }
        function re(v, N) {
          var D = Ft(v);
          for (const u in N)
            D.bind(u, N[u]);
          return D;
        }
        async function oe(v, N, D, u) {
          var d;
          if (v.type === "sort")
            return d = await Re(v, N, D), v.stages && (d = await Ee(v.stages, d, D)), d;
          d = E();
          for (var b = 0; b < N.length; b++) {
            var j = await R(v, N[b], D);
            if (v.stages)
              for (var C = 0; C < v.stages.length; C++)
                j = await ke(v.stages[C].expr, j, D);
            typeof j < "u" && d.push(j);
          }
          var Z = E();
          return u && d.length === 1 && Array.isArray(d[0]) && !M(d[0]) ? Z = d[0] : d.forEach(function(te) {
            !Array.isArray(te) || te.cons ? Z.push(te) : te.forEach((fe) => Z.push(fe));
          }), Z;
        }
        async function Ee(v, N, D) {
          for (var u = N, d = 0; d < v.length; d++) {
            var b = v[d];
            switch (b.type) {
              case "filter":
                u = await ke(b.expr, u, D);
                break;
              case "index":
                for (var j = 0; j < u.length; j++) {
                  var C = u[j];
                  C[b.value] = j;
                }
                break;
            }
          }
          return u;
        }
        async function he(v, N, D, u) {
          var d;
          if (v.type === "sort") {
            if (D)
              d = await Re(v, D, u);
            else {
              var b = await Re(v, N, u);
              d = E(), d.tupleStream = !0;
              for (var j = 0; j < b.length; j++) {
                var C = { "@": b[j] };
                C[v.index] = j, d.push(C);
              }
            }
            return v.stages && (d = await Ee(v.stages, d, u)), d;
          }
          d = E(), d.tupleStream = !0;
          var Z = u;
          D === void 0 && (D = N.map((Ze) => ({ "@": Ze })));
          for (var te = 0; te < D.length; te++) {
            Z = re(u, D[te]);
            var fe = await R(v, D[te]["@"], Z);
            if (typeof fe < "u") {
              Array.isArray(fe) || (fe = [fe]);
              for (var be = 0; be < fe.length; be++)
                C = {}, Object.assign(C, D[te]), fe.tupleStream ? Object.assign(C, fe[be]) : (v.focus ? (C[v.focus] = fe[be], C["@"] = D[te]["@"]) : C["@"] = fe[be], v.index && (C[v.index] = be), v.ancestor && (C[v.ancestor.label] = D[te]["@"])), d.push(C);
            }
          }
          return v.stages && (d = await Ee(v.stages, d, u)), d;
        }
        async function ke(v, N, D) {
          var u = E();
          if (N && N.tupleStream && (u.tupleStream = !0), Array.isArray(N) || (N = E(N)), v.type === "number") {
            var d = Math.floor(v.value);
            d < 0 && (d = N.length + d);
            var b = N[d];
            typeof b < "u" && (Array.isArray(b) ? u = b : u.push(b));
          } else
            for (d = 0; d < N.length; d++) {
              var b = N[d], j = b, C = D;
              N.tupleStream && (j = b["@"], C = re(D, b));
              var Z = await R(v, j, C);
              h(Z) && (Z = [Z]), S(Z) ? Z.forEach(function(fe) {
                var be = Math.floor(fe);
                be < 0 && (be = N.length + be), be === d && u.push(b);
              }) : a.boolean(Z) && u.push(b);
            }
          return u;
        }
        async function Oe(v, N, D) {
          var u, d = await R(v.lhs, N, D), b = v.value, j = async () => await R(v.rhs, N, D);
          if (b === "and" || b === "or")
            try {
              return await H(d, j, b);
            } catch (Z) {
              throw Z.position = v.position, Z.token = b, Z;
            }
          var C = await j();
          try {
            switch (b) {
              case "+":
              case "-":
              case "*":
              case "/":
              case "%":
                u = g(d, C, b);
                break;
              case "=":
              case "!=":
                u = m(d, C, b);
                break;
              case "<":
              case "<=":
              case ">":
              case ">=":
                u = p(d, C, b);
                break;
              case "&":
                u = O(d, C);
                break;
              case "..":
                u = G(d, C);
                break;
              case "in":
                u = k(d, C);
                break;
            }
          } catch (Z) {
            throw Z.position = v.position, Z.token = b, Z;
          }
          return u;
        }
        async function ht(v, N, D) {
          var u;
          switch (v.value) {
            case "-":
              if (u = await R(v.expression, N, D), typeof u > "u")
                u = void 0;
              else if (h(u))
                u = -u;
              else
                throw {
                  code: "D1002",
                  stack: new Error().stack,
                  position: v.position,
                  token: v.value,
                  value: u
                };
              break;
            case "[":
              u = [];
              let j = await Promise.all(v.expressions.map(async (C, Z) => (D.isParallelCall = Z > 0, [C, await R(C, N, D)])));
              for (let C of j) {
                var [d, b] = C;
                typeof b < "u" && (d.value === "[" ? u.push(b) : u = a.append(u, b));
              }
              v.consarray && Object.defineProperty(u, "cons", {
                enumerable: !1,
                configurable: !1,
                value: !0
              });
              break;
            case "{":
              u = await V(v, N, D);
              break;
          }
          return u;
        }
        function Me(v, N, D) {
          return a.lookup(N, v.value);
        }
        function Te(v) {
          return v.value;
        }
        function vt(v, N) {
          var D = E();
          return Array.isArray(N) && N.outerWrapper && N.length > 0 && (N = N[0]), N !== null && typeof N == "object" && Object.keys(N).forEach(function(u) {
            var d = N[u];
            Array.isArray(d) ? (d = Se(d), D = a.append(D, d)) : D.push(d);
          }), D;
        }
        function Se(v, N) {
          return typeof N > "u" && (N = []), Array.isArray(v) ? v.forEach(function(D) {
            Se(D, N);
          }) : N.push(v), N;
        }
        function Y(v, N) {
          var D, u = E();
          return typeof N < "u" && (F(N, u), u.length === 1 ? D = u[0] : D = u), D;
        }
        function F(v, N) {
          Array.isArray(v) || N.push(v), Array.isArray(v) ? v.forEach(function(D) {
            F(D, N);
          }) : v !== null && typeof v == "object" && Object.keys(v).forEach(function(D) {
            F(v[D], N);
          });
        }
        function g(v, N, D) {
          var u;
          if (typeof v < "u" && !h(v))
            throw {
              code: "T2001",
              stack: new Error().stack,
              value: v
            };
          if (typeof N < "u" && !h(N))
            throw {
              code: "T2002",
              stack: new Error().stack,
              value: N
            };
          if (typeof v > "u" || typeof N > "u")
            return u;
          switch (D) {
            case "+":
              u = v + N;
              break;
            case "-":
              u = v - N;
              break;
            case "*":
              u = v * N;
              break;
            case "/":
              u = v / N;
              break;
            case "%":
              u = v % N;
              break;
          }
          return u;
        }
        function m(v, N, D) {
          var u, d = typeof v, b = typeof N;
          if (d === "undefined" || b === "undefined")
            return !1;
          switch (D) {
            case "=":
              u = B(v, N);
              break;
            case "!=":
              u = !B(v, N);
              break;
          }
          return u;
        }
        function p(v, N, D) {
          var u, d = typeof v, b = typeof N, j = d === "undefined" || d === "string" || d === "number", C = b === "undefined" || b === "string" || b === "number";
          if (!j || !C)
            throw {
              code: "T2010",
              stack: new Error().stack,
              value: d === "string" || d === "number" ? N : v
            };
          if (!(d === "undefined" || b === "undefined")) {
            if (d !== b)
              throw {
                code: "T2009",
                stack: new Error().stack,
                value: v,
                value2: N
              };
            switch (D) {
              case "<":
                u = v < N;
                break;
              case "<=":
                u = v <= N;
                break;
              case ">":
                u = v > N;
                break;
              case ">=":
                u = v >= N;
                break;
            }
            return u;
          }
        }
        function k(v, N) {
          var D = !1;
          if (typeof v > "u" || typeof N > "u")
            return !1;
          Array.isArray(N) || (N = [N]);
          for (var u = 0; u < N.length; u++)
            if (N[u] === v) {
              D = !0;
              break;
            }
          return D;
        }
        async function H(v, N, D) {
          var u, d = J(v);
          switch (D) {
            case "and":
              u = d && J(await N());
              break;
            case "or":
              u = d || J(await N());
              break;
          }
          return u;
        }
        function J(v) {
          var N = a.boolean(v);
          return typeof N > "u" ? !1 : N;
        }
        function O(v, N) {
          var D, u = "", d = "";
          return typeof v < "u" && (u = a.string(v)), typeof N < "u" && (d = a.string(N)), D = u.concat(d), D;
        }
        async function V(v, N, D) {
          var u = {}, d = {}, b = !!(N && N.tupleStream);
          Array.isArray(N) || (N = E(N)), N.length === 0 && N.push(void 0);
          for (var j = 0; j < N.length; j++)
            for (var C = N[j], Z = b ? re(D, C) : D, te = 0; te < v.lhs.length; te++) {
              var fe = v.lhs[te], be = await R(fe[0], b ? C["@"] : C, Z);
              if (typeof be != "string" && be !== void 0)
                throw {
                  code: "T1003",
                  stack: new Error().stack,
                  position: v.position,
                  value: be
                };
              if (be !== void 0) {
                var Ze = { data: C, exprIndex: te };
                if (d.hasOwnProperty(be)) {
                  if (d[be].exprIndex !== te)
                    throw {
                      code: "D1009",
                      stack: new Error().stack,
                      position: v.position,
                      value: be
                    };
                  d[be].data = a.append(d[be].data, C);
                } else
                  d[be] = Ze;
              }
            }
          let Ue = await Promise.all(Object.keys(d).map(async (T, _) => {
            let I = d[T];
            var q = I.data, W = D;
            if (b) {
              var ie = L(I.data);
              q = ie["@"], delete ie["@"], W = re(D, ie);
            }
            return D.isParallelCall = _ > 0, [T, await R(v.lhs[I.exprIndex][1], q, W)];
          }));
          for (let T of Ue) {
            var [be, Qe] = await T;
            typeof Qe < "u" && (u[be] = Qe);
          }
          return u;
        }
        function L(v) {
          if (!Array.isArray(v))
            return v;
          var N = {};
          Object.assign(N, v[0]);
          for (var D = 1; D < v.length; D++)
            for (const u in v[D])
              N[u] = a.append(N[u], v[D][u]);
          return N;
        }
        function G(v, N) {
          var D;
          if (typeof v < "u" && !Number.isInteger(v))
            throw {
              code: "T2003",
              stack: new Error().stack,
              value: v
            };
          if (typeof N < "u" && !Number.isInteger(N))
            throw {
              code: "T2004",
              stack: new Error().stack,
              value: N
            };
          if (typeof v > "u" || typeof N > "u" || v > N)
            return D;
          var u = N - v + 1;
          if (u > 1e7)
            throw {
              code: "D2014",
              stack: new Error().stack,
              value: u
            };
          D = new Array(u);
          for (var d = v, b = 0; d <= N; d++, b++)
            D[b] = d;
          return D.sequence = !0, D;
        }
        async function Q(v, N, D) {
          var u = await R(v.rhs, N, D);
          return D.bind(v.lhs.value, u), u;
        }
        async function X(v, N, D) {
          var u, d = await R(v.condition, N, D);
          return a.boolean(d) ? u = await R(v.then, N, D) : typeof v.else < "u" && (u = await R(v.else, N, D)), u;
        }
        async function K(v, N, D) {
          for (var u, d = Ft(D), b = 0; b < v.expressions.length; b++)
            u = await R(v.expressions[b], N, d);
          return u;
        }
        function se(v) {
          var N = new Je.RegexEngine(v.value), D = function(u, d) {
            var b;
            N.lastIndex = d || 0;
            var j = N.exec(u);
            if (j !== null) {
              if (b = {
                match: j[0],
                start: j.index,
                end: j.index + j[0].length,
                groups: []
              }, j.length > 1)
                for (var C = 1; C < j.length; C++)
                  b.groups.push(j[C]);
              b.next = function() {
                if (!(N.lastIndex >= u.length)) {
                  var Z = D(u, N.lastIndex);
                  if (Z && Z.match === "")
                    throw {
                      code: "D1004",
                      stack: new Error().stack,
                      position: v.position,
                      value: v.value.source
                    };
                  return Z;
                }
              };
            }
            return b;
          };
          return D;
        }
        function ue(v, N, D) {
          var u;
          return v.value === "" ? u = N && N.outerWrapper ? N[0] : N : u = D.lookup(v.value), u;
        }
        async function Re(v, N, D) {
          var u, d = N, b = !!N.tupleStream, j = async function(Z, te) {
            for (var fe = 0, be = 0; fe === 0 && be < v.terms.length; be++) {
              var Ze = v.terms[be], Ue = Z, Qe = D;
              b && (Ue = Z["@"], Qe = re(D, Z));
              var T = await R(Ze.expression, Ue, Qe);
              Ue = te, Qe = D, b && (Ue = te["@"], Qe = re(D, te));
              var _ = await R(Ze.expression, Ue, Qe), I = typeof T, q = typeof _;
              if (I === "undefined") {
                fe = q === "undefined" ? 0 : 1;
                continue;
              }
              if (q === "undefined") {
                fe = -1;
                continue;
              }
              if (!(I === "string" || I === "number") || !(q === "string" || q === "number"))
                throw {
                  code: "T2008",
                  stack: new Error().stack,
                  position: v.position,
                  value: I === "string" || I === "number" ? _ : T
                };
              if (I !== q)
                throw {
                  code: "T2007",
                  stack: new Error().stack,
                  position: v.position,
                  value: T,
                  value2: _
                };
              T !== _ && (T < _ ? fe = -1 : fe = 1, Ze.descending === !0 && (fe = -fe));
            }
            return fe === 1;
          }, C = {
            environment: D,
            input: N
          };
          return u = await a.sort.apply(C, [d, j]), u;
        }
        function je(v, N, D) {
          var u = async function(d) {
            if (!(typeof d > "u")) {
              var b = D.lookup("clone");
              if (!A(b))
                throw {
                  code: "T2013",
                  stack: new Error().stack,
                  position: v.position
                };
              var j = await ce(b, [d], null, D), C = await R(v.pattern, j, D);
              if (typeof C < "u") {
                Array.isArray(C) || (C = [C]);
                for (var Z = 0; Z < C.length; Z++) {
                  var te = C[Z], fe = await R(v.update, te, D), be = typeof fe;
                  if (be !== "undefined") {
                    if (be !== "object" || fe === null || Array.isArray(fe))
                      throw {
                        code: "T2011",
                        stack: new Error().stack,
                        position: v.update.position,
                        value: fe
                      };
                    for (var Ze in fe)
                      te[Ze] = fe[Ze];
                  }
                  if (typeof v.delete < "u") {
                    var Ue = await R(v.delete, te, D);
                    if (typeof Ue < "u") {
                      var Qe = Ue;
                      if (Array.isArray(Ue) || (Ue = [Ue]), !y(Ue))
                        throw {
                          code: "T2012",
                          stack: new Error().stack,
                          position: v.delete.position,
                          value: Qe
                        };
                      for (var T = 0; T < Ue.length; T++)
                        typeof te == "object" && te !== null && delete te[Ue[T]];
                    }
                  }
                }
              }
              return j;
            }
          };
          return ae(u, "<(oa):o>");
        }
        var pe = c("function($f, $g) { function($x){ $g($f($x)) } }");
        async function we(v, N, D) {
          var u, d = await R(v.lhs, N, D);
          if (v.rhs.type === "function")
            u = await Fe(v.rhs, N, D, { context: d });
          else {
            var b = await R(v.rhs, N, D);
            if (!A(b))
              throw {
                code: "T2006",
                stack: new Error().stack,
                position: v.position,
                value: b
              };
            if (A(d)) {
              var j = await R(pe, null, D);
              u = await ce(j, [d, b], null, D);
            } else
              u = await ce(b, [d], null, D);
          }
          return u;
        }
        async function Fe(v, N, D, u) {
          var d, b = await R(v.procedure, N, D);
          if (typeof b > "u" && v.procedure.type === "path" && D.lookup(v.procedure.steps[0].value))
            throw {
              code: "T1005",
              stack: new Error().stack,
              position: v.position,
              token: v.procedure.steps[0].value
            };
          var j = [];
          typeof u < "u" && j.push(u.context);
          for (var C = 0; C < v.arguments.length; C++) {
            const te = await R(v.arguments[C], N, D);
            if (A(te)) {
              const fe = async function(...be) {
                return await ce(te, be, null, D);
              };
              fe.arity = U(te), j.push(fe);
            } else
              j.push(te);
          }
          var Z = v.procedure.type === "path" ? v.procedure.steps[0].value : v.procedure.value;
          try {
            typeof b == "object" && (b.token = Z, b.position = v.position), d = await ce(b, j, N, D);
          } catch (te) {
            throw te.position || (te.position = v.position), te.token || (te.token = Z), te;
          }
          return d;
        }
        async function ce(v, N, D, u) {
          var d;
          for (d = await We(v, N, D, u); $(d) && d.thunk === !0; ) {
            var b = await R(d.body.procedure, d.input, d.environment);
            d.body.procedure.type === "variable" && (b.token = d.body.procedure.value), b.position = d.body.procedure.position;
            for (var j = [], C = 0; C < d.body.arguments.length; C++)
              j.push(await R(d.body.arguments[C], d.input, d.environment));
            d = await We(b, j, D, u);
          }
          return d;
        }
        async function We(v, N, D, u) {
          var d;
          try {
            var b = N;
            if (v && (b = nt(v.signature, N, D)), $(v))
              d = await dt(v, b);
            else if (v && v._jsonata_function === !0) {
              var j = {
                environment: u,
                input: D
              };
              d = v.implementation.apply(j, b), x(d) && (d = d.next().value), P(d) && (d = await d);
            } else if (typeof v == "function")
              d = v.apply(D, b), P(d) && (d = await d);
            else
              throw {
                code: "T1006",
                stack: new Error().stack
              };
          } catch (C) {
            throw v && (typeof C.token > "u" && typeof v.token < "u" && (C.token = v.token), C.position = v.position), C;
          }
          return d;
        }
        function bt(v, N, D) {
          var u = {
            _jsonata_lambda: !0,
            input: N,
            environment: D,
            arguments: v.arguments,
            signature: v.signature,
            body: v.body
          };
          return v.thunk === !0 && (u.thunk = !0), u.apply = async function(d, b) {
            return await ce(u, b, N, d ? d.environment : D);
          }, u;
        }
        async function lt(v, N, D) {
          for (var u, d = [], b = 0; b < v.arguments.length; b++) {
            var j = v.arguments[b];
            j.type === "operator" && j.value === "?" ? d.push(j) : d.push(await R(j, N, D));
          }
          var C = await R(v.procedure, N, D);
          if (typeof C > "u" && v.procedure.type === "path" && D.lookup(v.procedure.steps[0].value))
            throw {
              code: "T1007",
              stack: new Error().stack,
              position: v.position,
              token: v.procedure.steps[0].value
            };
          if ($(C))
            u = Mt(C, d);
          else if (C && C._jsonata_function === !0)
            u = pt(C.implementation, d);
          else if (typeof C == "function")
            u = pt(C, d);
          else
            throw {
              code: "T1008",
              stack: new Error().stack,
              position: v.position,
              token: v.procedure.type === "path" ? v.procedure.steps[0].value : v.procedure.value
            };
          return u;
        }
        function nt(v, N, D) {
          if (typeof v > "u")
            return N;
          var u = v.validate(N, D);
          return u;
        }
        async function dt(v, N) {
          var D, u = Ft(v.environment);
          return v.arguments.forEach(function(d, b) {
            u.bind(d.value, N[b]);
          }), typeof v.body == "function" ? D = await qt(v.body, u) : D = await R(v.body, v.input, u), D;
        }
        function Mt(v, N) {
          var D = Ft(v.environment), u = [];
          v.arguments.forEach(function(b, j) {
            var C = N[j];
            C && C.type === "operator" && C.value === "?" ? u.push(b) : D.bind(b.value, C);
          });
          var d = {
            _jsonata_lambda: !0,
            input: v.input,
            environment: D,
            arguments: u,
            body: v.body
          };
          return d;
        }
        function pt(v, N) {
          var D = Jt(v);
          D = D.map(function(j) {
            return "$" + j.trim();
          });
          var u = "function(" + D.join(", ") + "){ _ }", d = c(u);
          d.body = v;
          var b = Mt(d, N);
          return b;
        }
        async function qt(v, N) {
          var D = Jt(v), u = D.map(function(j) {
            return N.lookup(j.trim());
          }), d = {
            environment: N
          }, b = v.apply(d, u);
          return P(b) && (b = await b), b;
        }
        function Jt(v) {
          var N = v.toString(), D = /\(([^)]*)\)/.exec(N)[1], u = D.split(",");
          return u;
        }
        function ae(v, N) {
          var D = {
            _jsonata_function: !0,
            implementation: v
          };
          return typeof N < "u" && (D.signature = l(N)), D;
        }
        async function or(v, N) {
          if (!(typeof v > "u")) {
            var D = this.input;
            typeof N < "u" && (D = N, Array.isArray(D) && !M(D) && (D = E(D), D.outerWrapper = !0));
            try {
              var u = c(v, !1);
            } catch (b) {
              throw mt(b), {
                stack: new Error().stack,
                code: "D3120",
                value: b.message,
                error: b
              };
            }
            try {
              var d = await R(u, D, this.environment);
            } catch (b) {
              throw mt(b), {
                stack: new Error().stack,
                code: "D3121",
                value: b.message,
                error: b
              };
            }
            return d;
          }
        }
        function Or(v) {
          if (!(typeof v > "u"))
            return JSON.parse(a.string(v));
        }
        function Ft(v) {
          var N = {};
          return {
            bind: function(D, u) {
              N[D] = u;
            },
            lookup: function(D) {
              var u;
              return N.hasOwnProperty(D) ? u = N[D] : v && (u = v.lookup(D)), u;
            },
            timestamp: v ? v.timestamp : null,
            async: v ? v.async : !1,
            isParallelCall: v ? v.isParallelCall : !1,
            global: v ? v.global : {
              ancestry: [null]
            }
          };
        }
        w.bind("sum", ae(a.sum, "<a<n>:n>")), w.bind("count", ae(a.count, "<a:n>")), w.bind("max", ae(a.max, "<a<n>:n>")), w.bind("min", ae(a.min, "<a<n>:n>")), w.bind("average", ae(a.average, "<a<n>:n>")), w.bind("string", ae(a.string, "<x-b?:s>")), w.bind("substring", ae(a.substring, "<s-nn?:s>")), w.bind("substringBefore", ae(a.substringBefore, "<s-s:s>")), w.bind("substringAfter", ae(a.substringAfter, "<s-s:s>")), w.bind("lowercase", ae(a.lowercase, "<s-:s>")), w.bind("uppercase", ae(a.uppercase, "<s-:s>")), w.bind("length", ae(a.length, "<s-:n>")), w.bind("trim", ae(a.trim, "<s-:s>")), w.bind("pad", ae(a.pad, "<s-ns?:s>")), w.bind("match", ae(a.match, "<s-f<s:o>n?:a<o>>")), w.bind("contains", ae(a.contains, "<s-(sf):b>")), w.bind("replace", ae(a.replace, "<s-(sf)(sf)n?:s>")), w.bind("split", ae(a.split, "<s-(sf)n?:a<s>>")), w.bind("join", ae(a.join, "<a<s>s?:s>")), w.bind("formatNumber", ae(a.formatNumber, "<n-so?:s>")), w.bind("formatBase", ae(a.formatBase, "<n-n?:s>")), w.bind("formatInteger", ae(i.formatInteger, "<n-s:s>")), w.bind("parseInteger", ae(i.parseInteger, "<s-s:n>")), w.bind("number", ae(a.number, "<(nsb)-:n>")), w.bind("floor", ae(a.floor, "<n-:n>")), w.bind("ceil", ae(a.ceil, "<n-:n>")), w.bind("round", ae(a.round, "<n-n?:n>")), w.bind("abs", ae(a.abs, "<n-:n>")), w.bind("sqrt", ae(a.sqrt, "<n-:n>")), w.bind("power", ae(a.power, "<n-n:n>")), w.bind("random", ae(a.random, "<:n>")), w.bind("boolean", ae(a.boolean, "<x-:b>")), w.bind("not", ae(a.not, "<x-:b>")), w.bind("map", ae(a.map, "<af>")), w.bind("zip", ae(a.zip, "<a+>")), w.bind("filter", ae(a.filter, "<af>")), w.bind("single", ae(a.single, "<af?>")), w.bind("reduce", ae(a.foldLeft, "<afj?:j>")), w.bind("sift", ae(a.sift, "<o-f?:o>")), w.bind("keys", ae(a.keys, "<x-:a<s>>")), w.bind("lookup", ae(a.lookup, "<x-s:x>")), w.bind("append", ae(a.append, "<xx:a>")), w.bind("exists", ae(a.exists, "<x:b>")), w.bind("spread", ae(a.spread, "<x-:a<o>>")), w.bind("merge", ae(a.merge, "<a<o>:o>")), w.bind("reverse", ae(a.reverse, "<a:a>")), w.bind("each", ae(a.each, "<o-f:a>")), w.bind("error", ae(a.error, "<s?:x>")), w.bind("assert", ae(a.assert, "<bs?:x>")), w.bind("type", ae(a.type, "<x:s>")), w.bind("sort", ae(a.sort, "<af?:a>")), w.bind("shuffle", ae(a.shuffle, "<a:a>")), w.bind("distinct", ae(a.distinct, "<x:x>")), w.bind("base64encode", ae(a.base64encode, "<s-:s>")), w.bind("base64decode", ae(a.base64decode, "<s-:s>")), w.bind("encodeUrlComponent", ae(a.encodeUrlComponent, "<s-:s>")), w.bind("encodeUrl", ae(a.encodeUrl, "<s-:s>")), w.bind("decodeUrlComponent", ae(a.decodeUrlComponent, "<s-:s>")), w.bind("decodeUrl", ae(a.decodeUrl, "<s-:s>")), w.bind("eval", ae(or, "<sx?:x>")), w.bind("toMillis", ae(i.toMillis, "<s-s?:n>")), w.bind("fromMillis", ae(i.fromMillis, "<n-s?s?:s>")), w.bind("clone", ae(Or, "<(oa)-:o>"));
        var vr = {
          S0101: "String literal must be terminated by a matching quote",
          S0102: "Number out of range: {{token}}",
          S0103: "Unsupported escape sequence: \\{{token}}",
          S0104: "The escape sequence \\u must be followed by 4 hex digits",
          S0105: "Quoted property name must be terminated with a backquote (`)",
          S0106: "Comment has no closing tag",
          S0201: "Syntax error: {{token}}",
          S0202: "Expected {{value}}, got {{token}}",
          S0203: "Expected {{value}} before end of expression",
          S0204: "Unknown operator: {{token}}",
          S0205: "Unexpected token: {{token}}",
          S0206: "Unknown expression type: {{token}}",
          S0207: "Unexpected end of expression",
          S0208: "Parameter {{value}} of function definition must be a variable name (start with $)",
          S0209: "A predicate cannot follow a grouping expression in a step",
          S0210: "Each step can only have one grouping expression",
          S0211: "The symbol {{token}} cannot be used as a unary operator",
          S0212: "The left side of := must be a variable name (start with $)",
          S0213: "The literal value {{value}} cannot be used as a step within a path expression",
          S0214: "The right side of {{token}} must be a variable name (start with $)",
          S0215: "A context variable binding must precede any predicates on a step",
          S0216: "A context variable binding must precede the 'order-by' clause on a step",
          S0217: "The object representing the 'parent' cannot be derived from this expression",
          S0301: "Empty regular expressions are not allowed",
          S0302: "No terminating / in regular expression",
          S0402: "Choice groups containing parameterized types are not supported",
          S0401: "Type parameters can only be applied to functions and arrays",
          S0500: "Attempted to evaluate an expression containing syntax error(s)",
          T0410: "Argument {{index}} of function {{token}} does not match function signature",
          T0411: "Context value is not a compatible type with argument {{index}} of function {{token}}",
          T0412: "Argument {{index}} of function {{token}} must be an array of {{type}}",
          D1001: "Number out of range: {{value}}",
          D1002: "Cannot negate a non-numeric value: {{value}}",
          T1003: "Key in object structure must evaluate to a string; got: {{value}}",
          D1004: "Regular expression matches zero length string",
          T1005: "Attempted to invoke a non-function. Did you mean ${{{token}}}?",
          T1006: "Attempted to invoke a non-function",
          T1007: "Attempted to partially apply a non-function. Did you mean ${{{token}}}?",
          T1008: "Attempted to partially apply a non-function",
          D1009: "Multiple key definitions evaluate to same key: {{value}}",
          T1010: "The matcher function argument passed to function {{token}} does not return the correct object structure",
          T2001: "The left side of the {{token}} operator must evaluate to a number",
          T2002: "The right side of the {{token}} operator must evaluate to a number",
          T2003: "The left side of the range operator (..) must evaluate to an integer",
          T2004: "The right side of the range operator (..) must evaluate to an integer",
          D2005: "The left side of := must be a variable name (start with $)",
          // defunct - replaced by S0212 parser error
          T2006: "The right side of the function application operator ~> must be a function",
          T2007: "Type mismatch when comparing values {{value}} and {{value2}} in order-by clause",
          T2008: "The expressions within an order-by clause must evaluate to numeric or string values",
          T2009: "The values {{value}} and {{value2}} either side of operator {{token}} must be of the same data type",
          T2010: "The expressions either side of operator {{token}} must evaluate to numeric or string values",
          T2011: "The insert/update clause of the transform expression must evaluate to an object: {{value}}",
          T2012: "The delete clause of the transform expression must evaluate to a string or array of strings: {{value}}",
          T2013: "The transform expression clones the input object using the $clone() function.  This has been overridden in the current scope by a non-function.",
          D2014: "The size of the sequence allocated by the range operator (..) must not exceed 1e6.  Attempted to allocate {{value}}.",
          D3001: "Attempting to invoke string function on Infinity or NaN",
          D3010: "Second argument of replace function cannot be an empty string",
          D3011: "Fourth argument of replace function must evaluate to a positive number",
          D3012: "Attempted to replace a matched string with a non-string value",
          D3020: "Third argument of split function must evaluate to a positive number",
          D3030: "Unable to cast value to a number: {{value}}",
          D3040: "Third argument of match function must evaluate to a positive number",
          D3050: "The second argument of reduce function must be a function with at least two arguments",
          D3060: "The sqrt function cannot be applied to a negative number: {{value}}",
          D3061: "The power function has resulted in a value that cannot be represented as a JSON number: base={{value}}, exponent={{exp}}",
          D3070: "The single argument form of the sort function can only be applied to an array of strings or an array of numbers.  Use the second argument to specify a comparison function",
          D3080: "The picture string must only contain a maximum of two sub-pictures",
          D3081: "The sub-picture must not contain more than one instance of the 'decimal-separator' character",
          D3082: "The sub-picture must not contain more than one instance of the 'percent' character",
          D3083: "The sub-picture must not contain more than one instance of the 'per-mille' character",
          D3084: "The sub-picture must not contain both a 'percent' and a 'per-mille' character",
          D3085: "The mantissa part of a sub-picture must contain at least one character that is either an 'optional digit character' or a member of the 'decimal digit family'",
          D3086: "The sub-picture must not contain a passive character that is preceded by an active character and that is followed by another active character",
          D3087: "The sub-picture must not contain a 'grouping-separator' character that appears adjacent to a 'decimal-separator' character",
          D3088: "The sub-picture must not contain a 'grouping-separator' at the end of the integer part",
          D3089: "The sub-picture must not contain two adjacent instances of the 'grouping-separator' character",
          D3090: "The integer part of the sub-picture must not contain a member of the 'decimal digit family' that is followed by an instance of the 'optional digit character'",
          D3091: "The fractional part of the sub-picture must not contain an instance of the 'optional digit character' that is followed by a member of the 'decimal digit family'",
          D3092: "A sub-picture that contains a 'percent' or 'per-mille' character must not contain a character treated as an 'exponent-separator'",
          D3093: "The exponent part of the sub-picture must comprise only of one or more characters that are members of the 'decimal digit family'",
          D3100: "The radix of the formatBase function must be between 2 and 36.  It was given {{value}}",
          D3110: "The argument of the toMillis function must be an ISO 8601 formatted timestamp. Given {{value}}",
          D3120: "Syntax error in expression passed to function eval: {{value}}",
          D3121: "Dynamic error evaluating the expression passed to function eval: {{value}}",
          D3130: "Formatting or parsing an integer as a sequence starting with {{value}} is not supported by this implementation",
          D3131: "In a decimal digit pattern, all digits must be from the same decimal group",
          D3132: "Unknown component specifier {{value}} in date/time picture string",
          D3133: "The 'name' modifier can only be applied to months and days in the date/time picture string, not {{value}}",
          D3134: "The timezone integer format specifier cannot have more than four digits",
          D3135: "No matching closing bracket ']' in date/time picture string",
          D3136: "The date/time picture string is missing specifiers required to parse the timestamp",
          D3137: "{{{message}}}",
          D3138: "The $single() function expected exactly 1 matching result.  Instead it matched more.",
          D3139: "The $single() function expected exactly 1 matching result.  Instead it matched 0.",
          D3140: "Malformed URL passed to ${{{functionName}}}(): {{value}}",
          D3141: "{{{message}}}"
        };
        function mt(v) {
          var N = vr[v.code];
          if (typeof N < "u") {
            var D = N.replace(/\{\{\{([^}]+)}}}/g, function() {
              return v[arguments[1]];
            });
            D = D.replace(/\{\{([^}]+)}}/g, function() {
              return JSON.stringify(v[arguments[1]]);
            }), v.message = D;
          }
        }
        function Je(v, N) {
          var D, u;
          try {
            D = c(v, N && N.recover), u = D.errors, delete D.errors;
          } catch (j) {
            throw mt(j), j;
          }
          var d = Ft(w), b = /* @__PURE__ */ new Date();
          return d.bind("now", ae(function(j, C) {
            return i.fromMillis(b.getTime(), j, C);
          }, "<s?s?:s>")), d.bind("millis", ae(function() {
            return b.getTime();
          }, "<:n>")), N && N.RegexEngine ? Je.RegexEngine = N.RegexEngine : Je.RegexEngine = RegExp, {
            evaluate: async function(j, C, Z) {
              if (typeof u < "u") {
                var te = {
                  code: "S0500",
                  position: 0
                };
                throw mt(te), te;
              }
              if (typeof C < "u") {
                var fe;
                fe = Ft(d);
                for (var be in C)
                  fe.bind(be, C[be]);
              } else
                fe = d;
              fe.bind("$", j), b = /* @__PURE__ */ new Date(), fe.timestamp = b, Array.isArray(j) && !M(j) && (j = E(j), j.outerWrapper = !0);
              var Ze;
              try {
                return Ze = await R(D, j, fe), typeof Z == "function" && Z(null, Ze), Ze;
              } catch (Ue) {
                throw mt(Ue), Ue;
              }
            },
            assign: function(j, C) {
              d.bind(j, C);
            },
            registerFunction: function(j, C, Z) {
              var te = ae(C, Z);
              d.bind(j, te);
            },
            ast: function() {
              return D;
            },
            errors: function() {
              return u;
            }
          };
        }
        return Je.parser = c, Je;
      }();
      n.exports = f;
    }, { "./datetime": 1, "./functions": 2, "./parser": 4, "./signature": 5, "./utils": 6 }], 4: [function(r, n, s) {
      var i = r("./signature");
      const a = /* @__PURE__ */ (() => {
        var o = {
          ".": 75,
          "[": 80,
          "]": 0,
          "{": 70,
          "}": 0,
          "(": 80,
          ")": 0,
          ",": 0,
          "@": 80,
          "#": 80,
          ";": 80,
          ":": 80,
          "?": 20,
          "+": 50,
          "-": 50,
          "*": 60,
          "/": 60,
          "%": 60,
          "|": 20,
          "=": 40,
          "<": 40,
          ">": 40,
          "^": 40,
          "**": 60,
          "..": 20,
          ":=": 10,
          "!=": 40,
          "<=": 40,
          ">=": 40,
          "~>": 40,
          and: 30,
          or: 25,
          in: 40,
          "&": 50,
          "!": 0,
          // not an operator, but needed as a stop character for name tokens
          "~": 0
          // not an operator, but needed as a stop character for name tokens
        }, c = {
          // JSON string escape sequences - see json.org
          '"': '"',
          "\\": "\\",
          "/": "/",
          b: "\b",
          f: "\f",
          n: `
`,
          r: "\r",
          t: "	"
        }, l = function(h) {
          var y = 0, S = h.length, E = function($, x) {
            var P = { type: $, value: x, position: y };
            return P;
          }, M = function() {
            for (var $ = y, x = 0, P, U, B = function(R) {
              if (h.charAt(R) === "/" && x === 0) {
                for (var z = 0; h.charAt(R - (z + 1)) === "\\"; )
                  z++;
                if (z % 2 === 0)
                  return !0;
              }
              return !1;
            }; y < S; ) {
              var w = h.charAt(y);
              if (B(y)) {
                if (P = h.substring($, y), P === "")
                  throw {
                    code: "S0301",
                    stack: new Error().stack,
                    position: y
                  };
                for (y++, w = h.charAt(y), $ = y; w === "i" || w === "m"; )
                  y++, w = h.charAt(y);
                return U = h.substring($, y) + "g", new RegExp(P, U);
              }
              (w === "(" || w === "[" || w === "{") && h.charAt(y - 1) !== "\\" && x++, (w === ")" || w === "]" || w === "}") && h.charAt(y - 1) !== "\\" && x--, y++;
            }
            throw {
              code: "S0302",
              stack: new Error().stack,
              position: y
            };
          }, A = function($) {
            if (y >= S)
              return null;
            for (var x = h.charAt(y); y < S && ` 	
\r\v`.indexOf(x) > -1; )
              y++, x = h.charAt(y);
            if (x === "/" && h.charAt(y + 1) === "*") {
              var P = y;
              for (y += 2, x = h.charAt(y); !(x === "*" && h.charAt(y + 1) === "/"); )
                if (x = h.charAt(++y), y >= S)
                  throw {
                    code: "S0106",
                    stack: new Error().stack,
                    position: P
                  };
              return y += 2, x = h.charAt(y), A($);
            }
            if ($ !== !0 && x === "/")
              return y++, E("regex", M());
            if (x === "." && h.charAt(y + 1) === ".")
              return y += 2, E("operator", "..");
            if (x === ":" && h.charAt(y + 1) === "=")
              return y += 2, E("operator", ":=");
            if (x === "!" && h.charAt(y + 1) === "=")
              return y += 2, E("operator", "!=");
            if (x === ">" && h.charAt(y + 1) === "=")
              return y += 2, E("operator", ">=");
            if (x === "<" && h.charAt(y + 1) === "=")
              return y += 2, E("operator", "<=");
            if (x === "*" && h.charAt(y + 1) === "*")
              return y += 2, E("operator", "**");
            if (x === "~" && h.charAt(y + 1) === ">")
              return y += 2, E("operator", "~>");
            if (Object.prototype.hasOwnProperty.call(o, x))
              return y++, E("operator", x);
            if (x === '"' || x === "'") {
              var U = x;
              y++;
              for (var B = ""; y < S; ) {
                if (x = h.charAt(y), x === "\\")
                  if (y++, x = h.charAt(y), Object.prototype.hasOwnProperty.call(c, x))
                    B += c[x];
                  else if (x === "u") {
                    var w = h.substr(y + 1, 4);
                    if (/^[0-9a-fA-F]+$/.test(w)) {
                      var R = parseInt(w, 16);
                      B += String.fromCharCode(R), y += 4;
                    } else
                      throw {
                        code: "S0104",
                        stack: new Error().stack,
                        position: y
                      };
                  } else
                    throw {
                      code: "S0103",
                      stack: new Error().stack,
                      position: y,
                      token: x
                    };
                else {
                  if (x === U)
                    return y++, E("string", B);
                  B += x;
                }
                y++;
              }
              throw {
                code: "S0101",
                stack: new Error().stack,
                position: y
              };
            }
            var z = /^-?(0|([1-9][0-9]*))(\.[0-9]+)?([Ee][-+]?[0-9]+)?/, re = z.exec(h.substring(y));
            if (re !== null) {
              var oe = parseFloat(re[0]);
              if (!isNaN(oe) && isFinite(oe))
                return y += re[0].length, E("number", oe);
              throw {
                code: "S0102",
                stack: new Error().stack,
                position: y,
                token: re[0]
              };
            }
            var Ee;
            if (x === "`") {
              y++;
              var he = h.indexOf("`", y);
              if (he !== -1)
                return Ee = h.substring(y, he), y = he + 1, E("name", Ee);
              throw y = S, {
                code: "S0105",
                stack: new Error().stack,
                position: y
              };
            }
            for (var ke = y, Oe; ; )
              if (Oe = h.charAt(ke), ke === S || ` 	
\r\v`.indexOf(Oe) > -1 || Object.prototype.hasOwnProperty.call(o, Oe)) {
                if (h.charAt(y) === "$")
                  return Ee = h.substring(y + 1, ke), y = ke, E("variable", Ee);
                switch (Ee = h.substring(y, ke), y = ke, Ee) {
                  case "or":
                  case "in":
                  case "and":
                    return E("operator", Ee);
                  case "true":
                    return E("value", !0);
                  case "false":
                    return E("value", !1);
                  case "null":
                    return E("value", null);
                  default:
                    return y === S && Ee === "" ? null : E("name", Ee);
                }
              } else
                ke++;
          };
          return A;
        }, f = function(h, y) {
          var S, E, M = {}, A = [], $ = function() {
            var g = [];
            S.id !== "(end)" && g.push({ type: S.type, value: S.value, position: S.position });
            for (var m = E(); m !== null; )
              g.push(m), m = E();
            return g;
          }, x = {
            nud: function() {
              var g = {
                code: "S0211",
                token: this.value,
                position: this.position
              };
              if (y)
                return g.remaining = $(), g.type = "error", A.push(g), g;
              throw g.stack = new Error().stack, g;
            }
          }, P = function(g, m) {
            var p = M[g];
            return m = m || 0, p ? m >= p.lbp && (p.lbp = m) : (p = Object.create(x), p.id = p.value = g, p.lbp = m, M[g] = p), p;
          }, U = function(g) {
            if (y) {
              g.remaining = $(), A.push(g);
              var m = M["(error)"];
              return S = Object.create(m), S.error = g, S.type = "(error)", S;
            } else
              throw g.stack = new Error().stack, g;
          }, B = function(g, m) {
            if (g && S.id !== g) {
              var p;
              S.id === "(end)" ? p = "S0203" : p = "S0202";
              var k = {
                code: p,
                position: S.position,
                token: S.value,
                value: g
              };
              return U(k);
            }
            var H = E(m);
            if (H === null)
              return S = M["(end)"], S.position = h.length, S;
            var J = H.value, O = H.type, V;
            switch (O) {
              case "name":
              case "variable":
                V = M["(name)"];
                break;
              case "operator":
                if (V = M[J], !V)
                  return U({
                    code: "S0204",
                    stack: new Error().stack,
                    position: H.position,
                    token: J
                  });
                break;
              case "string":
              case "number":
              case "value":
                V = M["(literal)"];
                break;
              case "regex":
                O = "regex", V = M["(regex)"];
                break;
              default:
                return U({
                  code: "S0205",
                  stack: new Error().stack,
                  position: H.position,
                  token: J
                });
            }
            return S = Object.create(V), S.value = J, S.type = O, S.position = H.position, S;
          }, w = function(g) {
            var m, p = S;
            for (B(null, !0), m = p.nud(); g < S.lbp; )
              p = S, B(), m = p.led(m);
            return m;
          }, R = function(g) {
            var m = P(g, 0);
            m.nud = function() {
              return this;
            };
          }, z = function(g, m, p) {
            var k = m || o[g], H = P(g, k);
            return H.led = p || function(J) {
              return this.lhs = J, this.rhs = w(k), this.type = "binary", this;
            }, H;
          }, re = function(g, m, p) {
            var k = P(g, m);
            return k.led = p, k;
          }, oe = function(g, m) {
            var p = P(g);
            return p.nud = m || function() {
              return this.expression = w(70), this.type = "unary", this;
            }, p;
          };
          R("(end)"), R("(name)"), R("(literal)"), R("(regex)"), P(":"), P(";"), P(","), P(")"), P("]"), P("}"), P(".."), z("."), z("+"), z("-"), z("*"), z("/"), z("%"), z("="), z("<"), z(">"), z("!="), z("<="), z(">="), z("&"), z("and"), z("or"), z("in"), R("and"), R("or"), R("in"), oe("-"), z("~>"), re("(error)", 10, function(g) {
            return this.lhs = g, this.error = S.error, this.remaining = $(), this.type = "error", this;
          }), oe("*", function() {
            return this.type = "wildcard", this;
          }), oe("**", function() {
            return this.type = "descendant", this;
          }), oe("%", function() {
            return this.type = "parent", this;
          }), z("(", o["("], function(g) {
            if (this.procedure = g, this.type = "function", this.arguments = [], S.id !== ")")
              for (; S.type === "operator" && S.id === "?" ? (this.type = "partial", this.arguments.push(S), B("?")) : this.arguments.push(w(0)), S.id === ","; )
                B(",");
            if (B(")", !0), g.type === "name" && (g.value === "function" || g.value === "λ")) {
              if (this.arguments.forEach(function(J, O) {
                if (J.type !== "variable")
                  return U({
                    code: "S0208",
                    stack: new Error().stack,
                    position: J.position,
                    token: J.value,
                    value: O + 1
                  });
              }), this.type = "lambda", S.id === "<") {
                for (var m = S.position, p = 1, k = "<"; p > 0 && S.id !== "{" && S.id !== "(end)"; ) {
                  var H = B();
                  H.id === ">" ? p-- : H.id === "<" && p++, k += H.value;
                }
                B(">");
                try {
                  this.signature = i(k);
                } catch (J) {
                  return J.position = m + J.offset, U(J);
                }
              }
              B("{"), this.body = w(0), B("}");
            }
            return this;
          }), oe("(", function() {
            for (var g = []; S.id !== ")" && (g.push(w(0)), S.id === ";"); )
              B(";");
            return B(")", !0), this.type = "block", this.expressions = g, this;
          }), oe("[", function() {
            var g = [];
            if (S.id !== "]")
              for (; ; ) {
                var m = w(0);
                if (S.id === "..") {
                  var p = { type: "binary", value: "..", position: S.position, lhs: m };
                  B(".."), p.rhs = w(0), m = p;
                }
                if (g.push(m), S.id !== ",")
                  break;
                B(",");
              }
            return B("]", !0), this.expressions = g, this.type = "unary", this;
          }), z("[", o["["], function(g) {
            if (S.id === "]") {
              for (var m = g; m && m.type === "binary" && m.value === "["; )
                m = m.lhs;
              return m.keepArray = !0, B("]"), g;
            } else
              return this.lhs = g, this.rhs = w(o["]"]), this.type = "binary", B("]", !0), this;
          }), z("^", o["^"], function(g) {
            B("(");
            for (var m = []; ; ) {
              var p = {
                descending: !1
              };
              if (S.id === "<" ? B("<") : S.id === ">" && (p.descending = !0, B(">")), p.expression = w(0), m.push(p), S.id !== ",")
                break;
              B(",");
            }
            return B(")"), this.lhs = g, this.rhs = m, this.type = "binary", this;
          });
          var Ee = function(g) {
            var m = [];
            if (S.id !== "}")
              for (; ; ) {
                var p = w(0);
                B(":");
                var k = w(0);
                if (m.push([p, k]), S.id !== ",")
                  break;
                B(",");
              }
            return B("}", !0), typeof g > "u" ? (this.lhs = m, this.type = "unary") : (this.lhs = g, this.rhs = m, this.type = "binary"), this;
          };
          oe("{", Ee), z("{", o["{"], Ee), re(":=", o[":="], function(g) {
            return g.type !== "variable" ? U({
              code: "S0212",
              stack: new Error().stack,
              position: g.position,
              token: g.value
            }) : (this.lhs = g, this.rhs = w(o[":="] - 1), this.type = "binary", this);
          }), z("@", o["@"], function(g) {
            return this.lhs = g, this.rhs = w(o["@"]), this.rhs.type !== "variable" ? U({
              code: "S0214",
              stack: new Error().stack,
              position: this.rhs.position,
              token: "@"
            }) : (this.type = "binary", this);
          }), z("#", o["#"], function(g) {
            return this.lhs = g, this.rhs = w(o["#"]), this.rhs.type !== "variable" ? U({
              code: "S0214",
              stack: new Error().stack,
              position: this.rhs.position,
              token: "#"
            }) : (this.type = "binary", this);
          }), z("?", o["?"], function(g) {
            return this.type = "condition", this.condition = g, this.then = w(0), S.id === ":" && (B(":"), this.else = w(0)), this;
          }), oe("|", function() {
            return this.type = "transform", this.pattern = w(0), B("|"), this.update = w(0), S.id === "," && (B(","), this.delete = w(0)), B("|"), this;
          });
          var he = function(g) {
            var m;
            if (g.type === "function" && !g.predicate) {
              var p = { type: "lambda", thunk: !0, arguments: [], position: g.position };
              p.body = g, m = p;
            } else if (g.type === "condition")
              g.then = he(g.then), typeof g.else < "u" && (g.else = he(g.else)), m = g;
            else if (g.type === "block") {
              var k = g.expressions.length;
              k > 0 && (g.expressions[k - 1] = he(g.expressions[k - 1])), m = g;
            } else
              m = g;
            return m;
          }, ke = 0, Oe = 0, ht = [], Me = function(g, m) {
            switch (g.type) {
              case "name":
              case "wildcard":
                m.level--, m.level === 0 && (typeof g.ancestor > "u" || (ht[m.index].slot.label = g.ancestor.label), g.ancestor = m, g.tuple = !0);
                break;
              case "parent":
                m.level++;
                break;
              case "block":
                g.expressions.length > 0 && (g.tuple = !0, m = Me(g.expressions[g.expressions.length - 1], m));
                break;
              case "path":
                g.tuple = !0;
                var p = g.steps.length - 1;
                for (m = Me(g.steps[p--], m); m.level > 0 && p >= 0; )
                  m = Me(g.steps[p--], m);
                break;
              default:
                throw {
                  code: "S0217",
                  token: g.type,
                  position: g.position
                };
            }
            return m;
          }, Te = function(g, m) {
            if (typeof m.seekingParent < "u" || m.type === "parent") {
              var p = typeof m.seekingParent < "u" ? m.seekingParent : [];
              m.type === "parent" && p.push(m.slot), typeof g.seekingParent > "u" ? g.seekingParent = p : Array.prototype.push.apply(g.seekingParent, p);
            }
          }, vt = function(g) {
            var m = g.steps.length - 1, p = g.steps[m], k = typeof p.seekingParent < "u" ? p.seekingParent : [];
            p.type === "parent" && k.push(p.slot);
            for (var H = 0; H < k.length; H++) {
              var J = k[H];
              for (m = g.steps.length - 2; J.level > 0; ) {
                if (m < 0) {
                  typeof g.seekingParent > "u" ? g.seekingParent = [J] : g.seekingParent.push(J);
                  break;
                }
                for (var O = g.steps[m--]; m >= 0 && O.focus && g.steps[m].focus; )
                  O = g.steps[m--];
                J = Me(O, J);
              }
            }
          }, Se = function(g) {
            var m;
            switch (g.type) {
              case "binary":
                switch (g.value) {
                  case ".":
                    var p = Se(g.lhs);
                    p.type === "path" ? m = p : m = { type: "path", steps: [p] }, p.type === "parent" && (m.seekingParent = [p.slot]);
                    var k = Se(g.rhs);
                    k.type === "function" && k.procedure.type === "path" && k.procedure.steps.length === 1 && k.procedure.steps[0].type === "name" && m.steps[m.steps.length - 1].type === "function" && (m.steps[m.steps.length - 1].nextFunction = k.procedure.steps[0].value), k.type === "path" ? Array.prototype.push.apply(m.steps, k.steps) : (typeof k.predicate < "u" && (k.stages = k.predicate, delete k.predicate), m.steps.push(k)), m.steps.filter(function(se) {
                      if (se.type === "number" || se.type === "value")
                        throw {
                          code: "S0213",
                          stack: new Error().stack,
                          position: se.position,
                          value: se.value
                        };
                      return se.type === "string";
                    }).forEach(function(se) {
                      se.type = "name";
                    }), m.steps.filter(function(se) {
                      return se.keepArray === !0;
                    }).length > 0 && (m.keepSingletonArray = !0);
                    var H = m.steps[0];
                    H.type === "unary" && H.value === "[" && (H.consarray = !0);
                    var J = m.steps[m.steps.length - 1];
                    J.type === "unary" && J.value === "[" && (J.consarray = !0), vt(m);
                    break;
                  case "[":
                    m = Se(g.lhs);
                    var O = m, V = "predicate";
                    if (m.type === "path" && (O = m.steps[m.steps.length - 1], V = "stages"), typeof O.group < "u")
                      throw {
                        code: "S0209",
                        stack: new Error().stack,
                        position: g.position
                      };
                    typeof O[V] > "u" && (O[V] = []);
                    var L = Se(g.rhs);
                    typeof L.seekingParent < "u" && (L.seekingParent.forEach((se) => {
                      se.level === 1 ? Me(O, se) : se.level--;
                    }), Te(O, L)), O[V].push({ type: "filter", expr: L, position: g.position });
                    break;
                  case "{":
                    if (m = Se(g.lhs), typeof m.group < "u")
                      throw {
                        code: "S0210",
                        stack: new Error().stack,
                        position: g.position
                      };
                    m.group = {
                      lhs: g.rhs.map(function(se) {
                        return [Se(se[0]), Se(se[1])];
                      }),
                      position: g.position
                    };
                    break;
                  case "^":
                    m = Se(g.lhs), m.type !== "path" && (m = { type: "path", steps: [m] });
                    var G = { type: "sort", position: g.position };
                    G.terms = g.rhs.map(function(se) {
                      var ue = Se(se.expression);
                      return Te(G, ue), {
                        descending: se.descending,
                        expression: ue
                      };
                    }), m.steps.push(G), vt(m);
                    break;
                  case ":=":
                    m = { type: "bind", value: g.value, position: g.position }, m.lhs = Se(g.lhs), m.rhs = Se(g.rhs), Te(m, m.rhs);
                    break;
                  case "@":
                    if (m = Se(g.lhs), O = m, m.type === "path" && (O = m.steps[m.steps.length - 1]), typeof O.stages < "u" || typeof O.predicate < "u")
                      throw {
                        code: "S0215",
                        stack: new Error().stack,
                        position: g.position
                      };
                    if (O.type === "sort")
                      throw {
                        code: "S0216",
                        stack: new Error().stack,
                        position: g.position
                      };
                    g.keepArray && (O.keepArray = !0), O.focus = g.rhs.value, O.tuple = !0;
                    break;
                  case "#":
                    m = Se(g.lhs), O = m, m.type === "path" ? O = m.steps[m.steps.length - 1] : (m = { type: "path", steps: [m] }, typeof O.predicate < "u" && (O.stages = O.predicate, delete O.predicate)), typeof O.stages > "u" ? O.index = g.rhs.value : O.stages.push({ type: "index", value: g.rhs.value, position: g.position }), O.tuple = !0;
                    break;
                  case "~>":
                    m = { type: "apply", value: g.value, position: g.position }, m.lhs = Se(g.lhs), m.rhs = Se(g.rhs);
                    break;
                  default:
                    m = { type: g.type, value: g.value, position: g.position }, m.lhs = Se(g.lhs), m.rhs = Se(g.rhs), Te(m, m.lhs), Te(m, m.rhs);
                }
                break;
              case "unary":
                m = { type: g.type, value: g.value, position: g.position }, g.value === "[" ? m.expressions = g.expressions.map(function(se) {
                  var ue = Se(se);
                  return Te(m, ue), ue;
                }) : g.value === "{" ? m.lhs = g.lhs.map(function(se) {
                  var ue = Se(se[0]);
                  Te(m, ue);
                  var Re = Se(se[1]);
                  return Te(m, Re), [ue, Re];
                }) : (m.expression = Se(g.expression), g.value === "-" && m.expression.type === "number" ? (m = m.expression, m.value = -m.value) : Te(m, m.expression));
                break;
              case "function":
              case "partial":
                m = { type: g.type, name: g.name, value: g.value, position: g.position }, m.arguments = g.arguments.map(function(se) {
                  var ue = Se(se);
                  return Te(m, ue), ue;
                }), m.procedure = Se(g.procedure);
                break;
              case "lambda":
                m = {
                  type: g.type,
                  arguments: g.arguments,
                  signature: g.signature,
                  position: g.position
                };
                var Q = Se(g.body);
                m.body = he(Q);
                break;
              case "condition":
                m = { type: g.type, position: g.position }, m.condition = Se(g.condition), Te(m, m.condition), m.then = Se(g.then), Te(m, m.then), typeof g.else < "u" && (m.else = Se(g.else), Te(m, m.else));
                break;
              case "transform":
                m = { type: g.type, position: g.position }, m.pattern = Se(g.pattern), m.update = Se(g.update), typeof g.delete < "u" && (m.delete = Se(g.delete));
                break;
              case "block":
                m = { type: g.type, position: g.position }, m.expressions = g.expressions.map(function(se) {
                  var ue = Se(se);
                  return Te(m, ue), (ue.consarray || ue.type === "path" && ue.steps[0].consarray) && (m.consarray = !0), ue;
                });
                break;
              case "name":
                m = { type: "path", steps: [g] }, g.keepArray && (m.keepSingletonArray = !0);
                break;
              case "parent":
                m = { type: "parent", slot: { label: "!" + ke++, level: 1, index: Oe++ } }, ht.push(m);
                break;
              case "string":
              case "number":
              case "value":
              case "wildcard":
              case "descendant":
              case "variable":
              case "regex":
                m = g;
                break;
              case "operator":
                if (g.value === "and" || g.value === "or" || g.value === "in")
                  g.type = "name", m = Se(g);
                else if (g.value === "?")
                  m = g;
                else
                  throw {
                    code: "S0201",
                    stack: new Error().stack,
                    position: g.position,
                    token: g.value
                  };
                break;
              case "error":
                m = g, g.lhs && (m = Se(g.lhs));
                break;
              default:
                var X = "S0206";
                g.id === "(end)" && (X = "S0207");
                var K = {
                  code: X,
                  position: g.position,
                  token: g.value
                };
                if (y)
                  return A.push(K), { type: "error", error: K };
                throw K.stack = new Error().stack, K;
            }
            return g.keepArray && (m.keepArray = !0), m;
          };
          E = l(h), B();
          var Y = w(0);
          if (S.id !== "(end)") {
            var F = {
              code: "S0201",
              position: S.position,
              token: S.value
            };
            U(F);
          }
          if (Y = Se(Y), Y.type === "parent" || typeof Y.seekingParent < "u")
            throw {
              code: "S0217",
              token: Y.type,
              position: Y.position
            };
          return A.length > 0 && (Y.errors = A), Y;
        };
        return f;
      })();
      n.exports = a;
    }, { "./signature": 5 }], 5: [function(r, n, s) {
      var i = r("./utils");
      const a = /* @__PURE__ */ (() => {
        var o = {
          a: "arrays",
          b: "booleans",
          f: "functions",
          n: "numbers",
          o: "objects",
          s: "strings"
        };
        function c(l) {
          for (var f = 1, h = [], y = {}, S = y; f < l.length; ) {
            var E = l.charAt(f);
            if (E === ":")
              break;
            var M = function() {
              h.push(y), S = y, y = {};
            }, A = function(z, re, oe, Ee) {
              for (var he = 1, ke = re; ke < z.length; )
                if (ke++, E = z.charAt(ke), E === Ee) {
                  if (he--, he === 0)
                    break;
                } else
                  E === oe && he++;
              return ke;
            };
            switch (E) {
              case "s":
              case "n":
              case "b":
              case "l":
              case "o":
                y.regex = "[" + E + "m]", y.type = E, M();
                break;
              case "a":
                y.regex = "[asnblfom]", y.type = E, y.array = !0, M();
                break;
              case "f":
                y.regex = "f", y.type = E, M();
                break;
              case "j":
                y.regex = "[asnblom]", y.type = E, M();
                break;
              case "x":
                y.regex = "[asnblfom]", y.type = E, M();
                break;
              case "-":
                S.context = !0, S.contextRegex = new RegExp(S.regex), S.regex += "?";
                break;
              case "?":
              case "+":
                S.regex += E;
                break;
              case "(":
                var $ = A(l, f, "(", ")"), x = l.substring(f + 1, $);
                if (x.indexOf("<") === -1)
                  y.regex = "[" + x + "m]";
                else
                  throw {
                    code: "S0402",
                    stack: new Error().stack,
                    value: x,
                    offset: f
                  };
                y.type = "(" + x + ")", f = $, M();
                break;
              case "<":
                if (S.type === "a" || S.type === "f") {
                  var P = A(l, f, "<", ">");
                  S.subtype = l.substring(f + 1, P), f = P;
                } else
                  throw {
                    code: "S0401",
                    stack: new Error().stack,
                    value: S.type,
                    offset: f
                  };
                break;
            }
            f++;
          }
          var U = "^" + h.map(function(z) {
            return "(" + z.regex + ")";
          }).join("") + "$", B = new RegExp(U), w = function(z) {
            var re;
            if (i.isFunction(z))
              re = "f";
            else {
              var oe = typeof z;
              switch (oe) {
                case "string":
                  re = "s";
                  break;
                case "number":
                  re = "n";
                  break;
                case "boolean":
                  re = "b";
                  break;
                case "object":
                  z === null ? re = "l" : Array.isArray(z) ? re = "a" : re = "o";
                  break;
                case "undefined":
                default:
                  re = "m";
              }
            }
            return re;
          }, R = function(z, re) {
            for (var oe = "^", Ee = 0, he = 0; he < h.length; he++) {
              oe += h[he].regex;
              var ke = re.match(oe);
              if (ke === null)
                throw {
                  code: "T0410",
                  stack: new Error().stack,
                  value: z[Ee],
                  index: Ee + 1
                };
              Ee = ke[0].length;
            }
            throw {
              code: "T0410",
              stack: new Error().stack,
              value: z[Ee],
              index: Ee + 1
            };
          };
          return {
            definition: l,
            validate: function(z, re) {
              var oe = "";
              z.forEach(function(Oe) {
                oe += w(Oe);
              });
              var Ee = B.exec(oe);
              if (Ee) {
                var he = [], ke = 0;
                return h.forEach(function(Oe, ht) {
                  var Me = z[ke], Te = Ee[ht + 1];
                  if (Te === "")
                    if (Oe.context && Oe.contextRegex) {
                      var vt = w(re);
                      if (Oe.contextRegex.test(vt))
                        he.push(re);
                      else
                        throw {
                          code: "T0411",
                          stack: new Error().stack,
                          value: re,
                          index: ke + 1
                        };
                    } else
                      he.push(Me), ke++;
                  else
                    Te.split("").forEach(function(Se) {
                      if (Oe.type === "a") {
                        if (Se === "m")
                          Me = void 0;
                        else {
                          Me = z[ke];
                          var Y = !0;
                          if (typeof Oe.subtype < "u") {
                            if (Se !== "a" && Te !== Oe.subtype)
                              Y = !1;
                            else if (Se === "a" && Me.length > 0) {
                              var F = w(Me[0]);
                              if (F !== Oe.subtype.charAt(0))
                                Y = !1;
                              else {
                                var g = Me.filter(function(m) {
                                  return w(m) !== F;
                                });
                                Y = g.length === 0;
                              }
                            }
                          }
                          if (!Y)
                            throw {
                              code: "T0412",
                              stack: new Error().stack,
                              value: Me,
                              index: ke + 1,
                              type: o[Oe.subtype]
                            };
                          Se !== "a" && (Me = [Me]);
                        }
                        he.push(Me), ke++;
                      } else
                        he.push(Me), ke++;
                    });
                }), he;
              }
              R(z, oe);
            }
          };
        }
        return c;
      })();
      n.exports = a;
    }, { "./utils": 6 }], 6: [function(r, n, s) {
      const i = (() => {
        function a(P) {
          var U = !1;
          if (typeof P == "number" && (U = !isNaN(P), U && !isFinite(P)))
            throw {
              code: "D1001",
              value: P,
              stack: new Error().stack
            };
          return U;
        }
        function o(P) {
          var U = !1;
          return Array.isArray(P) && (U = P.filter(function(B) {
            return typeof B != "string";
          }).length === 0), U;
        }
        function c(P) {
          var U = !1;
          return Array.isArray(P) && (U = P.filter(function(B) {
            return !a(B);
          }).length === 0), U;
        }
        function l() {
          var P = [];
          return P.sequence = !0, arguments.length === 1 && P.push(arguments[0]), P;
        }
        function f(P) {
          return P.sequence === !0 && Array.isArray(P);
        }
        function h(P) {
          return P && (P._jsonata_function === !0 || P._jsonata_lambda === !0) || typeof P == "function";
        }
        function y(P) {
          var U = typeof P.arity == "number" ? P.arity : typeof P.implementation == "function" ? P.implementation.length : typeof P.length == "number" ? P.length : P.arguments.length;
          return U;
        }
        function S(P) {
          return P && P._jsonata_lambda === !0;
        }
        var E = (typeof Symbol == "function" ? Symbol : {}).iterator || "@@iterator";
        function M(P) {
          return typeof P == "object" && P !== null && E in P && "next" in P && typeof P.next == "function";
        }
        function A(P, U) {
          if (P === U)
            return !0;
          if (typeof P == "object" && typeof U == "object" && P !== null && U !== null) {
            if (Array.isArray(P) && Array.isArray(U)) {
              if (P.length !== U.length)
                return !1;
              for (var B = 0; B < P.length; B++)
                if (!A(P[B], U[B]))
                  return !1;
              return !0;
            }
            var w = Object.getOwnPropertyNames(P), R = Object.getOwnPropertyNames(U);
            if (w.length !== R.length)
              return !1;
            for (w = w.sort(), R = R.sort(), B = 0; B < w.length; B++)
              if (w[B] !== R[B])
                return !1;
            for (B = 0; B < w.length; B++) {
              var z = w[B];
              if (!A(P[z], U[z]))
                return !1;
            }
            return !0;
          }
          return !1;
        }
        function $(P) {
          return typeof P == "object" && P !== null && "then" in P && typeof P.then == "function";
        }
        function x(P) {
          var U = [];
          for (let B of P)
            U.push(B);
          return U;
        }
        return {
          isNumeric: a,
          isArrayOfStrings: o,
          isArrayOfNumbers: c,
          createSequence: l,
          isSequence: f,
          isFunction: h,
          isLambda: S,
          isIterable: M,
          getFunctionArity: y,
          isDeepEqual: A,
          stringToArray: x,
          isPromise: $
        };
      })();
      n.exports = i;
    }, {}] }, {}, [3])(3);
  });
})(pl);
var Db = pl.exports;
const xb = /* @__PURE__ */ Cu(Db);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const ml = async (t) => {
  const { expression: e, raw: r, ...n } = t;
  if (!e)
    throw new Error("Jsonata node requires `expression` input");
  const s = n.json || n, i = await xb(e).evaluate(s);
  return r ? i : { result: i };
}, Mb = async (t) => {
  if (!t || !t.raw)
    return {
      type: "object",
      properties: {
        result: {
          title: "result",
          description: "The result of the Jsonata expression",
          type: "string"
        }
      },
      required: ["result"]
    };
  try {
    const e = await ml(t, {});
    if (!e)
      return {};
    const r = {}, n = {
      type: "object",
      properties: r,
      additionalProperties: !1
    };
    return Object.entries(e).forEach(([s, i]) => {
      r[s] = {
        type: typeof i,
        title: s
      };
    }), n;
  } catch {
    return {
      type: "object",
      additionalProperties: !1,
      properties: {}
    };
  }
}, jb = async (t) => {
  const e = await Mb(t || {});
  return {
    inputSchema: {
      type: "object",
      properties: {
        expression: {
          title: "expression",
          description: "The Jsonata expression to evaluate",
          type: "string"
        },
        raw: {
          title: "raw",
          description: "Whether or not to return use the evaluation result as raw output (true) or as a port called `result` (false). Default is false.",
          type: "boolean"
        },
        json: {
          title: "json",
          description: "The JSON object to evaluate",
          type: ["object", "string"]
        }
      },
      required: ["expression"]
    },
    outputSchema: e
  };
}, Lb = {
  describe: jb,
  invoke: ml
};
/*! @rgrove/parse-xml v4.1.0 | ISC License | Copyright Ryan Grove */
var Do = Object.defineProperty, Ub = Object.getOwnPropertyDescriptor, Fb = Object.getOwnPropertyNames, Vb = Object.prototype.hasOwnProperty, qb = (t, e) => {
  for (var r in e)
    Do(t, r, { get: e[r], enumerable: !0 });
}, Bb = (t, e, r, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let s of Fb(e))
      !Vb.call(t, s) && s !== r && Do(t, s, { get: () => e[s], enumerable: !(n = Ub(e, s)) || n.enumerable });
  return t;
}, zb = (t) => Bb(Do({}, "__esModule", { value: !0 }), t), gl = {};
qb(gl, {
  XmlCdata: () => wl,
  XmlComment: () => _l,
  XmlDeclaration: () => El,
  XmlDocument: () => Sl,
  XmlDocumentType: () => $l,
  XmlElement: () => Ui,
  XmlError: () => kl,
  XmlNode: () => Ge,
  XmlProcessingInstruction: () => Oa,
  XmlText: () => Mo,
  parseXml: () => rw
});
var Wb = zb(gl), Gr = "", Hb = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, Zb = class {
  constructor(t) {
    if (this.k = this.q(t, !0), this.d = 0, this.length = t.length, this.n = this.k !== this.length, this.m = t, this.n) {
      let e = [];
      for (let r = 0, n = 0; n < this.k; ++n)
        e[n] = r, r += t.codePointAt(r) > 65535 ? 2 : 1;
      this.y = e;
    }
  }
  /**
   * Whether the current character index is at the end of the input string.
   */
  get z() {
    return this.d >= this.k;
  }
  // -- Protected Methods ------------------------------------------------------
  /**
   * Returns the number of characters in the given string, which may differ from
   * the byte length if the string contains multibyte characters.
   */
  q(t, e = this.n) {
    return e ? t.replace(Hb, "_").length : t.length;
  }
  // -- Public Methods ---------------------------------------------------------
  /**
   * Advances the scanner by the given number of characters, stopping if the end
   * of the string is reached.
   */
  g(t = 1) {
    this.d = Math.min(this.k, this.d + t);
  }
  /**
   * Returns the byte index of the given character index in the string. The two
   * may differ in strings that contain multibyte characters.
   */
  i(t = this.d) {
    var e;
    return this.n ? (e = this.y[t]) != null ? e : 1 / 0 : t;
  }
  /**
   * Consumes and returns the given number of characters if possible, advancing
   * the scanner and stopping if the end of the string is reached.
   *
   * If no characters could be consumed, an empty string will be returned.
   */
  F(t = 1) {
    let e = this.h(t);
    return this.g(t), e;
  }
  /**
   * Consumes a match for the given sticky regex, advances the scanner, updates
   * the `lastIndex` property of the regex, and returns the matching string.
   *
   * The regex must have a sticky flag ("y") so that its `lastIndex` prop can be
   * used to anchor the match at the current scanner position.
   *
   * Returns the consumed string, or an empty string if nothing was consumed.
   */
  G(t) {
    if (!t.sticky)
      throw new Error('`regex` must have a sticky flag ("y")');
    t.lastIndex = this.i();
    let e = t.exec(this.m);
    if (e === null || e.length === 0)
      return Gr;
    let r = e[0];
    return this.g(this.q(r)), r;
  }
  /**
   * Consumes and returns all characters for which the given function returns a
   * truthy value, stopping on the first falsy return value or if the end of the
   * input is reached.
   */
  v(t) {
    let e, r = Gr;
    for (; (e = this.h()) && t(e); )
      r += e, this.g();
    return r;
  }
  /**
   * Consumes the given string if it exists at the current character index, and
   * advances the scanner.
   *
   * If the given string doesn't exist at the current character index, an empty
   * string will be returned and the scanner will not be advanced.
   */
  Q(t) {
    if (this.b(t))
      return t;
    if (this.n) {
      let { length: e } = t, r = this.q(t);
      if (r !== e && t === this.h(r))
        return this.g(r), t;
    }
    return Gr;
  }
  /**
   * Does the same thing as `consumeString()`, but doesn't support consuming
   * multibyte characters. This can be faster if you only need to match single
   * byte characters.
   */
  b(t) {
    let { length: e } = t;
    return this.h(e) === t ? (this.g(e), t) : Gr;
  }
  /**
   * Consumes characters until the given global regex is matched, advancing the
   * scanner up to (but not beyond) the beginning of the match. If the regex
   * doesn't match, nothing will be consumed.
   *
   * Returns the consumed string, or an empty string if nothing was consumed.
   */
  A(t) {
    let e = this.m.slice(this.i()), r = e.search(t);
    if (r <= 0)
      return Gr;
    let n = e.slice(0, r);
    return this.g(this.q(n)), n;
  }
  /**
   * Consumes characters until the given string is found, advancing the scanner
   * up to (but not beyond) that point. If the string is never found, nothing
   * will be consumed.
   *
   * Returns the consumed string, or an empty string if nothing was consumed.
   */
  t(t) {
    let { m: e } = this, r = this.i(), n = e.indexOf(t, r);
    if (n <= 0)
      return Gr;
    let s = e.slice(r, n);
    return this.g(this.q(s)), s;
  }
  /**
   * Returns the given number of characters starting at the current character
   * index, without advancing the scanner and without exceeding the end of the
   * input string.
   */
  h(t = 1) {
    let { d: e, n: r, m: n } = this;
    return r ? e >= this.k ? Gr : n.slice(
      this.i(e),
      this.i(e + t)
    ) : n.slice(e, e + t);
  }
  /**
   * Resets the scanner position to the given character _index_, or to the start
   * of the input string if no index is given.
   *
   * If _index_ is negative, the scanner position will be moved backward by that
   * many characters, stopping if the beginning of the string is reached.
   */
  o(t = 0) {
    this.d = t >= 0 ? Math.min(this.k, t) : Math.max(0, this.d + t);
  }
}, Kb = /[^"&<]+/y, Gb = /[^'&<]+/y, Jb = /\r\n|[\n\r\t]/g, Yb = /<|&|]]>/, Xb = Object.freeze(Object.assign(/* @__PURE__ */ Object.create(null), {
  amp: "&",
  apos: "'",
  gt: ">",
  lt: "<",
  quot: '"'
}));
function yl(t) {
  let e = xo(t);
  return e >= 97 && e <= 122 || e >= 65 && e <= 90 || e >= 48 && e <= 57 || e === 45 || e === 46 || e === 183 || e >= 768 && e <= 879 || e >= 8255 && e <= 8256 || vl(t, e);
}
function vl(t, e = xo(t)) {
  return e >= 97 && e <= 122 || e >= 65 && e <= 90 || e === 58 || e === 95 || e >= 192 && e <= 214 || e >= 216 && e <= 246 || e >= 248 && e <= 767 || e >= 880 && e <= 893 || e >= 895 && e <= 8191 || e >= 8204 && e <= 8205 || e >= 8304 && e <= 8591 || e >= 11264 && e <= 12271 || e >= 12289 && e <= 55295 || e >= 63744 && e <= 64975 || e >= 65008 && e <= 65533 || e >= 65536 && e <= 983039;
}
function Qb(t) {
  return t === "#" || yl(t);
}
function ew(t) {
  let e = xo(t);
  return e === 32 || e === 9 || e === 10 || e === 13;
}
function Ic(t) {
  return t === 9 || t === 10 || t === 13 || t >= 32 && t <= 55295 || t >= 57344 && t <= 65533 || t >= 65536 && t <= 1114111;
}
function xo(t) {
  return t.codePointAt(0) || -1;
}
var bl = class {
  constructor() {
    this.parent = null, this.start = -1, this.end = -1;
  }
  /**
   * Document that contains this node, or `null` if this node is not associated
   * with a document.
   */
  get document() {
    var t, e;
    return (e = (t = this.parent) == null ? void 0 : t.document) != null ? e : null;
  }
  /**
   * Whether this node is the root node of the document (also known as the
   * document element).
   */
  get isRootNode() {
    return this.parent !== null && this.parent === this.document && this.type === bl.TYPE_ELEMENT;
  }
  /**
   * Whether whitespace should be preserved in the content of this element and
   * its children.
   *
   * This is influenced by the value of the special `xml:space` attribute, and
   * will be `true` for any node whose `xml:space` attribute is set to
   * "preserve". If a node has no such attribute, it will inherit the value of
   * the nearest ancestor that does (if any).
   *
   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-white-space
   */
  get preserveWhitespace() {
    var t;
    return !!((t = this.parent) != null && t.preserveWhitespace);
  }
  /**
   * Type of this node.
   *
   * The value of this property is a string that matches one of the static
   * `TYPE_*` properties on the `XmlNode` class (e.g. `TYPE_ELEMENT`,
   * `TYPE_TEXT`, etc.).
   *
   * The `XmlNode` class itself is a base class and doesn't have its own type
   * name.
   */
  get type() {
    return "";
  }
  /**
   * Returns a JSON-serializable object representing this node, minus properties
   * that could result in circular references.
   */
  toJSON() {
    let t = {
      type: this.type
    };
    return this.isRootNode && (t.isRootNode = !0), this.preserveWhitespace && (t.preserveWhitespace = !0), this.start !== -1 && (t.start = this.start, t.end = this.end), t;
  }
}, Ge = bl;
Ge.TYPE_CDATA = "cdata";
Ge.TYPE_COMMENT = "comment";
Ge.TYPE_DOCUMENT = "document";
Ge.TYPE_DOCUMENT_TYPE = "doctype";
Ge.TYPE_ELEMENT = "element";
Ge.TYPE_PROCESSING_INSTRUCTION = "pi";
Ge.TYPE_TEXT = "text";
Ge.TYPE_XML_DECLARATION = "xmldecl";
var Mo = class extends Ge {
  constructor(t = "") {
    super(), this.text = t;
  }
  get type() {
    return Ge.TYPE_TEXT;
  }
  toJSON() {
    return Object.assign(Ge.prototype.toJSON.call(this), {
      text: this.text
    });
  }
}, wl = class extends Mo {
  get type() {
    return Ge.TYPE_CDATA;
  }
}, _l = class extends Ge {
  constructor(t = "") {
    super(), this.content = t;
  }
  get type() {
    return Ge.TYPE_COMMENT;
  }
  toJSON() {
    return Object.assign(Ge.prototype.toJSON.call(this), {
      content: this.content
    });
  }
}, El = class extends Ge {
  constructor(t, e, r) {
    super(), this.version = t, this.encoding = e ?? null, this.standalone = r ?? null;
  }
  get type() {
    return Ge.TYPE_XML_DECLARATION;
  }
  toJSON() {
    let t = Ge.prototype.toJSON.call(this);
    t.version = this.version;
    for (let e of ["encoding", "standalone"])
      this[e] !== null && (t[e] = this[e]);
    return t;
  }
}, Ui = class extends Ge {
  constructor(t, e = /* @__PURE__ */ Object.create(null), r = []) {
    super(), this.name = t, this.attributes = e, this.children = r;
  }
  /**
   * Whether this element is empty (meaning it has no children).
   */
  get isEmpty() {
    return this.children.length === 0;
  }
  get preserveWhitespace() {
    let t = this;
    for (; t instanceof Ui; ) {
      if ("xml:space" in t.attributes)
        return t.attributes["xml:space"] === "preserve";
      t = t.parent;
    }
    return !1;
  }
  /**
   * Text content of this element and all its descendants.
   */
  get text() {
    return this.children.map((t) => "text" in t ? t.text : "").join("");
  }
  get type() {
    return Ge.TYPE_ELEMENT;
  }
  toJSON() {
    return Object.assign(Ge.prototype.toJSON.call(this), {
      name: this.name,
      attributes: this.attributes,
      children: this.children.map((t) => t.toJSON())
    });
  }
}, Sl = class extends Ge {
  constructor(t = []) {
    super(), this.children = t;
  }
  get document() {
    return this;
  }
  /**
   * Root element of this document, or `null` if this document is empty.
   */
  get root() {
    for (let t of this.children)
      if (t instanceof Ui)
        return t;
    return null;
  }
  /**
   * Text content of this document and all its descendants.
   */
  get text() {
    return this.children.map((t) => "text" in t ? t.text : "").join("");
  }
  get type() {
    return Ge.TYPE_DOCUMENT;
  }
  toJSON() {
    return Object.assign(Ge.prototype.toJSON.call(this), {
      children: this.children.map((t) => t.toJSON())
    });
  }
}, $l = class extends Ge {
  constructor(t, e, r, n) {
    super(), this.name = t, this.publicId = e ?? null, this.systemId = r ?? null, this.internalSubset = n ?? null;
  }
  get type() {
    return Ge.TYPE_DOCUMENT_TYPE;
  }
  toJSON() {
    let t = Ge.prototype.toJSON.call(this);
    t.name = this.name;
    for (let e of ["publicId", "systemId", "internalSubset"])
      this[e] !== null && (t[e] = this[e]);
    return t;
  }
}, kl = class extends Error {
  constructor(t, e, r) {
    let n = 1, s = "", i = 1;
    for (let c = 0; c < e; ++c) {
      let l = r[c];
      l === `
` ? (n = 1, s = "", i += 1) : (n += 1, s += l);
    }
    let a = r.indexOf(`
`, e);
    s += a === -1 ? r.slice(e) : r.slice(e, a);
    let o = 0;
    s.length > 50 && (n < 40 ? s = s.slice(0, 50) : (o = n - 20, s = s.slice(o, n + 30))), super(
      `${t} (line ${i}, column ${n})
  ${s}
` + " ".repeat(n - o + 1) + `^
`
    ), this.column = n, this.excerpt = s, this.line = i, this.name = "XmlError", this.pos = e;
  }
}, Oa = class extends Ge {
  constructor(t, e = "") {
    super(), this.name = t, this.content = e;
  }
  get type() {
    return Ge.TYPE_PROCESSING_INSTRUCTION;
  }
  toJSON() {
    return Object.assign(Ge.prototype.toJSON.call(this), {
      name: this.name,
      content: this.content
    });
  }
}, ta = "", tw = class {
  /**
   * @param xml XML string to parse.
   * @param options Parser options.
   */
  constructor(t, e = {}) {
    let r = this.document = new Sl(), n = this.c = new Zb(t);
    if (this.l = r, this.f = e, this.f.includeOffsets && (r.start = 0, r.end = t.length), n.b("\uFEFF"), this.H(), !this.B())
      throw this.a("Root element is missing or invalid");
    for (; this.w(); )
      ;
    if (!n.z)
      throw this.a("Extra content at the end of the document");
  }
  /**
   * Adds the given `XmlNode` as a child of `this.currentNode`.
   */
  j(t, e) {
    return t.parent = this.l, this.f.includeOffsets && (t.start = this.c.i(e), t.end = this.c.i()), this.l.children.push(t), !0;
  }
  /**
   * Adds the given _text_ to the document, either by appending it to a
   * preceding `XmlText` node (if possible) or by creating a new `XmlText` node.
   */
  x(t, e) {
    let { children: r } = this.l, { length: n } = r;
    if (t = zs(t), n > 0) {
      let s = r[n - 1];
      if (s?.type === Ge.TYPE_TEXT) {
        let i = s;
        return i.text += t, this.f.includeOffsets && (i.end = this.c.i()), !0;
      }
    }
    return this.j(new Mo(t), e);
  }
  /**
   * Consumes element attributes.
   *
   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-starttags
   */
  I() {
    let t = /* @__PURE__ */ Object.create(null);
    for (; this.e(); ) {
      let e = this.r();
      if (!e)
        break;
      let r = this.u() && this.J();
      if (r === !1)
        throw this.a("Attribute value expected");
      if (e in t)
        throw this.a(`Duplicate attribute: ${e}`);
      if (e === "xml:space" && r !== "default" && r !== "preserve")
        throw this.a('Value of the `xml:space` attribute must be "default" or "preserve"');
      t[e] = r;
    }
    if (this.f.sortAttributes) {
      let e = Object.keys(t).sort(), r = /* @__PURE__ */ Object.create(null);
      for (let n = 0; n < e.length; ++n) {
        let s = e[n];
        r[s] = t[s];
      }
      t = r;
    }
    return t;
  }
  /**
   * Consumes an `AttValue` (attribute value) if possible.
   *
   * @returns
   *   Contents of the `AttValue` minus quotes, or `false` if nothing was
   *   consumed. An empty string indicates that an `AttValue` was consumed but
   *   was empty.
   *
   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue
   */
  J() {
    let { c: t } = this, e = t.h();
    if (e !== '"' && e !== "'")
      return !1;
    t.g();
    let r, n = !1, s = ta, i = e === '"' ? Kb : Gb;
    e:
      for (; !t.z; )
        switch (r = t.G(i), r && (this.p(r), s += r.replace(Jb, " ")), t.h()) {
          case e:
            n = !0;
            break e;
          case "&":
            s += this.C();
            continue;
          case "<":
            throw this.a("Unescaped `<` is not allowed in an attribute value");
          case ta:
            break e;
        }
    if (!n)
      throw this.a("Unclosed attribute");
    return t.g(), s;
  }
  /**
   * Consumes a CDATA section if possible.
   *
   * @returns Whether a CDATA section was consumed.
   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-cdata-sect
   */
  K() {
    let { c: t } = this, e = t.d;
    if (!t.b("<![CDATA["))
      return !1;
    let r = t.t("]]>");
    if (this.p(r), !t.b("]]>"))
      throw this.a("Unclosed CDATA section");
    return this.f.preserveCdata ? this.j(new wl(zs(r)), e) : this.x(r, e);
  }
  /**
   * Consumes character data if possible.
   *
   * @returns Whether character data was consumed.
   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#dt-chardata
   */
  L() {
    let { c: t } = this, e = t.d, r = t.A(Yb);
    if (!r)
      return !1;
    if (this.p(r), t.h(3) === "]]>")
      throw this.a("Element content may not contain the CDATA section close delimiter `]]>`");
    return this.x(r, e);
  }
  /**
   * Consumes a comment if possible.
   *
   * @returns Whether a comment was consumed.
   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Comment
   */
  D() {
    let { c: t } = this, e = t.d;
    if (!t.b("<!--"))
      return !1;
    let r = t.t("--");
    if (this.p(r), !t.b("-->"))
      throw t.h(2) === "--" ? this.a("The string `--` isn't allowed inside a comment") : this.a("Unclosed comment");
    return this.f.preserveComments ? this.j(new _l(zs(r)), e) : !0;
  }
  /**
   * Consumes a reference in a content context if possible.
   *
   * This differs from `consumeReference()` in that a consumed reference will be
   * added to the document as a text node instead of returned.
   *
   * @returns Whether a reference was consumed.
   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#entproc
   */
  M() {
    let t = this.c.d, e = this.C();
    return e ? this.x(e, t) : !1;
  }
  /**
   * Consumes a doctype declaration if possible.
   *
   * This is a loose implementation since doctype declarations are currently
   * discarded without further parsing.
   *
   * @returns Whether a doctype declaration was consumed.
   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#dtd
   */
  N() {
    let { c: t } = this, e = t.d;
    if (!t.b("<!DOCTYPE"))
      return !1;
    let r = this.e() && this.r();
    if (!r)
      throw this.a("Expected a name");
    let n, s;
    if (this.e()) {
      if (t.b("PUBLIC")) {
        if (n = this.e() && this.O(), n === !1)
          throw this.a("Expected a public identifier");
        this.e();
      }
      if (n !== void 0 || t.b("SYSTEM")) {
        if (this.e(), s = this.s(), s === !1)
          throw this.a("Expected a system identifier");
        this.e();
      }
    }
    let i;
    if (t.b("[")) {
      if (i = t.A(/\][\x20\t\r\n]*>/), !t.b("]"))
        throw this.a("Unclosed internal subset");
      this.e();
    }
    if (!t.b(">"))
      throw this.a("Unclosed doctype declaration");
    return this.f.preserveDocumentType ? this.j(new $l(r, n, s, i), e) : !0;
  }
  /**
   * Consumes an element if possible.
   *
   * @returns Whether an element was consumed.
   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-element
   */
  B() {
    let { c: t } = this, e = t.d;
    if (!t.b("<"))
      return !1;
    let r = this.r();
    if (!r)
      return t.o(e), !1;
    let n = this.I(), s = !!t.b("/>"), i = new Ui(r, n);
    if (i.parent = this.l, !s) {
      if (!t.b(">"))
        throw this.a(`Unclosed start tag for element \`${r}\``);
      this.l = i;
      do
        this.L();
      while (this.B() || this.M() || this.K() || this.E() || this.D());
      let a = t.d, o;
      if (!t.b("</") || !(o = this.r()) || o !== r)
        throw t.o(a), this.a(`Missing end tag for element ${r}`);
      if (this.e(), !t.b(">"))
        throw this.a(`Unclosed end tag for element ${r}`);
      this.l = i.parent;
    }
    return this.j(i, e);
  }
  /**
   * Consumes an `Eq` production if possible.
   *
   * @returns Whether an `Eq` production was consumed.
   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Eq
   */
  u() {
    return this.e(), this.c.b("=") ? (this.e(), !0) : !1;
  }
  /**
   * Consumes `Misc` content if possible.
   *
   * @returns Whether anything was consumed.
   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Misc
   */
  w() {
    return this.D() || this.E() || this.e();
  }
  /**
   * Consumes one or more `Name` characters if possible.
   *
   * @returns `Name` characters, or an empty string if none were consumed.
   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Name
   */
  r() {
    return vl(this.c.h()) ? this.c.v(yl) : ta;
  }
  /**
   * Consumes a processing instruction if possible.
   *
   * @returns Whether a processing instruction was consumed.
   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-pi
   */
  E() {
    let { c: t } = this, e = t.d;
    if (!t.b("<?"))
      return !1;
    let r = this.r();
    if (r) {
      if (r.toLowerCase() === "xml")
        throw t.o(e), this.a("XML declaration isn't allowed here");
    } else
      throw this.a("Invalid processing instruction");
    if (!this.e()) {
      if (t.b("?>"))
        return this.j(new Oa(r), e);
      throw this.a("Whitespace is required after a processing instruction name");
    }
    let n = t.t("?>");
    if (this.p(n), !t.b("?>"))
      throw this.a("Unterminated processing instruction");
    return this.j(new Oa(r, zs(n)), e);
  }
  /**
   * Consumes a prolog if possible.
   *
   * @returns Whether a prolog was consumed.
   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-prolog-dtd
   */
  H() {
    let { c: t } = this, e = t.d;
    for (this.P(); this.w(); )
      ;
    if (this.N())
      for (; this.w(); )
        ;
    return e < t.d;
  }
  /**
   * Consumes a public identifier literal if possible.
   *
   * @returns
   *   Value of the public identifier literal minus quotes, or `false` if
   *   nothing was consumed. An empty string indicates that a public id literal
   *   was consumed but was empty.
   *
   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-PubidLiteral
   */
  O() {
    let t = this.c.d, e = this.s();
    if (e !== !1 && !/^[-\x20\r\na-zA-Z0-9'()+,./:=?;!*#@$_%]*$/.test(e))
      throw this.c.o(t), this.a("Invalid character in public identifier");
    return e;
  }
  /**
   * Consumes a reference if possible.
   *
   * This differs from `consumeContentReference()` in that a consumed reference
   * will be returned rather than added to the document.
   *
   * @returns
   *   Parsed reference value, or `false` if nothing was consumed (to
   *   distinguish from a reference that resolves to an empty string).
   *
   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Reference
   */
  C() {
    let { c: t } = this;
    if (!t.b("&"))
      return !1;
    let e = t.v(Qb);
    if (t.F() !== ";")
      throw this.a("Unterminated reference (a reference must end with `;`)");
    let r;
    if (e[0] === "#") {
      let n = e[1] === "x" ? parseInt(e.slice(2), 16) : parseInt(e.slice(1), 10);
      if (isNaN(n))
        throw this.a("Invalid character reference");
      if (!Ic(n))
        throw this.a("Character reference resolves to an invalid character");
      r = String.fromCodePoint(n);
    } else if (r = Xb[e], r === void 0) {
      let {
        ignoreUndefinedEntities: n,
        resolveUndefinedEntity: s
      } = this.f, i = `&${e};`;
      if (s) {
        let a = s(i);
        if (a != null) {
          let o = typeof a;
          if (o !== "string")
            throw new TypeError(`\`resolveUndefinedEntity()\` must return a string, \`null\`, or \`undefined\`, but returned a value of type ${o}`);
          return a;
        }
      }
      if (n)
        return i;
      throw t.o(-i.length), this.a(`Named entity isn't defined: ${i}`);
    }
    return r;
  }
  /**
   * Consumes a `SystemLiteral` if possible.
   *
   * A `SystemLiteral` is similar to an attribute value, but allows the
   * characters `<` and `&` and doesn't replace references.
   *
   * @returns
   *   Value of the `SystemLiteral` minus quotes, or `false` if nothing was
   *   consumed. An empty string indicates that a `SystemLiteral` was consumed
   *   but was empty.
   *
   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-SystemLiteral
   */
  s() {
    let { c: t } = this, e = t.b('"') || t.b("'");
    if (!e)
      return !1;
    let r = t.t(e);
    if (this.p(r), !t.b(e))
      throw this.a("Missing end quote");
    return r;
  }
  /**
   * Consumes one or more whitespace characters if possible.
   *
   * @returns Whether any whitespace characters were consumed.
   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#white
   */
  e() {
    return !!this.c.v(ew);
  }
  /**
   * Consumes an XML declaration if possible.
   *
   * @returns Whether an XML declaration was consumed.
   * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-XMLDecl
   */
  P() {
    let { c: t } = this, e = t.d;
    if (!t.b("<?xml"))
      return !1;
    if (!this.e())
      throw this.a("Invalid XML declaration");
    let r = !!t.b("version") && this.u() && this.s();
    if (r === !1)
      throw this.a("XML version is missing or invalid");
    if (!/^1\.[0-9]+$/.test(r))
      throw this.a("Invalid character in version number");
    let n, s;
    if (this.e() && (n = !!t.b("encoding") && this.u() && this.s(), n && this.e(), s = !!t.b("standalone") && this.u() && this.s(), s)) {
      if (s !== "yes" && s !== "no")
        throw this.a('Only "yes" and "no" are permitted as values of `standalone`');
      this.e();
    }
    if (!t.b("?>"))
      throw this.a("Invalid or unclosed XML declaration");
    return this.f.preserveXmlDeclaration ? this.j(new El(
      r,
      n || void 0,
      s || void 0
    ), e) : !0;
  }
  /**
   * Returns an `XmlError` for the current scanner position.
   */
  a(t) {
    let { c: e } = this;
    return new kl(t, e.d, e.m);
  }
  /**
   * Throws an invalid character error if any character in the given _string_
   * isn't a valid XML character.
   */
  p(t) {
    let { length: e } = t;
    for (let r = 0; r < e; ++r) {
      let n = t.codePointAt(r);
      if (!Ic(n))
        throw this.c.o(-([...t].length - r)), this.a("Invalid character");
      n > 65535 && (r += 1);
    }
  }
};
function zs(t) {
  let e = 0;
  for (; (e = t.indexOf("\r", e)) !== -1; )
    t = t[e + 1] === `
` ? t.slice(0, e) + t.slice(e + 1) : t.slice(0, e) + `
` + t.slice(e + 1);
  return t;
}
function rw(t, e) {
  return new tw(t, e).document;
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const nw = (t) => t.replace(/:/g, "$"), Aa = (t) => {
  if (t.type === "document") {
    const r = t.children.find((i) => i.type === "element"), [n, s] = Aa(r);
    return ["$doc", r ? { [n]: s } : ""];
  }
  if (t.type === "element") {
    const e = t, r = e.children.map(Aa), n = Object.fromEntries(r.reduce((s, [i, a]) => (s.has(i) ? s.get(i).push(a) : s.set(i, [a]), s), /* @__PURE__ */ new Map()));
    return [nw(e.name), { ...n, ...e.attributes }];
  }
  return t.type === "text" ? ["$t", t.text] : ["$c", ""];
}, sw = {
  describe: async () => ({
    inputSchema: {
      properties: {
        xml: {
          title: "XML",
          description: "Valid XML as a string"
        }
      }
    },
    outputSchema: {
      properties: {
        json: {
          title: "JSON",
          description: "JSON representation of the input XML. Represented as alt-json, described in https://developers.google.com/gdata/docs/json"
        }
      }
    }
  }),
  invoke: async (t) => {
    const { xml: e } = t;
    if (!e)
      throw new Error("XmlToJson requires `xml` input");
    return { json: Aa(Wb.parseXml(e)) };
  }
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Is = new gr({
  title: "JSON Kit",
  description: "A Breadboard Kit containing nodes that facilitate wrangling JSON objects",
  version: "0.0.1",
  url: "npm:@google-labs/json-kit"
}).build({
  validateJson: Cb,
  schemish: Rb,
  jsonata: Lb,
  xmlToJson: sw
}), Tn = xn(Is);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const iw = (t) => typeof t == "string" ? t : t === void 0 ? "undefined" : JSON.stringify(t, null, 2), aw = (t, e) => Object.entries(e).reduce((r, [n, s]) => r.replace(`{{${n}}}`, iw(s)), t), Tl = (t) => {
  const e = t.matchAll(/{{(?<name>[\w-]+)}}/g), r = Array.from(e).map((s) => s.groups?.name || "");
  return Array.from(new Set(r));
}, ow = async (t) => {
  const e = t.template, r = Tl(e);
  if (!r.length)
    return { prompt: e, text: e };
  const n = r.reduce((i, a) => {
    if (t[a] === void 0)
      throw new Error(`Input is missing parameter "${a}"`);
    return { ...i, [a]: t[a] };
  }, {}), s = aw(e, n);
  return { prompt: s, text: s };
}, cw = (t) => {
  const e = Tl(t.template ?? ""), r = e.reduce((n, s) => {
    const i = {
      title: s,
      description: `The value to substitute for the parameter "${s}"`,
      type: ["string", "object"]
    };
    return { ...n, [s]: i };
  }, {});
  return r.template = {
    title: "template",
    description: "The template with placeholders to fill in.",
    type: "string"
  }, {
    type: "object",
    properties: r,
    required: ["template", ...e]
  };
}, uw = async (t) => ({
  inputSchema: cw(t || {}),
  outputSchema: {
    type: "object",
    properties: {
      text: {
        title: "prompt",
        description: "The resulting prompt that was produced by filling in the placeholders in the template.",
        type: "string"
      }
    },
    required: ["text"]
  }
}), lw = {
  describe: uw,
  invoke: ow
};
function Pl(t) {
  return t.split(/(%[0-9A-Fa-f]{2})/g).map(function(e) {
    return /%[0-9A-Fa-f]/.test(e) || (e = encodeURI(e).replace(/%5B/g, "[").replace(/%5D/g, "]")), e;
  }).join("");
}
function wn(t) {
  return encodeURIComponent(t).replace(/[!'()*]/g, function(e) {
    return "%" + e.charCodeAt(0).toString(16).toUpperCase();
  });
}
function Hn(t, e, r) {
  return e = t === "+" || t === "#" ? Pl(e) : wn(e), r ? wn(r) + "=" + e : e;
}
function gn(t) {
  return t != null;
}
function ra(t) {
  return t === ";" || t === "&" || t === "?";
}
function dw(t, e, r, n) {
  var s = t[r], i = [];
  if (gn(s) && s !== "")
    if (typeof s == "string" || typeof s == "number" || typeof s == "boolean")
      s = s.toString(), n && n !== "*" && (s = s.substring(0, parseInt(n, 10))), i.push(Hn(e, s, ra(e) ? r : null));
    else if (n === "*")
      Array.isArray(s) ? s.filter(gn).forEach(function(o) {
        i.push(Hn(e, o, ra(e) ? r : null));
      }) : Object.keys(s).forEach(function(o) {
        gn(s[o]) && i.push(Hn(e, s[o], o));
      });
    else {
      var a = [];
      Array.isArray(s) ? s.filter(gn).forEach(function(o) {
        a.push(Hn(e, o));
      }) : Object.keys(s).forEach(function(o) {
        gn(s[o]) && (a.push(wn(o)), a.push(Hn(e, s[o].toString())));
      }), ra(e) ? i.push(wn(r) + "=" + a.join(",")) : a.length !== 0 && i.push(a.join(","));
    }
  else
    e === ";" ? gn(s) && i.push(wn(r)) : s === "" && (e === "&" || e === "?") ? i.push(wn(r) + "=") : s === "" && i.push("");
  return i;
}
function fw(t) {
  var e = ["+", "#", ".", "/", ";", "?", "&"];
  return {
    expand: function(r) {
      return t.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(n, s, i) {
        if (s) {
          var a = null, o = [];
          if (e.indexOf(s.charAt(0)) !== -1 && (a = s.charAt(0), s = s.substr(1)), s.split(/,/g).forEach(function(l) {
            var f = /([^:\*]*)(?::(\d+)|(\*))?/.exec(l);
            o.push.apply(o, dw(r, a, f[1], f[2] || f[3]));
          }), a && a !== "+") {
            var c = ",";
            return a === "?" ? c = "&" : a !== "#" && (c = a), (o.length !== 0 ? a : "") + o.join(c);
          } else
            return o.join(",");
        } else
          return Pl(i);
      });
    }
  };
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const hw = async (t) => {
  const { template: e, ...r } = t;
  return { url: fw(e).expand(r) };
}, pw = [
  { prefix: "+", description: "reserved expansion" },
  { prefix: "#", description: "fragment expansion" },
  { prefix: ".", description: "label expansion, dot-prefixed" },
  { prefix: "/", description: "path segment expansion" },
  { prefix: ";", description: "path-style parameter expansion" },
  { prefix: "?", description: "form-style query expansion" },
  { prefix: "&", description: "form-style query continuation" }
], mw = (t) => t ? [...t.matchAll(/{([^{}]+)\}|([^{}]+)/g)].map((r) => r[1]).filter(Boolean).map((r) => {
  const n = r.charAt(0), s = pw.find((i) => i.prefix === n);
  return s ? { name: r.slice(1), operator: s } : { name: r };
}) : [], gw = (t) => {
  const e = mw(t);
  return {
    type: "object",
    properties: e.reduce((n, { name: s, operator: i }) => {
      const a = i?.description ? `Value for ${i.description} placeholder "${s}"` : `Value for placeholder "${s}"`;
      return n[s] = {
        title: s,
        description: a,
        type: "string"
      }, n;
    }, {
      template: {
        title: "template",
        description: "The URL template to use",
        type: "string"
      }
    }),
    required: ["template", ...e.map(({ name: n }) => n)]
  };
}, yw = async (t) => {
  const { template: e } = t || {};
  return {
    inputSchema: gw(e),
    outputSchema: {
      type: "object",
      properties: {
        url: {
          title: "url",
          description: "The resulting URL that was produced by filling in the placeholders in the template",
          type: "string"
        }
      },
      required: ["url"]
    }
  };
}, vw = {
  describe: yw,
  invoke: hw
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const bw = new gr({
  title: "Template Kit",
  description: "A kit that contains nodes for various sorts of templating.",
  version: "0.0.1",
  url: "npm:@google-labs/template-kit"
}), Fi = bw.build({
  promptTemplate: lw,
  urlTemplate: vw
}), Il = xn(Fi);
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ol = function(t) {
  const e = [];
  let r = 0;
  for (let n = 0; n < t.length; n++) {
    let s = t.charCodeAt(n);
    s < 128 ? e[r++] = s : s < 2048 ? (e[r++] = s >> 6 | 192, e[r++] = s & 63 | 128) : (s & 64512) === 55296 && n + 1 < t.length && (t.charCodeAt(n + 1) & 64512) === 56320 ? (s = 65536 + ((s & 1023) << 10) + (t.charCodeAt(++n) & 1023), e[r++] = s >> 18 | 240, e[r++] = s >> 12 & 63 | 128, e[r++] = s >> 6 & 63 | 128, e[r++] = s & 63 | 128) : (e[r++] = s >> 12 | 224, e[r++] = s >> 6 & 63 | 128, e[r++] = s & 63 | 128);
  }
  return e;
}, ww = function(t) {
  const e = [];
  let r = 0, n = 0;
  for (; r < t.length; ) {
    const s = t[r++];
    if (s < 128)
      e[n++] = String.fromCharCode(s);
    else if (s > 191 && s < 224) {
      const i = t[r++];
      e[n++] = String.fromCharCode((s & 31) << 6 | i & 63);
    } else if (s > 239 && s < 365) {
      const i = t[r++], a = t[r++], o = t[r++], c = ((s & 7) << 18 | (i & 63) << 12 | (a & 63) << 6 | o & 63) - 65536;
      e[n++] = String.fromCharCode(55296 + (c >> 10)), e[n++] = String.fromCharCode(56320 + (c & 1023));
    } else {
      const i = t[r++], a = t[r++];
      e[n++] = String.fromCharCode((s & 15) << 12 | (i & 63) << 6 | a & 63);
    }
  }
  return e.join("");
}, Al = {
  /**
   * Maps bytes to characters.
   */
  byteToCharMap_: null,
  /**
   * Maps characters to bytes.
   */
  charToByteMap_: null,
  /**
   * Maps bytes to websafe characters.
   * @private
   */
  byteToCharMapWebSafe_: null,
  /**
   * Maps websafe characters to bytes.
   * @private
   */
  charToByteMapWebSafe_: null,
  /**
   * Our default alphabet, shared between
   * ENCODED_VALS and ENCODED_VALS_WEBSAFE
   */
  ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
  /**
   * Our default alphabet. Value 64 (=) is special; it means "nothing."
   */
  get ENCODED_VALS() {
    return this.ENCODED_VALS_BASE + "+/=";
  },
  /**
   * Our websafe alphabet.
   */
  get ENCODED_VALS_WEBSAFE() {
    return this.ENCODED_VALS_BASE + "-_.";
  },
  /**
   * Whether this browser supports the atob and btoa functions. This extension
   * started at Mozilla but is now implemented by many browsers. We use the
   * ASSUME_* variables to avoid pulling in the full useragent detection library
   * but still allowing the standard per-browser compilations.
   *
   */
  HAS_NATIVE_SUPPORT: typeof atob == "function",
  /**
   * Base64-encode an array of bytes.
   *
   * @param input An array of bytes (numbers with
   *     value in [0, 255]) to encode.
   * @param webSafe Boolean indicating we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeByteArray(t, e) {
    if (!Array.isArray(t))
      throw Error("encodeByteArray takes an array as a parameter");
    this.init_();
    const r = e ? this.byteToCharMapWebSafe_ : this.byteToCharMap_, n = [];
    for (let s = 0; s < t.length; s += 3) {
      const i = t[s], a = s + 1 < t.length, o = a ? t[s + 1] : 0, c = s + 2 < t.length, l = c ? t[s + 2] : 0, f = i >> 2, h = (i & 3) << 4 | o >> 4;
      let y = (o & 15) << 2 | l >> 6, S = l & 63;
      c || (S = 64, a || (y = 64)), n.push(r[f], r[h], r[y], r[S]);
    }
    return n.join("");
  },
  /**
   * Base64-encode a string.
   *
   * @param input A string to encode.
   * @param webSafe If true, we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeString(t, e) {
    return this.HAS_NATIVE_SUPPORT && !e ? btoa(t) : this.encodeByteArray(Ol(t), e);
  },
  /**
   * Base64-decode a string.
   *
   * @param input to decode.
   * @param webSafe True if we should use the
   *     alternative alphabet.
   * @return string representing the decoded value.
   */
  decodeString(t, e) {
    return this.HAS_NATIVE_SUPPORT && !e ? atob(t) : ww(this.decodeStringToByteArray(t, e));
  },
  /**
   * Base64-decode a string.
   *
   * In base-64 decoding, groups of four characters are converted into three
   * bytes.  If the encoder did not apply padding, the input length may not
   * be a multiple of 4.
   *
   * In this case, the last group will have fewer than 4 characters, and
   * padding will be inferred.  If the group has one or two characters, it decodes
   * to one byte.  If the group has three characters, it decodes to two bytes.
   *
   * @param input Input to decode.
   * @param webSafe True if we should use the web-safe alphabet.
   * @return bytes representing the decoded value.
   */
  decodeStringToByteArray(t, e) {
    this.init_();
    const r = e ? this.charToByteMapWebSafe_ : this.charToByteMap_, n = [];
    for (let s = 0; s < t.length; ) {
      const i = r[t.charAt(s++)], o = s < t.length ? r[t.charAt(s)] : 0;
      ++s;
      const l = s < t.length ? r[t.charAt(s)] : 64;
      ++s;
      const h = s < t.length ? r[t.charAt(s)] : 64;
      if (++s, i == null || o == null || l == null || h == null)
        throw new _w();
      const y = i << 2 | o >> 4;
      if (n.push(y), l !== 64) {
        const S = o << 4 & 240 | l >> 2;
        if (n.push(S), h !== 64) {
          const E = l << 6 & 192 | h;
          n.push(E);
        }
      }
    }
    return n;
  },
  /**
   * Lazy static initialization function. Called before
   * accessing any of the static map variables.
   * @private
   */
  init_() {
    if (!this.byteToCharMap_) {
      this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {};
      for (let t = 0; t < this.ENCODED_VALS.length; t++)
        this.byteToCharMap_[t] = this.ENCODED_VALS.charAt(t), this.charToByteMap_[this.byteToCharMap_[t]] = t, this.byteToCharMapWebSafe_[t] = this.ENCODED_VALS_WEBSAFE.charAt(t), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[t]] = t, t >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(t)] = t, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(t)] = t);
    }
  }
};
let _w = class extends Error {
  constructor() {
    super(...arguments), this.name = "DecodeBase64StringError";
  }
};
const Ew = function(t) {
  const e = Ol(t);
  return Al.encodeByteArray(e, !0);
}, Nl = function(t) {
  return Ew(t).replace(/\./g, "");
}, Sw = function(t) {
  try {
    return Al.decodeString(t, !0);
  } catch (e) {
    console.error("base64Decode failed: ", e);
  }
  return null;
};
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function $w() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  throw new Error("Unable to locate global object.");
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const kw = () => $w().__FIREBASE_DEFAULTS__, Tw = () => {
  if (typeof process > "u" || typeof process.env > "u")
    return;
  const t = process.env.__FIREBASE_DEFAULTS__;
  if (t)
    return JSON.parse(t);
}, Pw = () => {
  if (typeof document > "u")
    return;
  let t;
  try {
    t = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
  } catch {
    return;
  }
  const e = t && Sw(t[1]);
  return e && JSON.parse(e);
}, Iw = () => {
  try {
    return kw() || Tw() || Pw();
  } catch (t) {
    console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${t}`);
    return;
  }
}, Cl = () => {
  var t;
  return (t = Iw()) === null || t === void 0 ? void 0 : t.config;
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ow {
  constructor() {
    this.reject = () => {
    }, this.resolve = () => {
    }, this.promise = new Promise((e, r) => {
      this.resolve = e, this.reject = r;
    });
  }
  /**
   * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around
   * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
   * and returns a node-style callback which will resolve or reject the Deferred's promise.
   */
  wrapCallback(e) {
    return (r, n) => {
      r ? this.reject(r) : this.resolve(n), typeof e == "function" && (this.promise.catch(() => {
      }), e.length === 1 ? e(r) : e(r, n));
    };
  }
}
function Aw() {
  try {
    return typeof indexedDB == "object";
  } catch {
    return !1;
  }
}
function Nw() {
  return new Promise((t, e) => {
    try {
      let r = !0;
      const n = "validate-browser-context-for-indexeddb-analytics-module", s = self.indexedDB.open(n);
      s.onsuccess = () => {
        s.result.close(), r || self.indexedDB.deleteDatabase(n), t(!0);
      }, s.onupgradeneeded = () => {
        r = !1;
      }, s.onerror = () => {
        var i;
        e(((i = s.error) === null || i === void 0 ? void 0 : i.message) || "");
      };
    } catch (r) {
      e(r);
    }
  });
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Cw = "FirebaseError";
let jo = class Rl extends Error {
  constructor(e, r, n) {
    super(r), this.code = e, this.customData = n, this.name = Cw, Object.setPrototypeOf(this, Rl.prototype), Error.captureStackTrace && Error.captureStackTrace(this, Dl.prototype.create);
  }
}, Dl = class {
  constructor(e, r, n) {
    this.service = e, this.serviceName = r, this.errors = n;
  }
  create(e, ...r) {
    const n = r[0] || {}, s = `${this.service}/${e}`, i = this.errors[e], a = i ? Rw(i, n) : "Error", o = `${this.serviceName}: ${a} (${s}).`;
    return new jo(s, o, n);
  }
};
function Rw(t, e) {
  return t.replace(Dw, (r, n) => {
    const s = e[n];
    return s != null ? String(s) : `<${n}?>`;
  });
}
const Dw = /\{\$([^}]+)}/g;
function Na(t, e) {
  if (t === e)
    return !0;
  const r = Object.keys(t), n = Object.keys(e);
  for (const s of r) {
    if (!n.includes(s))
      return !1;
    const i = t[s], a = e[s];
    if (Oc(i) && Oc(a)) {
      if (!Na(i, a))
        return !1;
    } else if (i !== a)
      return !1;
  }
  for (const s of n)
    if (!r.includes(s))
      return !1;
  return !0;
}
function Oc(t) {
  return t !== null && typeof t == "object";
}
let $i = class {
  /**
   *
   * @param name The public service name, e.g. app, auth, firestore, database
   * @param instanceFactory Service factory responsible for creating the public interface
   * @param type whether the service provided by the component is public or private
   */
  constructor(e, r, n) {
    this.name = e, this.instanceFactory = r, this.type = n, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null;
  }
  setInstantiationMode(e) {
    return this.instantiationMode = e, this;
  }
  setMultipleInstances(e) {
    return this.multipleInstances = e, this;
  }
  setServiceProps(e) {
    return this.serviceProps = e, this;
  }
  setInstanceCreatedCallback(e) {
    return this.onInstanceCreated = e, this;
  }
};
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Jr = "[DEFAULT]";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class xw {
  constructor(e, r) {
    this.name = e, this.container = r, this.component = null, this.instances = /* @__PURE__ */ new Map(), this.instancesDeferred = /* @__PURE__ */ new Map(), this.instancesOptions = /* @__PURE__ */ new Map(), this.onInitCallbacks = /* @__PURE__ */ new Map();
  }
  /**
   * @param identifier A provider can provide mulitple instances of a service
   * if this.component.multipleInstances is true.
   */
  get(e) {
    const r = this.normalizeInstanceIdentifier(e);
    if (!this.instancesDeferred.has(r)) {
      const n = new Ow();
      if (this.instancesDeferred.set(r, n), this.isInitialized(r) || this.shouldAutoInitialize())
        try {
          const s = this.getOrInitializeService({
            instanceIdentifier: r
          });
          s && n.resolve(s);
        } catch {
        }
    }
    return this.instancesDeferred.get(r).promise;
  }
  getImmediate(e) {
    var r;
    const n = this.normalizeInstanceIdentifier(e?.identifier), s = (r = e?.optional) !== null && r !== void 0 ? r : !1;
    if (this.isInitialized(n) || this.shouldAutoInitialize())
      try {
        return this.getOrInitializeService({
          instanceIdentifier: n
        });
      } catch (i) {
        if (s)
          return null;
        throw i;
      }
    else {
      if (s)
        return null;
      throw Error(`Service ${this.name} is not available`);
    }
  }
  getComponent() {
    return this.component;
  }
  setComponent(e) {
    if (e.name !== this.name)
      throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);
    if (this.component)
      throw Error(`Component for ${this.name} has already been provided`);
    if (this.component = e, !!this.shouldAutoInitialize()) {
      if (jw(e))
        try {
          this.getOrInitializeService({ instanceIdentifier: Jr });
        } catch {
        }
      for (const [r, n] of this.instancesDeferred.entries()) {
        const s = this.normalizeInstanceIdentifier(r);
        try {
          const i = this.getOrInitializeService({
            instanceIdentifier: s
          });
          n.resolve(i);
        } catch {
        }
      }
    }
  }
  clearInstance(e = Jr) {
    this.instancesDeferred.delete(e), this.instancesOptions.delete(e), this.instances.delete(e);
  }
  // app.delete() will call this method on every provider to delete the services
  // TODO: should we mark the provider as deleted?
  async delete() {
    const e = Array.from(this.instances.values());
    await Promise.all([
      ...e.filter((r) => "INTERNAL" in r).map((r) => r.INTERNAL.delete()),
      ...e.filter((r) => "_delete" in r).map((r) => r._delete())
    ]);
  }
  isComponentSet() {
    return this.component != null;
  }
  isInitialized(e = Jr) {
    return this.instances.has(e);
  }
  getOptions(e = Jr) {
    return this.instancesOptions.get(e) || {};
  }
  initialize(e = {}) {
    const { options: r = {} } = e, n = this.normalizeInstanceIdentifier(e.instanceIdentifier);
    if (this.isInitialized(n))
      throw Error(`${this.name}(${n}) has already been initialized`);
    if (!this.isComponentSet())
      throw Error(`Component ${this.name} has not been registered yet`);
    const s = this.getOrInitializeService({
      instanceIdentifier: n,
      options: r
    });
    for (const [i, a] of this.instancesDeferred.entries()) {
      const o = this.normalizeInstanceIdentifier(i);
      n === o && a.resolve(s);
    }
    return s;
  }
  /**
   *
   * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
   * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
   *
   * @param identifier An optional instance identifier
   * @returns a function to unregister the callback
   */
  onInit(e, r) {
    var n;
    const s = this.normalizeInstanceIdentifier(r), i = (n = this.onInitCallbacks.get(s)) !== null && n !== void 0 ? n : /* @__PURE__ */ new Set();
    i.add(e), this.onInitCallbacks.set(s, i);
    const a = this.instances.get(s);
    return a && e(a, s), () => {
      i.delete(e);
    };
  }
  /**
   * Invoke onInit callbacks synchronously
   * @param instance the service instance`
   */
  invokeOnInitCallbacks(e, r) {
    const n = this.onInitCallbacks.get(r);
    if (n)
      for (const s of n)
        try {
          s(e, r);
        } catch {
        }
  }
  getOrInitializeService({ instanceIdentifier: e, options: r = {} }) {
    let n = this.instances.get(e);
    if (!n && this.component && (n = this.component.instanceFactory(this.container, {
      instanceIdentifier: Mw(e),
      options: r
    }), this.instances.set(e, n), this.instancesOptions.set(e, r), this.invokeOnInitCallbacks(n, e), this.component.onInstanceCreated))
      try {
        this.component.onInstanceCreated(this.container, e, n);
      } catch {
      }
    return n || null;
  }
  normalizeInstanceIdentifier(e = Jr) {
    return this.component ? this.component.multipleInstances ? e : Jr : e;
  }
  shouldAutoInitialize() {
    return !!this.component && this.component.instantiationMode !== "EXPLICIT";
  }
}
function Mw(t) {
  return t === Jr ? void 0 : t;
}
function jw(t) {
  return t.instantiationMode === "EAGER";
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Lw {
  constructor(e) {
    this.name = e, this.providers = /* @__PURE__ */ new Map();
  }
  /**
   *
   * @param component Component being added
   * @param overwrite When a component with the same name has already been registered,
   * if overwrite is true: overwrite the existing component with the new component and create a new
   * provider with the new component. It can be useful in tests where you want to use different mocks
   * for different tests.
   * if overwrite is false: throw an exception
   */
  addComponent(e) {
    const r = this.getProvider(e.name);
    if (r.isComponentSet())
      throw new Error(`Component ${e.name} has already been registered with ${this.name}`);
    r.setComponent(e);
  }
  addOrOverwriteComponent(e) {
    this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name), this.addComponent(e);
  }
  /**
   * getProvider provides a type safe interface where it can only be called with a field name
   * present in NameServiceMapping interface.
   *
   * Firebase SDKs providing services should extend NameServiceMapping interface to register
   * themselves.
   */
  getProvider(e) {
    if (this.providers.has(e))
      return this.providers.get(e);
    const r = new xw(e, this);
    return this.providers.set(e, r), r;
  }
  getProviders() {
    return Array.from(this.providers.values());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var it;
(function(t) {
  t[t.DEBUG = 0] = "DEBUG", t[t.VERBOSE = 1] = "VERBOSE", t[t.INFO = 2] = "INFO", t[t.WARN = 3] = "WARN", t[t.ERROR = 4] = "ERROR", t[t.SILENT = 5] = "SILENT";
})(it || (it = {}));
const Uw = {
  debug: it.DEBUG,
  verbose: it.VERBOSE,
  info: it.INFO,
  warn: it.WARN,
  error: it.ERROR,
  silent: it.SILENT
}, Fw = it.INFO, Vw = {
  [it.DEBUG]: "log",
  [it.VERBOSE]: "log",
  [it.INFO]: "info",
  [it.WARN]: "warn",
  [it.ERROR]: "error"
}, qw = (t, e, ...r) => {
  if (e < t.logLevel)
    return;
  const n = (/* @__PURE__ */ new Date()).toISOString(), s = Vw[e];
  if (s)
    console[s](`[${n}]  ${t.name}:`, ...r);
  else
    throw new Error(`Attempted to log a message with an invalid logType (value: ${e})`);
};
class xl {
  /**
   * Gives you an instance of a Logger to capture messages according to
   * Firebase's logging scheme.
   *
   * @param name The name that the logs will be associated with
   */
  constructor(e) {
    this.name = e, this._logLevel = Fw, this._logHandler = qw, this._userLogHandler = null;
  }
  get logLevel() {
    return this._logLevel;
  }
  set logLevel(e) {
    if (!(e in it))
      throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);
    this._logLevel = e;
  }
  // Workaround for setter/getter having to be the same type.
  setLogLevel(e) {
    this._logLevel = typeof e == "string" ? Uw[e] : e;
  }
  get logHandler() {
    return this._logHandler;
  }
  set logHandler(e) {
    if (typeof e != "function")
      throw new TypeError("Value assigned to `logHandler` must be a function");
    this._logHandler = e;
  }
  get userLogHandler() {
    return this._userLogHandler;
  }
  set userLogHandler(e) {
    this._userLogHandler = e;
  }
  /**
   * The functions below are all based on the `console` interface
   */
  debug(...e) {
    this._userLogHandler && this._userLogHandler(this, it.DEBUG, ...e), this._logHandler(this, it.DEBUG, ...e);
  }
  log(...e) {
    this._userLogHandler && this._userLogHandler(this, it.VERBOSE, ...e), this._logHandler(this, it.VERBOSE, ...e);
  }
  info(...e) {
    this._userLogHandler && this._userLogHandler(this, it.INFO, ...e), this._logHandler(this, it.INFO, ...e);
  }
  warn(...e) {
    this._userLogHandler && this._userLogHandler(this, it.WARN, ...e), this._logHandler(this, it.WARN, ...e);
  }
  error(...e) {
    this._userLogHandler && this._userLogHandler(this, it.ERROR, ...e), this._logHandler(this, it.ERROR, ...e);
  }
}
const Bw = (t, e) => e.some((r) => t instanceof r);
let Ac, Nc;
function zw() {
  return Ac || (Ac = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function Ww() {
  return Nc || (Nc = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const Ml = /* @__PURE__ */ new WeakMap(), Ca = /* @__PURE__ */ new WeakMap(), jl = /* @__PURE__ */ new WeakMap(), na = /* @__PURE__ */ new WeakMap(), Lo = /* @__PURE__ */ new WeakMap();
function Hw(t) {
  const e = new Promise((r, n) => {
    const s = () => {
      t.removeEventListener("success", i), t.removeEventListener("error", a);
    }, i = () => {
      r(qr(t.result)), s();
    }, a = () => {
      n(t.error), s();
    };
    t.addEventListener("success", i), t.addEventListener("error", a);
  });
  return e.then((r) => {
    r instanceof IDBCursor && Ml.set(r, t);
  }).catch(() => {
  }), Lo.set(e, t), e;
}
function Zw(t) {
  if (Ca.has(t))
    return;
  const e = new Promise((r, n) => {
    const s = () => {
      t.removeEventListener("complete", i), t.removeEventListener("error", a), t.removeEventListener("abort", a);
    }, i = () => {
      r(), s();
    }, a = () => {
      n(t.error || new DOMException("AbortError", "AbortError")), s();
    };
    t.addEventListener("complete", i), t.addEventListener("error", a), t.addEventListener("abort", a);
  });
  Ca.set(t, e);
}
let Ra = {
  get(t, e, r) {
    if (t instanceof IDBTransaction) {
      if (e === "done")
        return Ca.get(t);
      if (e === "objectStoreNames")
        return t.objectStoreNames || jl.get(t);
      if (e === "store")
        return r.objectStoreNames[1] ? void 0 : r.objectStore(r.objectStoreNames[0]);
    }
    return qr(t[e]);
  },
  set(t, e, r) {
    return t[e] = r, !0;
  },
  has(t, e) {
    return t instanceof IDBTransaction && (e === "done" || e === "store") ? !0 : e in t;
  }
};
function Kw(t) {
  Ra = t(Ra);
}
function Gw(t) {
  return t === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(e, ...r) {
    const n = t.call(sa(this), e, ...r);
    return jl.set(n, e.sort ? e.sort() : [e]), qr(n);
  } : Ww().includes(t) ? function(...e) {
    return t.apply(sa(this), e), qr(Ml.get(this));
  } : function(...e) {
    return qr(t.apply(sa(this), e));
  };
}
function Jw(t) {
  return typeof t == "function" ? Gw(t) : (t instanceof IDBTransaction && Zw(t), Bw(t, zw()) ? new Proxy(t, Ra) : t);
}
function qr(t) {
  if (t instanceof IDBRequest)
    return Hw(t);
  if (na.has(t))
    return na.get(t);
  const e = Jw(t);
  return e !== t && (na.set(t, e), Lo.set(e, t)), e;
}
const sa = (t) => Lo.get(t);
function Yw(t, e, { blocked: r, upgrade: n, blocking: s, terminated: i } = {}) {
  const a = indexedDB.open(t, e), o = qr(a);
  return n && a.addEventListener("upgradeneeded", (c) => {
    n(qr(a.result), c.oldVersion, c.newVersion, qr(a.transaction), c);
  }), r && a.addEventListener("blocked", (c) => r(
    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
    c.oldVersion,
    c.newVersion,
    c
  )), o.then((c) => {
    i && c.addEventListener("close", () => i()), s && c.addEventListener("versionchange", (l) => s(l.oldVersion, l.newVersion, l));
  }).catch(() => {
  }), o;
}
const Xw = ["get", "getKey", "getAll", "getAllKeys", "count"], Qw = ["put", "add", "delete", "clear"], ia = /* @__PURE__ */ new Map();
function Cc(t, e) {
  if (!(t instanceof IDBDatabase && !(e in t) && typeof e == "string"))
    return;
  if (ia.get(e))
    return ia.get(e);
  const r = e.replace(/FromIndex$/, ""), n = e !== r, s = Qw.includes(r);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(r in (n ? IDBIndex : IDBObjectStore).prototype) || !(s || Xw.includes(r))
  )
    return;
  const i = async function(a, ...o) {
    const c = this.transaction(a, s ? "readwrite" : "readonly");
    let l = c.store;
    return n && (l = l.index(o.shift())), (await Promise.all([
      l[r](...o),
      s && c.done
    ]))[0];
  };
  return ia.set(e, i), i;
}
Kw((t) => ({
  ...t,
  get: (e, r, n) => Cc(e, r) || t.get(e, r, n),
  has: (e, r) => !!Cc(e, r) || t.has(e, r)
}));
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class e_ {
  constructor(e) {
    this.container = e;
  }
  // In initial implementation, this will be called by installations on
  // auth token refresh, and installations will send this string.
  getPlatformInfoString() {
    return this.container.getProviders().map((r) => {
      if (t_(r)) {
        const n = r.getImmediate();
        return `${n.library}/${n.version}`;
      } else
        return null;
    }).filter((r) => r).join(" ");
  }
}
function t_(t) {
  const e = t.getComponent();
  return e?.type === "VERSION";
}
const Da = "@firebase/app", Rc = "0.9.27";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const dn = new xl("@firebase/app"), r_ = "@firebase/app-compat", n_ = "@firebase/analytics-compat", s_ = "@firebase/analytics", i_ = "@firebase/app-check-compat", a_ = "@firebase/app-check", o_ = "@firebase/auth", c_ = "@firebase/auth-compat", u_ = "@firebase/database", l_ = "@firebase/database-compat", d_ = "@firebase/functions", f_ = "@firebase/functions-compat", h_ = "@firebase/installations", p_ = "@firebase/installations-compat", m_ = "@firebase/messaging", g_ = "@firebase/messaging-compat", y_ = "@firebase/performance", v_ = "@firebase/performance-compat", b_ = "@firebase/remote-config", w_ = "@firebase/remote-config-compat", __ = "@firebase/storage", E_ = "@firebase/storage-compat", S_ = "@firebase/firestore", $_ = "@firebase/firestore-compat", k_ = "firebase", T_ = "10.8.0";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const xa = "[DEFAULT]", P_ = {
  [Da]: "fire-core",
  [r_]: "fire-core-compat",
  [s_]: "fire-analytics",
  [n_]: "fire-analytics-compat",
  [a_]: "fire-app-check",
  [i_]: "fire-app-check-compat",
  [o_]: "fire-auth",
  [c_]: "fire-auth-compat",
  [u_]: "fire-rtdb",
  [l_]: "fire-rtdb-compat",
  [d_]: "fire-fn",
  [f_]: "fire-fn-compat",
  [h_]: "fire-iid",
  [p_]: "fire-iid-compat",
  [m_]: "fire-fcm",
  [g_]: "fire-fcm-compat",
  [y_]: "fire-perf",
  [v_]: "fire-perf-compat",
  [b_]: "fire-rc",
  [w_]: "fire-rc-compat",
  [__]: "fire-gcs",
  [E_]: "fire-gcs-compat",
  [S_]: "fire-fst",
  [$_]: "fire-fst-compat",
  "fire-js": "fire-js",
  [k_]: "fire-js-all"
};
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ki = /* @__PURE__ */ new Map(), Ma = /* @__PURE__ */ new Map();
function I_(t, e) {
  try {
    t.container.addComponent(e);
  } catch (r) {
    dn.debug(`Component ${e.name} failed to register with FirebaseApp ${t.name}`, r);
  }
}
function ms(t) {
  const e = t.name;
  if (Ma.has(e))
    return dn.debug(`There were multiple attempts to register component ${e}.`), !1;
  Ma.set(e, t);
  for (const r of ki.values())
    I_(r, t);
  return !0;
}
function Ll(t, e) {
  const r = t.container.getProvider("heartbeat").getImmediate({ optional: !0 });
  return r && r.triggerHeartbeat(), t.container.getProvider(e);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const O_ = {
  "no-app": "No Firebase App '{$appName}' has been created - call initializeApp() first",
  "bad-app-name": "Illegal App name: '{$appName}",
  "duplicate-app": "Firebase App named '{$appName}' already exists with different options or config",
  "app-deleted": "Firebase App named '{$appName}' already deleted",
  "no-options": "Need to provide options, when not being deployed to hosting via source.",
  "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.",
  "invalid-log-argument": "First argument to `onLog` must be null or a function.",
  "idb-open": "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
  "idb-get": "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
  "idb-set": "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
  "idb-delete": "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}."
}, Br = new Dl("app", "Firebase", O_);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class A_ {
  constructor(e, r, n) {
    this._isDeleted = !1, this._options = Object.assign({}, e), this._config = Object.assign({}, r), this._name = r.name, this._automaticDataCollectionEnabled = r.automaticDataCollectionEnabled, this._container = n, this.container.addComponent(new $i(
      "app",
      () => this,
      "PUBLIC"
      /* ComponentType.PUBLIC */
    ));
  }
  get automaticDataCollectionEnabled() {
    return this.checkDestroyed(), this._automaticDataCollectionEnabled;
  }
  set automaticDataCollectionEnabled(e) {
    this.checkDestroyed(), this._automaticDataCollectionEnabled = e;
  }
  get name() {
    return this.checkDestroyed(), this._name;
  }
  get options() {
    return this.checkDestroyed(), this._options;
  }
  get config() {
    return this.checkDestroyed(), this._config;
  }
  get container() {
    return this._container;
  }
  get isDeleted() {
    return this._isDeleted;
  }
  set isDeleted(e) {
    this._isDeleted = e;
  }
  /**
   * This function will throw an Error if the App has already been deleted -
   * use before performing API actions on the App.
   */
  checkDestroyed() {
    if (this.isDeleted)
      throw Br.create("app-deleted", { appName: this._name });
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Os = T_;
function Ul(t, e = {}) {
  let r = t;
  typeof e != "object" && (e = { name: e });
  const n = Object.assign({ name: xa, automaticDataCollectionEnabled: !1 }, e), s = n.name;
  if (typeof s != "string" || !s)
    throw Br.create("bad-app-name", {
      appName: String(s)
    });
  if (r || (r = Cl()), !r)
    throw Br.create(
      "no-options"
      /* AppError.NO_OPTIONS */
    );
  const i = ki.get(s);
  if (i) {
    if (Na(r, i.options) && Na(n, i.config))
      return i;
    throw Br.create("duplicate-app", { appName: s });
  }
  const a = new Lw(s);
  for (const c of Ma.values())
    a.addComponent(c);
  const o = new A_(r, n, a);
  return ki.set(s, o), o;
}
function N_(t = xa) {
  const e = ki.get(t);
  if (!e && t === xa && Cl())
    return Ul();
  if (!e)
    throw Br.create("no-app", { appName: t });
  return e;
}
function Pn(t, e, r) {
  var n;
  let s = (n = P_[t]) !== null && n !== void 0 ? n : t;
  r && (s += `-${r}`);
  const i = s.match(/\s|\//), a = e.match(/\s|\//);
  if (i || a) {
    const o = [
      `Unable to register library "${s}" with version "${e}":`
    ];
    i && o.push(`library name "${s}" contains illegal characters (whitespace or "/")`), i && a && o.push("and"), a && o.push(`version name "${e}" contains illegal characters (whitespace or "/")`), dn.warn(o.join(" "));
    return;
  }
  ms(new $i(
    `${s}-version`,
    () => ({ library: s, version: e }),
    "VERSION"
    /* ComponentType.VERSION */
  ));
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const C_ = "firebase-heartbeat-database", R_ = 1, gs = "firebase-heartbeat-store";
let aa = null;
function Fl() {
  return aa || (aa = Yw(C_, R_, {
    upgrade: (t, e) => {
      switch (e) {
        case 0:
          try {
            t.createObjectStore(gs);
          } catch (r) {
            console.warn(r);
          }
      }
    }
  }).catch((t) => {
    throw Br.create("idb-open", {
      originalErrorMessage: t.message
    });
  })), aa;
}
async function D_(t) {
  try {
    const r = (await Fl()).transaction(gs), n = await r.objectStore(gs).get(Vl(t));
    return await r.done, n;
  } catch (e) {
    if (e instanceof jo)
      dn.warn(e.message);
    else {
      const r = Br.create("idb-get", {
        originalErrorMessage: e?.message
      });
      dn.warn(r.message);
    }
  }
}
async function Dc(t, e) {
  try {
    const n = (await Fl()).transaction(gs, "readwrite");
    await n.objectStore(gs).put(e, Vl(t)), await n.done;
  } catch (r) {
    if (r instanceof jo)
      dn.warn(r.message);
    else {
      const n = Br.create("idb-set", {
        originalErrorMessage: r?.message
      });
      dn.warn(n.message);
    }
  }
}
function Vl(t) {
  return `${t.name}!${t.options.appId}`;
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const x_ = 1024, M_ = 30 * 24 * 60 * 60 * 1e3;
class j_ {
  constructor(e) {
    this.container = e, this._heartbeatsCache = null;
    const r = this.container.getProvider("app").getImmediate();
    this._storage = new U_(r), this._heartbeatsCachePromise = this._storage.read().then((n) => (this._heartbeatsCache = n, n));
  }
  /**
   * Called to report a heartbeat. The function will generate
   * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it
   * to IndexedDB.
   * Note that we only store one heartbeat per day. So if a heartbeat for today is
   * already logged, subsequent calls to this function in the same day will be ignored.
   */
  async triggerHeartbeat() {
    var e, r;
    const s = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(), i = xc();
    if (!(((e = this._heartbeatsCache) === null || e === void 0 ? void 0 : e.heartbeats) == null && (this._heartbeatsCache = await this._heartbeatsCachePromise, ((r = this._heartbeatsCache) === null || r === void 0 ? void 0 : r.heartbeats) == null)) && !(this._heartbeatsCache.lastSentHeartbeatDate === i || this._heartbeatsCache.heartbeats.some((a) => a.date === i)))
      return this._heartbeatsCache.heartbeats.push({ date: i, agent: s }), this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((a) => {
        const o = new Date(a.date).valueOf();
        return Date.now() - o <= M_;
      }), this._storage.overwrite(this._heartbeatsCache);
  }
  /**
   * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.
   * It also clears all heartbeats from memory as well as in IndexedDB.
   *
   * NOTE: Consuming product SDKs should not send the header if this method
   * returns an empty string.
   */
  async getHeartbeatsHeader() {
    var e;
    if (this._heartbeatsCache === null && await this._heartbeatsCachePromise, ((e = this._heartbeatsCache) === null || e === void 0 ? void 0 : e.heartbeats) == null || this._heartbeatsCache.heartbeats.length === 0)
      return "";
    const r = xc(), { heartbeatsToSend: n, unsentEntries: s } = L_(this._heartbeatsCache.heartbeats), i = Nl(JSON.stringify({ version: 2, heartbeats: n }));
    return this._heartbeatsCache.lastSentHeartbeatDate = r, s.length > 0 ? (this._heartbeatsCache.heartbeats = s, await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [], this._storage.overwrite(this._heartbeatsCache)), i;
  }
}
function xc() {
  return (/* @__PURE__ */ new Date()).toISOString().substring(0, 10);
}
function L_(t, e = x_) {
  const r = [];
  let n = t.slice();
  for (const s of t) {
    const i = r.find((a) => a.agent === s.agent);
    if (i) {
      if (i.dates.push(s.date), Mc(r) > e) {
        i.dates.pop();
        break;
      }
    } else if (r.push({
      agent: s.agent,
      dates: [s.date]
    }), Mc(r) > e) {
      r.pop();
      break;
    }
    n = n.slice(1);
  }
  return {
    heartbeatsToSend: r,
    unsentEntries: n
  };
}
class U_ {
  constructor(e) {
    this.app = e, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
  }
  async runIndexedDBEnvironmentCheck() {
    return Aw() ? Nw().then(() => !0).catch(() => !1) : !1;
  }
  /**
   * Read all heartbeats.
   */
  async read() {
    if (await this._canUseIndexedDBPromise) {
      const r = await D_(this.app);
      return r?.heartbeats ? r : { heartbeats: [] };
    } else
      return { heartbeats: [] };
  }
  // overwrite the storage with the provided heartbeats
  async overwrite(e) {
    var r;
    if (await this._canUseIndexedDBPromise) {
      const s = await this.read();
      return Dc(this.app, {
        lastSentHeartbeatDate: (r = e.lastSentHeartbeatDate) !== null && r !== void 0 ? r : s.lastSentHeartbeatDate,
        heartbeats: e.heartbeats
      });
    } else
      return;
  }
  // add heartbeats
  async add(e) {
    var r;
    if (await this._canUseIndexedDBPromise) {
      const s = await this.read();
      return Dc(this.app, {
        lastSentHeartbeatDate: (r = e.lastSentHeartbeatDate) !== null && r !== void 0 ? r : s.lastSentHeartbeatDate,
        heartbeats: [
          ...s.heartbeats,
          ...e.heartbeats
        ]
      });
    } else
      return;
  }
}
function Mc(t) {
  return Nl(
    // heartbeatsCache wrapper properties
    JSON.stringify({ version: 2, heartbeats: t })
  ).length;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function F_(t) {
  ms(new $i(
    "platform-logger",
    (e) => new e_(e),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  )), ms(new $i(
    "heartbeat",
    (e) => new j_(e),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  )), Pn(Da, Rc, t), Pn(Da, Rc, "esm2017"), Pn("fire-js", "");
}
F_("");
var V_ = "firebase", q_ = "10.8.0";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Pn(V_, q_, "app");
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const B_ = function(t) {
  const e = [];
  let r = 0;
  for (let n = 0; n < t.length; n++) {
    let s = t.charCodeAt(n);
    s < 128 ? e[r++] = s : s < 2048 ? (e[r++] = s >> 6 | 192, e[r++] = s & 63 | 128) : (s & 64512) === 55296 && n + 1 < t.length && (t.charCodeAt(n + 1) & 64512) === 56320 ? (s = 65536 + ((s & 1023) << 10) + (t.charCodeAt(++n) & 1023), e[r++] = s >> 18 | 240, e[r++] = s >> 12 & 63 | 128, e[r++] = s >> 6 & 63 | 128, e[r++] = s & 63 | 128) : (e[r++] = s >> 12 | 224, e[r++] = s >> 6 & 63 | 128, e[r++] = s & 63 | 128);
  }
  return e;
}, z_ = function(t) {
  const e = [];
  let r = 0, n = 0;
  for (; r < t.length; ) {
    const s = t[r++];
    if (s < 128)
      e[n++] = String.fromCharCode(s);
    else if (s > 191 && s < 224) {
      const i = t[r++];
      e[n++] = String.fromCharCode((s & 31) << 6 | i & 63);
    } else if (s > 239 && s < 365) {
      const i = t[r++], a = t[r++], o = t[r++], c = ((s & 7) << 18 | (i & 63) << 12 | (a & 63) << 6 | o & 63) - 65536;
      e[n++] = String.fromCharCode(55296 + (c >> 10)), e[n++] = String.fromCharCode(56320 + (c & 1023));
    } else {
      const i = t[r++], a = t[r++];
      e[n++] = String.fromCharCode((s & 15) << 12 | (i & 63) << 6 | a & 63);
    }
  }
  return e.join("");
}, W_ = {
  /**
   * Maps bytes to characters.
   */
  byteToCharMap_: null,
  /**
   * Maps characters to bytes.
   */
  charToByteMap_: null,
  /**
   * Maps bytes to websafe characters.
   * @private
   */
  byteToCharMapWebSafe_: null,
  /**
   * Maps websafe characters to bytes.
   * @private
   */
  charToByteMapWebSafe_: null,
  /**
   * Our default alphabet, shared between
   * ENCODED_VALS and ENCODED_VALS_WEBSAFE
   */
  ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
  /**
   * Our default alphabet. Value 64 (=) is special; it means "nothing."
   */
  get ENCODED_VALS() {
    return this.ENCODED_VALS_BASE + "+/=";
  },
  /**
   * Our websafe alphabet.
   */
  get ENCODED_VALS_WEBSAFE() {
    return this.ENCODED_VALS_BASE + "-_.";
  },
  /**
   * Whether this browser supports the atob and btoa functions. This extension
   * started at Mozilla but is now implemented by many browsers. We use the
   * ASSUME_* variables to avoid pulling in the full useragent detection library
   * but still allowing the standard per-browser compilations.
   *
   */
  HAS_NATIVE_SUPPORT: typeof atob == "function",
  /**
   * Base64-encode an array of bytes.
   *
   * @param input An array of bytes (numbers with
   *     value in [0, 255]) to encode.
   * @param webSafe Boolean indicating we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeByteArray(t, e) {
    if (!Array.isArray(t))
      throw Error("encodeByteArray takes an array as a parameter");
    this.init_();
    const r = e ? this.byteToCharMapWebSafe_ : this.byteToCharMap_, n = [];
    for (let s = 0; s < t.length; s += 3) {
      const i = t[s], a = s + 1 < t.length, o = a ? t[s + 1] : 0, c = s + 2 < t.length, l = c ? t[s + 2] : 0, f = i >> 2, h = (i & 3) << 4 | o >> 4;
      let y = (o & 15) << 2 | l >> 6, S = l & 63;
      c || (S = 64, a || (y = 64)), n.push(r[f], r[h], r[y], r[S]);
    }
    return n.join("");
  },
  /**
   * Base64-encode a string.
   *
   * @param input A string to encode.
   * @param webSafe If true, we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeString(t, e) {
    return this.HAS_NATIVE_SUPPORT && !e ? btoa(t) : this.encodeByteArray(B_(t), e);
  },
  /**
   * Base64-decode a string.
   *
   * @param input to decode.
   * @param webSafe True if we should use the
   *     alternative alphabet.
   * @return string representing the decoded value.
   */
  decodeString(t, e) {
    return this.HAS_NATIVE_SUPPORT && !e ? atob(t) : z_(this.decodeStringToByteArray(t, e));
  },
  /**
   * Base64-decode a string.
   *
   * In base-64 decoding, groups of four characters are converted into three
   * bytes.  If the encoder did not apply padding, the input length may not
   * be a multiple of 4.
   *
   * In this case, the last group will have fewer than 4 characters, and
   * padding will be inferred.  If the group has one or two characters, it decodes
   * to one byte.  If the group has three characters, it decodes to two bytes.
   *
   * @param input Input to decode.
   * @param webSafe True if we should use the web-safe alphabet.
   * @return bytes representing the decoded value.
   */
  decodeStringToByteArray(t, e) {
    this.init_();
    const r = e ? this.charToByteMapWebSafe_ : this.charToByteMap_, n = [];
    for (let s = 0; s < t.length; ) {
      const i = r[t.charAt(s++)], o = s < t.length ? r[t.charAt(s)] : 0;
      ++s;
      const l = s < t.length ? r[t.charAt(s)] : 64;
      ++s;
      const h = s < t.length ? r[t.charAt(s)] : 64;
      if (++s, i == null || o == null || l == null || h == null)
        throw new H_();
      const y = i << 2 | o >> 4;
      if (n.push(y), l !== 64) {
        const S = o << 4 & 240 | l >> 2;
        if (n.push(S), h !== 64) {
          const E = l << 6 & 192 | h;
          n.push(E);
        }
      }
    }
    return n;
  },
  /**
   * Lazy static initialization function. Called before
   * accessing any of the static map variables.
   * @private
   */
  init_() {
    if (!this.byteToCharMap_) {
      this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {};
      for (let t = 0; t < this.ENCODED_VALS.length; t++)
        this.byteToCharMap_[t] = this.ENCODED_VALS.charAt(t), this.charToByteMap_[this.byteToCharMap_[t]] = t, this.byteToCharMapWebSafe_[t] = this.ENCODED_VALS_WEBSAFE.charAt(t), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[t]] = t, t >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(t)] = t, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(t)] = t);
    }
  }
};
class H_ extends Error {
  constructor() {
    super(...arguments), this.name = "DecodeBase64StringError";
  }
}
const ql = function(t) {
  try {
    return W_.decodeString(t, !0);
  } catch (e) {
    console.error("base64Decode failed: ", e);
  }
  return null;
};
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Z_() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  throw new Error("Unable to locate global object.");
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const K_ = () => Z_().__FIREBASE_DEFAULTS__, G_ = () => {
  if (typeof process > "u" || typeof process.env > "u")
    return;
  const t = process.env.__FIREBASE_DEFAULTS__;
  if (t)
    return JSON.parse(t);
}, J_ = () => {
  if (typeof document > "u")
    return;
  let t;
  try {
    t = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
  } catch {
    return;
  }
  const e = t && ql(t[1]);
  return e && JSON.parse(e);
}, Bl = () => {
  try {
    return K_() || G_() || J_();
  } catch (t) {
    console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${t}`);
    return;
  }
}, Y_ = (t) => {
  var e, r;
  return (r = (e = Bl()) === null || e === void 0 ? void 0 : e.emulatorHosts) === null || r === void 0 ? void 0 : r[t];
}, zl = (t) => {
  var e;
  return (e = Bl()) === null || e === void 0 ? void 0 : e[`_${t}`];
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Ct() {
  return typeof navigator < "u" && typeof navigator.userAgent == "string" ? navigator.userAgent : "";
}
function X_() {
  return typeof window < "u" && // @ts-ignore Setting up an broadly applicable index signature for Window
  // just to deal with this case would probably be a bad idea.
  !!(window.cordova || window.phonegap || window.PhoneGap) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(Ct());
}
function Q_() {
  const t = typeof chrome == "object" ? chrome.runtime : typeof browser == "object" ? browser.runtime : void 0;
  return typeof t == "object" && t.id !== void 0;
}
function e0() {
  return typeof navigator == "object" && navigator.product === "ReactNative";
}
function t0() {
  const t = Ct();
  return t.indexOf("MSIE ") >= 0 || t.indexOf("Trident/") >= 0;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const r0 = "FirebaseError";
class Ln extends Error {
  constructor(e, r, n) {
    super(r), this.code = e, this.customData = n, this.name = r0, Object.setPrototypeOf(this, Ln.prototype), Error.captureStackTrace && Error.captureStackTrace(this, Vi.prototype.create);
  }
}
class Vi {
  constructor(e, r, n) {
    this.service = e, this.serviceName = r, this.errors = n;
  }
  create(e, ...r) {
    const n = r[0] || {}, s = `${this.service}/${e}`, i = this.errors[e], a = i ? n0(i, n) : "Error", o = `${this.serviceName}: ${a} (${s}).`;
    return new Ln(s, o, n);
  }
}
function n0(t, e) {
  return t.replace(s0, (r, n) => {
    const s = e[n];
    return s != null ? String(s) : `<${n}?>`;
  });
}
const s0 = /\{\$([^}]+)}/g;
function i0(t) {
  for (const e in t)
    if (Object.prototype.hasOwnProperty.call(t, e))
      return !1;
  return !0;
}
function Wl(t, e) {
  if (t === e)
    return !0;
  const r = Object.keys(t), n = Object.keys(e);
  for (const s of r) {
    if (!n.includes(s))
      return !1;
    const i = t[s], a = e[s];
    if (jc(i) && jc(a)) {
      if (!Wl(i, a))
        return !1;
    } else if (i !== a)
      return !1;
  }
  for (const s of n)
    if (!r.includes(s))
      return !1;
  return !0;
}
function jc(t) {
  return t !== null && typeof t == "object";
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function As(t) {
  const e = [];
  for (const [r, n] of Object.entries(t))
    Array.isArray(n) ? n.forEach((s) => {
      e.push(encodeURIComponent(r) + "=" + encodeURIComponent(s));
    }) : e.push(encodeURIComponent(r) + "=" + encodeURIComponent(n));
  return e.length ? "&" + e.join("&") : "";
}
function a0(t, e) {
  const r = new o0(t, e);
  return r.subscribe.bind(r);
}
class o0 {
  /**
   * @param executor Function which can make calls to a single Observer
   *     as a proxy.
   * @param onNoObservers Callback when count of Observers goes to zero.
   */
  constructor(e, r) {
    this.observers = [], this.unsubscribes = [], this.observerCount = 0, this.task = Promise.resolve(), this.finalized = !1, this.onNoObservers = r, this.task.then(() => {
      e(this);
    }).catch((n) => {
      this.error(n);
    });
  }
  next(e) {
    this.forEachObserver((r) => {
      r.next(e);
    });
  }
  error(e) {
    this.forEachObserver((r) => {
      r.error(e);
    }), this.close(e);
  }
  complete() {
    this.forEachObserver((e) => {
      e.complete();
    }), this.close();
  }
  /**
   * Subscribe function that can be used to add an Observer to the fan-out list.
   *
   * - We require that no event is sent to a subscriber sychronously to their
   *   call to subscribe().
   */
  subscribe(e, r, n) {
    let s;
    if (e === void 0 && r === void 0 && n === void 0)
      throw new Error("Missing Observer.");
    c0(e, [
      "next",
      "error",
      "complete"
    ]) ? s = e : s = {
      next: e,
      error: r,
      complete: n
    }, s.next === void 0 && (s.next = oa), s.error === void 0 && (s.error = oa), s.complete === void 0 && (s.complete = oa);
    const i = this.unsubscribeOne.bind(this, this.observers.length);
    return this.finalized && this.task.then(() => {
      try {
        this.finalError ? s.error(this.finalError) : s.complete();
      } catch {
      }
    }), this.observers.push(s), i;
  }
  // Unsubscribe is synchronous - we guarantee that no events are sent to
  // any unsubscribed Observer.
  unsubscribeOne(e) {
    this.observers === void 0 || this.observers[e] === void 0 || (delete this.observers[e], this.observerCount -= 1, this.observerCount === 0 && this.onNoObservers !== void 0 && this.onNoObservers(this));
  }
  forEachObserver(e) {
    if (!this.finalized)
      for (let r = 0; r < this.observers.length; r++)
        this.sendOne(r, e);
  }
  // Call the Observer via one of it's callback function. We are careful to
  // confirm that the observe has not been unsubscribed since this asynchronous
  // function had been queued.
  sendOne(e, r) {
    this.task.then(() => {
      if (this.observers !== void 0 && this.observers[e] !== void 0)
        try {
          r(this.observers[e]);
        } catch (n) {
          typeof console < "u" && console.error && console.error(n);
        }
    });
  }
  close(e) {
    this.finalized || (this.finalized = !0, e !== void 0 && (this.finalError = e), this.task.then(() => {
      this.observers = void 0, this.onNoObservers = void 0;
    }));
  }
}
function c0(t, e) {
  if (typeof t != "object" || t === null)
    return !1;
  for (const r of e)
    if (r in t && typeof t[r] == "function")
      return !0;
  return !1;
}
function oa() {
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Un(t) {
  return t && t._delegate ? t._delegate : t;
}
function Uo(t, e) {
  var r = {};
  for (var n in t)
    Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var s = 0, n = Object.getOwnPropertySymbols(t); s < n.length; s++)
      e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[s]) && (r[n[s]] = t[n[s]]);
  return r;
}
class Lc {
  /**
   *
   * @param name The public service name, e.g. app, auth, firestore, database
   * @param instanceFactory Service factory responsible for creating the public interface
   * @param type whether the service provided by the component is public or private
   */
  constructor(e, r, n) {
    this.name = e, this.instanceFactory = r, this.type = n, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null;
  }
  setInstantiationMode(e) {
    return this.instantiationMode = e, this;
  }
  setMultipleInstances(e) {
    return this.multipleInstances = e, this;
  }
  setServiceProps(e) {
    return this.serviceProps = e, this;
  }
  setInstanceCreatedCallback(e) {
    return this.onInstanceCreated = e, this;
  }
}
function Hl() {
  return {
    "dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."
  };
}
const u0 = Hl, Zl = new Vi("auth", "Firebase", Hl());
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ti = new xl("@firebase/auth");
function l0(t, ...e) {
  Ti.logLevel <= it.WARN && Ti.warn(`Auth (${Os}): ${t}`, ...e);
}
function ei(t, ...e) {
  Ti.logLevel <= it.ERROR && Ti.error(`Auth (${Os}): ${t}`, ...e);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function mr(t, ...e) {
  throw Fo(t, ...e);
}
function dr(t, ...e) {
  return Fo(t, ...e);
}
function Kl(t, e, r) {
  const n = Object.assign(Object.assign({}, u0()), { [e]: r });
  return new Vi("auth", "Firebase", n).create(e, {
    appName: t.name
  });
}
function d0(t, e, r) {
  const n = r;
  if (!(e instanceof n))
    throw n.name !== e.constructor.name && mr(
      t,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    ), Kl(t, "argument-error", `Type of ${e.constructor.name} does not match expected instance.Did you pass a reference from a different Auth SDK?`);
}
function Fo(t, ...e) {
  if (typeof t != "string") {
    const r = e[0], n = [...e.slice(1)];
    return n[0] && (n[0].appName = t.name), t._errorFactory.create(r, ...n);
  }
  return Zl.create(t, ...e);
}
function Ae(t, e, ...r) {
  if (!t)
    throw Fo(e, ...r);
}
function _r(t) {
  const e = "INTERNAL ASSERTION FAILED: " + t;
  throw ei(e), new Error(e);
}
function Pr(t, e) {
  t || _r(e);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ja() {
  var t;
  return typeof self < "u" && ((t = self.location) === null || t === void 0 ? void 0 : t.href) || "";
}
function f0() {
  return Uc() === "http:" || Uc() === "https:";
}
function Uc() {
  var t;
  return typeof self < "u" && ((t = self.location) === null || t === void 0 ? void 0 : t.protocol) || null;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function h0() {
  return typeof navigator < "u" && navigator && "onLine" in navigator && typeof navigator.onLine == "boolean" && // Apply only for traditional web apps and Chrome extensions.
  // This is especially true for Cordova apps which have unreliable
  // navigator.onLine behavior unless cordova-plugin-network-information is
  // installed which overwrites the native navigator.onLine value and
  // defines navigator.connection.
  (f0() || Q_() || "connection" in navigator) ? navigator.onLine : !0;
}
function p0() {
  if (typeof navigator > "u")
    return null;
  const t = navigator;
  return (
    // Most reliable, but only supported in Chrome/Firefox.
    t.languages && t.languages[0] || // Supported in most browsers, but returns the language of the browser
    // UI, not the language set in browser settings.
    t.language || // Couldn't determine language.
    null
  );
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ns {
  constructor(e, r) {
    this.shortDelay = e, this.longDelay = r, Pr(r > e, "Short delay should be less than long delay!"), this.isMobile = X_() || e0();
  }
  get() {
    return h0() ? this.isMobile ? this.longDelay : this.shortDelay : Math.min(5e3, this.shortDelay);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Vo(t, e) {
  Pr(t.emulator, "Emulator should always be set here");
  const { url: r } = t.emulator;
  return e ? `${r}${e.startsWith("/") ? e.slice(1) : e}` : r;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Gl {
  static initialize(e, r, n) {
    this.fetchImpl = e, r && (this.headersImpl = r), n && (this.responseImpl = n);
  }
  static fetch() {
    if (this.fetchImpl)
      return this.fetchImpl;
    if (typeof self < "u" && "fetch" in self)
      return self.fetch;
    if (typeof globalThis < "u" && globalThis.fetch)
      return globalThis.fetch;
    if (typeof fetch < "u")
      return fetch;
    _r("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
  }
  static headers() {
    if (this.headersImpl)
      return this.headersImpl;
    if (typeof self < "u" && "Headers" in self)
      return self.Headers;
    if (typeof globalThis < "u" && globalThis.Headers)
      return globalThis.Headers;
    if (typeof Headers < "u")
      return Headers;
    _r("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
  }
  static response() {
    if (this.responseImpl)
      return this.responseImpl;
    if (typeof self < "u" && "Response" in self)
      return self.Response;
    if (typeof globalThis < "u" && globalThis.Response)
      return globalThis.Response;
    if (typeof Response < "u")
      return Response;
    _r("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const m0 = {
  // Custom token errors.
  CREDENTIAL_MISMATCH: "custom-token-mismatch",
  // This can only happen if the SDK sends a bad request.
  MISSING_CUSTOM_TOKEN: "internal-error",
  // Create Auth URI errors.
  INVALID_IDENTIFIER: "invalid-email",
  // This can only happen if the SDK sends a bad request.
  MISSING_CONTINUE_URI: "internal-error",
  // Sign in with email and password errors (some apply to sign up too).
  INVALID_PASSWORD: "wrong-password",
  // This can only happen if the SDK sends a bad request.
  MISSING_PASSWORD: "missing-password",
  // Thrown if Email Enumeration Protection is enabled in the project and the email or password is
  // invalid.
  INVALID_LOGIN_CREDENTIALS: "invalid-credential",
  // Sign up with email and password errors.
  EMAIL_EXISTS: "email-already-in-use",
  PASSWORD_LOGIN_DISABLED: "operation-not-allowed",
  // Verify assertion for sign in with credential errors:
  INVALID_IDP_RESPONSE: "invalid-credential",
  INVALID_PENDING_TOKEN: "invalid-credential",
  FEDERATED_USER_ID_ALREADY_LINKED: "credential-already-in-use",
  // This can only happen if the SDK sends a bad request.
  MISSING_REQ_TYPE: "internal-error",
  // Send Password reset email errors:
  EMAIL_NOT_FOUND: "user-not-found",
  RESET_PASSWORD_EXCEED_LIMIT: "too-many-requests",
  EXPIRED_OOB_CODE: "expired-action-code",
  INVALID_OOB_CODE: "invalid-action-code",
  // This can only happen if the SDK sends a bad request.
  MISSING_OOB_CODE: "internal-error",
  // Operations that require ID token in request:
  CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "requires-recent-login",
  INVALID_ID_TOKEN: "invalid-user-token",
  TOKEN_EXPIRED: "user-token-expired",
  USER_NOT_FOUND: "user-token-expired",
  // Other errors.
  TOO_MANY_ATTEMPTS_TRY_LATER: "too-many-requests",
  PASSWORD_DOES_NOT_MEET_REQUIREMENTS: "password-does-not-meet-requirements",
  // Phone Auth related errors.
  INVALID_CODE: "invalid-verification-code",
  INVALID_SESSION_INFO: "invalid-verification-id",
  INVALID_TEMPORARY_PROOF: "invalid-credential",
  MISSING_SESSION_INFO: "missing-verification-id",
  SESSION_EXPIRED: "code-expired",
  // Other action code errors when additional settings passed.
  // MISSING_CONTINUE_URI is getting mapped to INTERNAL_ERROR above.
  // This is OK as this error will be caught by client side validation.
  MISSING_ANDROID_PACKAGE_NAME: "missing-android-pkg-name",
  UNAUTHORIZED_DOMAIN: "unauthorized-continue-uri",
  // getProjectConfig errors when clientId is passed.
  INVALID_OAUTH_CLIENT_ID: "invalid-oauth-client-id",
  // User actions (sign-up or deletion) disabled errors.
  ADMIN_ONLY_OPERATION: "admin-restricted-operation",
  // Multi factor related errors.
  INVALID_MFA_PENDING_CREDENTIAL: "invalid-multi-factor-session",
  MFA_ENROLLMENT_NOT_FOUND: "multi-factor-info-not-found",
  MISSING_MFA_ENROLLMENT_ID: "missing-multi-factor-info",
  MISSING_MFA_PENDING_CREDENTIAL: "missing-multi-factor-session",
  SECOND_FACTOR_EXISTS: "second-factor-already-in-use",
  SECOND_FACTOR_LIMIT_EXCEEDED: "maximum-second-factor-count-exceeded",
  // Blocking functions related errors.
  BLOCKING_FUNCTION_ERROR_RESPONSE: "internal-error",
  // Recaptcha related errors.
  RECAPTCHA_NOT_ENABLED: "recaptcha-not-enabled",
  MISSING_RECAPTCHA_TOKEN: "missing-recaptcha-token",
  INVALID_RECAPTCHA_TOKEN: "invalid-recaptcha-token",
  INVALID_RECAPTCHA_ACTION: "invalid-recaptcha-action",
  MISSING_CLIENT_TYPE: "missing-client-type",
  MISSING_RECAPTCHA_VERSION: "missing-recaptcha-version",
  INVALID_RECAPTCHA_VERSION: "invalid-recaptcha-version",
  INVALID_REQ_TYPE: "invalid-req-type"
  /* AuthErrorCode.INVALID_REQ_TYPE */
};
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const g0 = new Ns(3e4, 6e4);
function qo(t, e) {
  return t.tenantId && !e.tenantId ? Object.assign(Object.assign({}, e), { tenantId: t.tenantId }) : e;
}
async function Fn(t, e, r, n, s = {}) {
  return Jl(t, s, async () => {
    let i = {}, a = {};
    n && (e === "GET" ? a = n : i = {
      body: JSON.stringify(n)
    });
    const o = As(Object.assign({ key: t.config.apiKey }, a)).slice(1), c = await t._getAdditionalHeaders();
    return c[
      "Content-Type"
      /* HttpHeader.CONTENT_TYPE */
    ] = "application/json", t.languageCode && (c[
      "X-Firebase-Locale"
      /* HttpHeader.X_FIREBASE_LOCALE */
    ] = t.languageCode), Gl.fetch()(Yl(t, t.config.apiHost, r, o), Object.assign({
      method: e,
      headers: c,
      referrerPolicy: "no-referrer"
    }, i));
  });
}
async function Jl(t, e, r) {
  t._canInitEmulator = !1;
  const n = Object.assign(Object.assign({}, m0), e);
  try {
    const s = new v0(t), i = await Promise.race([
      r(),
      s.promise
    ]);
    s.clearNetworkTimeout();
    const a = await i.json();
    if ("needConfirmation" in a)
      throw Ws(t, "account-exists-with-different-credential", a);
    if (i.ok && !("errorMessage" in a))
      return a;
    {
      const o = i.ok ? a.errorMessage : a.error.message, [c, l] = o.split(" : ");
      if (c === "FEDERATED_USER_ID_ALREADY_LINKED")
        throw Ws(t, "credential-already-in-use", a);
      if (c === "EMAIL_EXISTS")
        throw Ws(t, "email-already-in-use", a);
      if (c === "USER_DISABLED")
        throw Ws(t, "user-disabled", a);
      const f = n[c] || c.toLowerCase().replace(/[_\s]+/g, "-");
      if (l)
        throw Kl(t, f, l);
      mr(t, f);
    }
  } catch (s) {
    if (s instanceof Ln)
      throw s;
    mr(t, "network-request-failed", { message: String(s) });
  }
}
async function y0(t, e, r, n, s = {}) {
  const i = await Fn(t, e, r, n, s);
  return "mfaPendingCredential" in i && mr(t, "multi-factor-auth-required", {
    _serverResponse: i
  }), i;
}
function Yl(t, e, r, n) {
  const s = `${e}${r}?${n}`;
  return t.config.emulator ? Vo(t.config, s) : `${t.config.apiScheme}://${s}`;
}
class v0 {
  constructor(e) {
    this.auth = e, this.timer = null, this.promise = new Promise((r, n) => {
      this.timer = setTimeout(() => n(dr(
        this.auth,
        "network-request-failed"
        /* AuthErrorCode.NETWORK_REQUEST_FAILED */
      )), g0.get());
    });
  }
  clearNetworkTimeout() {
    clearTimeout(this.timer);
  }
}
function Ws(t, e, r) {
  const n = {
    appName: t.name
  };
  r.email && (n.email = r.email), r.phoneNumber && (n.phoneNumber = r.phoneNumber);
  const s = dr(t, e, n);
  return s.customData._tokenResponse = r, s;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function b0(t, e) {
  return Fn(t, "POST", "/v1/accounts:delete", e);
}
async function w0(t, e) {
  return Fn(t, "POST", "/v1/accounts:lookup", e);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function es(t) {
  if (t)
    try {
      const e = new Date(Number(t));
      if (!isNaN(e.getTime()))
        return e.toUTCString();
    } catch {
    }
}
async function _0(t, e = !1) {
  const r = Un(t), n = await r.getIdToken(e), s = Bo(n);
  Ae(
    s && s.exp && s.auth_time && s.iat,
    r.auth,
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  );
  const i = typeof s.firebase == "object" ? s.firebase : void 0, a = i?.sign_in_provider;
  return {
    claims: s,
    token: n,
    authTime: es(ca(s.auth_time)),
    issuedAtTime: es(ca(s.iat)),
    expirationTime: es(ca(s.exp)),
    signInProvider: a || null,
    signInSecondFactor: i?.sign_in_second_factor || null
  };
}
function ca(t) {
  return Number(t) * 1e3;
}
function Bo(t) {
  const [e, r, n] = t.split(".");
  if (e === void 0 || r === void 0 || n === void 0)
    return ei("JWT malformed, contained fewer than 3 sections"), null;
  try {
    const s = ql(r);
    return s ? JSON.parse(s) : (ei("Failed to decode base64 JWT payload"), null);
  } catch (s) {
    return ei("Caught error parsing JWT payload as JSON", s?.toString()), null;
  }
}
function E0(t) {
  const e = Bo(t);
  return Ae(
    e,
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  ), Ae(
    typeof e.exp < "u",
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  ), Ae(
    typeof e.iat < "u",
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  ), Number(e.exp) - Number(e.iat);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function ys(t, e, r = !1) {
  if (r)
    return e;
  try {
    return await e;
  } catch (n) {
    throw n instanceof Ln && S0(n) && t.auth.currentUser === t && await t.auth.signOut(), n;
  }
}
function S0({ code: t }) {
  return t === "auth/user-disabled" || t === "auth/user-token-expired";
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class $0 {
  constructor(e) {
    this.user = e, this.isRunning = !1, this.timerId = null, this.errorBackoff = 3e4;
  }
  _start() {
    this.isRunning || (this.isRunning = !0, this.schedule());
  }
  _stop() {
    this.isRunning && (this.isRunning = !1, this.timerId !== null && clearTimeout(this.timerId));
  }
  getInterval(e) {
    var r;
    if (e) {
      const n = this.errorBackoff;
      return this.errorBackoff = Math.min(
        this.errorBackoff * 2,
        96e4
        /* Duration.RETRY_BACKOFF_MAX */
      ), n;
    } else {
      this.errorBackoff = 3e4;
      const s = ((r = this.user.stsTokenManager.expirationTime) !== null && r !== void 0 ? r : 0) - Date.now() - 3e5;
      return Math.max(0, s);
    }
  }
  schedule(e = !1) {
    if (!this.isRunning)
      return;
    const r = this.getInterval(e);
    this.timerId = setTimeout(async () => {
      await this.iteration();
    }, r);
  }
  async iteration() {
    try {
      await this.user.getIdToken(!0);
    } catch (e) {
      e?.code === "auth/network-request-failed" && this.schedule(
        /* wasError */
        !0
      );
      return;
    }
    this.schedule();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Xl {
  constructor(e, r) {
    this.createdAt = e, this.lastLoginAt = r, this._initializeTime();
  }
  _initializeTime() {
    this.lastSignInTime = es(this.lastLoginAt), this.creationTime = es(this.createdAt);
  }
  _copy(e) {
    this.createdAt = e.createdAt, this.lastLoginAt = e.lastLoginAt, this._initializeTime();
  }
  toJSON() {
    return {
      createdAt: this.createdAt,
      lastLoginAt: this.lastLoginAt
    };
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Pi(t) {
  var e;
  const r = t.auth, n = await t.getIdToken(), s = await ys(t, w0(r, { idToken: n }));
  Ae(
    s?.users.length,
    r,
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  );
  const i = s.users[0];
  t._notifyReloadListener(i);
  const a = !((e = i.providerUserInfo) === null || e === void 0) && e.length ? P0(i.providerUserInfo) : [], o = T0(t.providerData, a), c = t.isAnonymous, l = !(t.email && i.passwordHash) && !o?.length, f = c ? l : !1, h = {
    uid: i.localId,
    displayName: i.displayName || null,
    photoURL: i.photoUrl || null,
    email: i.email || null,
    emailVerified: i.emailVerified || !1,
    phoneNumber: i.phoneNumber || null,
    tenantId: i.tenantId || null,
    providerData: o,
    metadata: new Xl(i.createdAt, i.lastLoginAt),
    isAnonymous: f
  };
  Object.assign(t, h);
}
async function k0(t) {
  const e = Un(t);
  await Pi(e), await e.auth._persistUserIfCurrent(e), e.auth._notifyListenersIfCurrent(e);
}
function T0(t, e) {
  return [...t.filter((n) => !e.some((s) => s.providerId === n.providerId)), ...e];
}
function P0(t) {
  return t.map((e) => {
    var { providerId: r } = e, n = Uo(e, ["providerId"]);
    return {
      providerId: r,
      uid: n.rawId || "",
      displayName: n.displayName || null,
      email: n.email || null,
      phoneNumber: n.phoneNumber || null,
      photoURL: n.photoUrl || null
    };
  });
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function I0(t, e) {
  const r = await Jl(t, {}, async () => {
    const n = As({
      grant_type: "refresh_token",
      refresh_token: e
    }).slice(1), { tokenApiHost: s, apiKey: i } = t.config, a = Yl(t, s, "/v1/token", `key=${i}`), o = await t._getAdditionalHeaders();
    return o[
      "Content-Type"
      /* HttpHeader.CONTENT_TYPE */
    ] = "application/x-www-form-urlencoded", Gl.fetch()(a, {
      method: "POST",
      headers: o,
      body: n
    });
  });
  return {
    accessToken: r.access_token,
    expiresIn: r.expires_in,
    refreshToken: r.refresh_token
  };
}
async function O0(t, e) {
  return Fn(t, "POST", "/v2/accounts:revokeToken", qo(t, e));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class vs {
  constructor() {
    this.refreshToken = null, this.accessToken = null, this.expirationTime = null;
  }
  get isExpired() {
    return !this.expirationTime || Date.now() > this.expirationTime - 3e4;
  }
  updateFromServerResponse(e) {
    Ae(
      e.idToken,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), Ae(
      typeof e.idToken < "u",
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), Ae(
      typeof e.refreshToken < "u",
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    const r = "expiresIn" in e && typeof e.expiresIn < "u" ? Number(e.expiresIn) : E0(e.idToken);
    this.updateTokensAndExpiration(e.idToken, e.refreshToken, r);
  }
  async getToken(e, r = !1) {
    return Ae(
      !this.accessToken || this.refreshToken,
      e,
      "user-token-expired"
      /* AuthErrorCode.TOKEN_EXPIRED */
    ), !r && this.accessToken && !this.isExpired ? this.accessToken : this.refreshToken ? (await this.refresh(e, this.refreshToken), this.accessToken) : null;
  }
  clearRefreshToken() {
    this.refreshToken = null;
  }
  async refresh(e, r) {
    const { accessToken: n, refreshToken: s, expiresIn: i } = await I0(e, r);
    this.updateTokensAndExpiration(n, s, Number(i));
  }
  updateTokensAndExpiration(e, r, n) {
    this.refreshToken = r || null, this.accessToken = e || null, this.expirationTime = Date.now() + n * 1e3;
  }
  static fromJSON(e, r) {
    const { refreshToken: n, accessToken: s, expirationTime: i } = r, a = new vs();
    return n && (Ae(typeof n == "string", "internal-error", {
      appName: e
    }), a.refreshToken = n), s && (Ae(typeof s == "string", "internal-error", {
      appName: e
    }), a.accessToken = s), i && (Ae(typeof i == "number", "internal-error", {
      appName: e
    }), a.expirationTime = i), a;
  }
  toJSON() {
    return {
      refreshToken: this.refreshToken,
      accessToken: this.accessToken,
      expirationTime: this.expirationTime
    };
  }
  _assign(e) {
    this.accessToken = e.accessToken, this.refreshToken = e.refreshToken, this.expirationTime = e.expirationTime;
  }
  _clone() {
    return Object.assign(new vs(), this.toJSON());
  }
  _performRefresh() {
    return _r("not implemented");
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Rr(t, e) {
  Ae(typeof t == "string" || typeof t > "u", "internal-error", { appName: e });
}
class sn {
  constructor(e) {
    var { uid: r, auth: n, stsTokenManager: s } = e, i = Uo(e, ["uid", "auth", "stsTokenManager"]);
    this.providerId = "firebase", this.proactiveRefresh = new $0(this), this.reloadUserInfo = null, this.reloadListener = null, this.uid = r, this.auth = n, this.stsTokenManager = s, this.accessToken = s.accessToken, this.displayName = i.displayName || null, this.email = i.email || null, this.emailVerified = i.emailVerified || !1, this.phoneNumber = i.phoneNumber || null, this.photoURL = i.photoURL || null, this.isAnonymous = i.isAnonymous || !1, this.tenantId = i.tenantId || null, this.providerData = i.providerData ? [...i.providerData] : [], this.metadata = new Xl(i.createdAt || void 0, i.lastLoginAt || void 0);
  }
  async getIdToken(e) {
    const r = await ys(this, this.stsTokenManager.getToken(this.auth, e));
    return Ae(
      r,
      this.auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), this.accessToken !== r && (this.accessToken = r, await this.auth._persistUserIfCurrent(this), this.auth._notifyListenersIfCurrent(this)), r;
  }
  getIdTokenResult(e) {
    return _0(this, e);
  }
  reload() {
    return k0(this);
  }
  _assign(e) {
    this !== e && (Ae(
      this.uid === e.uid,
      this.auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), this.displayName = e.displayName, this.photoURL = e.photoURL, this.email = e.email, this.emailVerified = e.emailVerified, this.phoneNumber = e.phoneNumber, this.isAnonymous = e.isAnonymous, this.tenantId = e.tenantId, this.providerData = e.providerData.map((r) => Object.assign({}, r)), this.metadata._copy(e.metadata), this.stsTokenManager._assign(e.stsTokenManager));
  }
  _clone(e) {
    const r = new sn(Object.assign(Object.assign({}, this), { auth: e, stsTokenManager: this.stsTokenManager._clone() }));
    return r.metadata._copy(this.metadata), r;
  }
  _onReload(e) {
    Ae(
      !this.reloadListener,
      this.auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), this.reloadListener = e, this.reloadUserInfo && (this._notifyReloadListener(this.reloadUserInfo), this.reloadUserInfo = null);
  }
  _notifyReloadListener(e) {
    this.reloadListener ? this.reloadListener(e) : this.reloadUserInfo = e;
  }
  _startProactiveRefresh() {
    this.proactiveRefresh._start();
  }
  _stopProactiveRefresh() {
    this.proactiveRefresh._stop();
  }
  async _updateTokensIfNecessary(e, r = !1) {
    let n = !1;
    e.idToken && e.idToken !== this.stsTokenManager.accessToken && (this.stsTokenManager.updateFromServerResponse(e), n = !0), r && await Pi(this), await this.auth._persistUserIfCurrent(this), n && this.auth._notifyListenersIfCurrent(this);
  }
  async delete() {
    const e = await this.getIdToken();
    return await ys(this, b0(this.auth, { idToken: e })), this.stsTokenManager.clearRefreshToken(), this.auth.signOut();
  }
  toJSON() {
    return Object.assign(Object.assign({
      uid: this.uid,
      email: this.email || void 0,
      emailVerified: this.emailVerified,
      displayName: this.displayName || void 0,
      isAnonymous: this.isAnonymous,
      photoURL: this.photoURL || void 0,
      phoneNumber: this.phoneNumber || void 0,
      tenantId: this.tenantId || void 0,
      providerData: this.providerData.map((e) => Object.assign({}, e)),
      stsTokenManager: this.stsTokenManager.toJSON(),
      // Redirect event ID must be maintained in case there is a pending
      // redirect event.
      _redirectEventId: this._redirectEventId
    }, this.metadata.toJSON()), {
      // Required for compatibility with the legacy SDK (go/firebase-auth-sdk-persistence-parsing):
      apiKey: this.auth.config.apiKey,
      appName: this.auth.name
    });
  }
  get refreshToken() {
    return this.stsTokenManager.refreshToken || "";
  }
  static _fromJSON(e, r) {
    var n, s, i, a, o, c, l, f;
    const h = (n = r.displayName) !== null && n !== void 0 ? n : void 0, y = (s = r.email) !== null && s !== void 0 ? s : void 0, S = (i = r.phoneNumber) !== null && i !== void 0 ? i : void 0, E = (a = r.photoURL) !== null && a !== void 0 ? a : void 0, M = (o = r.tenantId) !== null && o !== void 0 ? o : void 0, A = (c = r._redirectEventId) !== null && c !== void 0 ? c : void 0, $ = (l = r.createdAt) !== null && l !== void 0 ? l : void 0, x = (f = r.lastLoginAt) !== null && f !== void 0 ? f : void 0, { uid: P, emailVerified: U, isAnonymous: B, providerData: w, stsTokenManager: R } = r;
    Ae(
      P && R,
      e,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    const z = vs.fromJSON(this.name, R);
    Ae(
      typeof P == "string",
      e,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), Rr(h, e.name), Rr(y, e.name), Ae(
      typeof U == "boolean",
      e,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), Ae(
      typeof B == "boolean",
      e,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), Rr(S, e.name), Rr(E, e.name), Rr(M, e.name), Rr(A, e.name), Rr($, e.name), Rr(x, e.name);
    const re = new sn({
      uid: P,
      auth: e,
      email: y,
      emailVerified: U,
      displayName: h,
      isAnonymous: B,
      photoURL: E,
      phoneNumber: S,
      tenantId: M,
      stsTokenManager: z,
      createdAt: $,
      lastLoginAt: x
    });
    return w && Array.isArray(w) && (re.providerData = w.map((oe) => Object.assign({}, oe))), A && (re._redirectEventId = A), re;
  }
  /**
   * Initialize a User from an idToken server response
   * @param auth
   * @param idTokenResponse
   */
  static async _fromIdTokenResponse(e, r, n = !1) {
    const s = new vs();
    s.updateFromServerResponse(r);
    const i = new sn({
      uid: r.localId,
      auth: e,
      stsTokenManager: s,
      isAnonymous: n
    });
    return await Pi(i), i;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Fc = /* @__PURE__ */ new Map();
function Er(t) {
  Pr(t instanceof Function, "Expected a class definition");
  let e = Fc.get(t);
  return e ? (Pr(e instanceof t, "Instance stored in cache mismatched with class"), e) : (e = new t(), Fc.set(t, e), e);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ql {
  constructor() {
    this.type = "NONE", this.storage = {};
  }
  async _isAvailable() {
    return !0;
  }
  async _set(e, r) {
    this.storage[e] = r;
  }
  async _get(e) {
    const r = this.storage[e];
    return r === void 0 ? null : r;
  }
  async _remove(e) {
    delete this.storage[e];
  }
  _addListener(e, r) {
  }
  _removeListener(e, r) {
  }
}
Ql.type = "NONE";
const Vc = Ql;
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ti(t, e, r) {
  return `firebase:${t}:${e}:${r}`;
}
class In {
  constructor(e, r, n) {
    this.persistence = e, this.auth = r, this.userKey = n;
    const { config: s, name: i } = this.auth;
    this.fullUserKey = ti(this.userKey, s.apiKey, i), this.fullPersistenceKey = ti("persistence", s.apiKey, i), this.boundEventHandler = r._onStorageEvent.bind(r), this.persistence._addListener(this.fullUserKey, this.boundEventHandler);
  }
  setCurrentUser(e) {
    return this.persistence._set(this.fullUserKey, e.toJSON());
  }
  async getCurrentUser() {
    const e = await this.persistence._get(this.fullUserKey);
    return e ? sn._fromJSON(this.auth, e) : null;
  }
  removeCurrentUser() {
    return this.persistence._remove(this.fullUserKey);
  }
  savePersistenceForRedirect() {
    return this.persistence._set(this.fullPersistenceKey, this.persistence.type);
  }
  async setPersistence(e) {
    if (this.persistence === e)
      return;
    const r = await this.getCurrentUser();
    if (await this.removeCurrentUser(), this.persistence = e, r)
      return this.setCurrentUser(r);
  }
  delete() {
    this.persistence._removeListener(this.fullUserKey, this.boundEventHandler);
  }
  static async create(e, r, n = "authUser") {
    if (!r.length)
      return new In(Er(Vc), e, n);
    const s = (await Promise.all(r.map(async (l) => {
      if (await l._isAvailable())
        return l;
    }))).filter((l) => l);
    let i = s[0] || Er(Vc);
    const a = ti(n, e.config.apiKey, e.name);
    let o = null;
    for (const l of r)
      try {
        const f = await l._get(a);
        if (f) {
          const h = sn._fromJSON(e, f);
          l !== i && (o = h), i = l;
          break;
        }
      } catch {
      }
    const c = s.filter((l) => l._shouldAllowMigration);
    return !i._shouldAllowMigration || !c.length ? new In(i, e, n) : (i = c[0], o && await i._set(a, o.toJSON()), await Promise.all(r.map(async (l) => {
      if (l !== i)
        try {
          await l._remove(a);
        } catch {
        }
    })), new In(i, e, n));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function qc(t) {
  const e = t.toLowerCase();
  if (e.includes("opera/") || e.includes("opr/") || e.includes("opios/"))
    return "Opera";
  if (rd(e))
    return "IEMobile";
  if (e.includes("msie") || e.includes("trident/"))
    return "IE";
  if (e.includes("edge/"))
    return "Edge";
  if (ed(e))
    return "Firefox";
  if (e.includes("silk/"))
    return "Silk";
  if (sd(e))
    return "Blackberry";
  if (id(e))
    return "Webos";
  if (zo(e))
    return "Safari";
  if ((e.includes("chrome/") || td(e)) && !e.includes("edge/"))
    return "Chrome";
  if (nd(e))
    return "Android";
  {
    const r = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/, n = t.match(r);
    if (n?.length === 2)
      return n[1];
  }
  return "Other";
}
function ed(t = Ct()) {
  return /firefox\//i.test(t);
}
function zo(t = Ct()) {
  const e = t.toLowerCase();
  return e.includes("safari/") && !e.includes("chrome/") && !e.includes("crios/") && !e.includes("android");
}
function td(t = Ct()) {
  return /crios\//i.test(t);
}
function rd(t = Ct()) {
  return /iemobile/i.test(t);
}
function nd(t = Ct()) {
  return /android/i.test(t);
}
function sd(t = Ct()) {
  return /blackberry/i.test(t);
}
function id(t = Ct()) {
  return /webos/i.test(t);
}
function qi(t = Ct()) {
  return /iphone|ipad|ipod/i.test(t) || /macintosh/i.test(t) && /mobile/i.test(t);
}
function A0(t = Ct()) {
  var e;
  return qi(t) && !!(!((e = window.navigator) === null || e === void 0) && e.standalone);
}
function N0() {
  return t0() && document.documentMode === 10;
}
function ad(t = Ct()) {
  return qi(t) || nd(t) || id(t) || sd(t) || /windows phone/i.test(t) || rd(t);
}
function C0() {
  try {
    return !!(window && window !== window.top);
  } catch {
    return !1;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function od(t, e = []) {
  let r;
  switch (t) {
    case "Browser":
      r = qc(Ct());
      break;
    case "Worker":
      r = `${qc(Ct())}-${t}`;
      break;
    default:
      r = t;
  }
  const n = e.length ? e.join(",") : "FirebaseCore-web";
  return `${r}/JsCore/${Os}/${n}`;
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class R0 {
  constructor(e) {
    this.auth = e, this.queue = [];
  }
  pushCallback(e, r) {
    const n = (i) => new Promise((a, o) => {
      try {
        const c = e(i);
        a(c);
      } catch (c) {
        o(c);
      }
    });
    n.onAbort = r, this.queue.push(n);
    const s = this.queue.length - 1;
    return () => {
      this.queue[s] = () => Promise.resolve();
    };
  }
  async runMiddleware(e) {
    if (this.auth.currentUser === e)
      return;
    const r = [];
    try {
      for (const n of this.queue)
        await n(e), n.onAbort && r.push(n.onAbort);
    } catch (n) {
      r.reverse();
      for (const s of r)
        try {
          s();
        } catch {
        }
      throw this.auth._errorFactory.create("login-blocked", {
        originalMessage: n?.message
      });
    }
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function D0(t, e = {}) {
  return Fn(t, "GET", "/v2/passwordPolicy", qo(t, e));
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const x0 = 6;
class M0 {
  constructor(e) {
    var r, n, s, i;
    const a = e.customStrengthOptions;
    this.customStrengthOptions = {}, this.customStrengthOptions.minPasswordLength = (r = a.minPasswordLength) !== null && r !== void 0 ? r : x0, a.maxPasswordLength && (this.customStrengthOptions.maxPasswordLength = a.maxPasswordLength), a.containsLowercaseCharacter !== void 0 && (this.customStrengthOptions.containsLowercaseLetter = a.containsLowercaseCharacter), a.containsUppercaseCharacter !== void 0 && (this.customStrengthOptions.containsUppercaseLetter = a.containsUppercaseCharacter), a.containsNumericCharacter !== void 0 && (this.customStrengthOptions.containsNumericCharacter = a.containsNumericCharacter), a.containsNonAlphanumericCharacter !== void 0 && (this.customStrengthOptions.containsNonAlphanumericCharacter = a.containsNonAlphanumericCharacter), this.enforcementState = e.enforcementState, this.enforcementState === "ENFORCEMENT_STATE_UNSPECIFIED" && (this.enforcementState = "OFF"), this.allowedNonAlphanumericCharacters = (s = (n = e.allowedNonAlphanumericCharacters) === null || n === void 0 ? void 0 : n.join("")) !== null && s !== void 0 ? s : "", this.forceUpgradeOnSignin = (i = e.forceUpgradeOnSignin) !== null && i !== void 0 ? i : !1, this.schemaVersion = e.schemaVersion;
  }
  validatePassword(e) {
    var r, n, s, i, a, o;
    const c = {
      isValid: !0,
      passwordPolicy: this
    };
    return this.validatePasswordLengthOptions(e, c), this.validatePasswordCharacterOptions(e, c), c.isValid && (c.isValid = (r = c.meetsMinPasswordLength) !== null && r !== void 0 ? r : !0), c.isValid && (c.isValid = (n = c.meetsMaxPasswordLength) !== null && n !== void 0 ? n : !0), c.isValid && (c.isValid = (s = c.containsLowercaseLetter) !== null && s !== void 0 ? s : !0), c.isValid && (c.isValid = (i = c.containsUppercaseLetter) !== null && i !== void 0 ? i : !0), c.isValid && (c.isValid = (a = c.containsNumericCharacter) !== null && a !== void 0 ? a : !0), c.isValid && (c.isValid = (o = c.containsNonAlphanumericCharacter) !== null && o !== void 0 ? o : !0), c;
  }
  /**
   * Validates that the password meets the length options for the policy.
   *
   * @param password Password to validate.
   * @param status Validation status.
   */
  validatePasswordLengthOptions(e, r) {
    const n = this.customStrengthOptions.minPasswordLength, s = this.customStrengthOptions.maxPasswordLength;
    n && (r.meetsMinPasswordLength = e.length >= n), s && (r.meetsMaxPasswordLength = e.length <= s);
  }
  /**
   * Validates that the password meets the character options for the policy.
   *
   * @param password Password to validate.
   * @param status Validation status.
   */
  validatePasswordCharacterOptions(e, r) {
    this.updatePasswordCharacterOptionsStatuses(
      r,
      /* containsLowercaseCharacter= */
      !1,
      /* containsUppercaseCharacter= */
      !1,
      /* containsNumericCharacter= */
      !1,
      /* containsNonAlphanumericCharacter= */
      !1
    );
    let n;
    for (let s = 0; s < e.length; s++)
      n = e.charAt(s), this.updatePasswordCharacterOptionsStatuses(
        r,
        /* containsLowercaseCharacter= */
        n >= "a" && n <= "z",
        /* containsUppercaseCharacter= */
        n >= "A" && n <= "Z",
        /* containsNumericCharacter= */
        n >= "0" && n <= "9",
        /* containsNonAlphanumericCharacter= */
        this.allowedNonAlphanumericCharacters.includes(n)
      );
  }
  /**
   * Updates the running validation status with the statuses for the character options.
   * Expected to be called each time a character is processed to update each option status
   * based on the current character.
   *
   * @param status Validation status.
   * @param containsLowercaseCharacter Whether the character is a lowercase letter.
   * @param containsUppercaseCharacter Whether the character is an uppercase letter.
   * @param containsNumericCharacter Whether the character is a numeric character.
   * @param containsNonAlphanumericCharacter Whether the character is a non-alphanumeric character.
   */
  updatePasswordCharacterOptionsStatuses(e, r, n, s, i) {
    this.customStrengthOptions.containsLowercaseLetter && (e.containsLowercaseLetter || (e.containsLowercaseLetter = r)), this.customStrengthOptions.containsUppercaseLetter && (e.containsUppercaseLetter || (e.containsUppercaseLetter = n)), this.customStrengthOptions.containsNumericCharacter && (e.containsNumericCharacter || (e.containsNumericCharacter = s)), this.customStrengthOptions.containsNonAlphanumericCharacter && (e.containsNonAlphanumericCharacter || (e.containsNonAlphanumericCharacter = i));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class j0 {
  constructor(e, r, n, s) {
    this.app = e, this.heartbeatServiceProvider = r, this.appCheckServiceProvider = n, this.config = s, this.currentUser = null, this.emulatorConfig = null, this.operations = Promise.resolve(), this.authStateSubscription = new Bc(this), this.idTokenSubscription = new Bc(this), this.beforeStateQueue = new R0(this), this.redirectUser = null, this.isProactiveRefreshEnabled = !1, this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION = 1, this._canInitEmulator = !0, this._isInitialized = !1, this._deleted = !1, this._initializationPromise = null, this._popupRedirectResolver = null, this._errorFactory = Zl, this._agentRecaptchaConfig = null, this._tenantRecaptchaConfigs = {}, this._projectPasswordPolicy = null, this._tenantPasswordPolicies = {}, this.lastNotifiedUid = void 0, this.languageCode = null, this.tenantId = null, this.settings = { appVerificationDisabledForTesting: !1 }, this.frameworks = [], this.name = e.name, this.clientVersion = s.sdkClientVersion;
  }
  _initializeWithPersistence(e, r) {
    return r && (this._popupRedirectResolver = Er(r)), this._initializationPromise = this.queue(async () => {
      var n, s;
      if (!this._deleted && (this.persistenceManager = await In.create(this, e), !this._deleted)) {
        if (!((n = this._popupRedirectResolver) === null || n === void 0) && n._shouldInitProactively)
          try {
            await this._popupRedirectResolver._initialize(this);
          } catch {
          }
        await this.initializeCurrentUser(r), this.lastNotifiedUid = ((s = this.currentUser) === null || s === void 0 ? void 0 : s.uid) || null, !this._deleted && (this._isInitialized = !0);
      }
    }), this._initializationPromise;
  }
  /**
   * If the persistence is changed in another window, the user manager will let us know
   */
  async _onStorageEvent() {
    if (this._deleted)
      return;
    const e = await this.assertedPersistence.getCurrentUser();
    if (!(!this.currentUser && !e)) {
      if (this.currentUser && e && this.currentUser.uid === e.uid) {
        this._currentUser._assign(e), await this.currentUser.getIdToken();
        return;
      }
      await this._updateCurrentUser(
        e,
        /* skipBeforeStateCallbacks */
        !0
      );
    }
  }
  async initializeCurrentUser(e) {
    var r;
    const n = await this.assertedPersistence.getCurrentUser();
    let s = n, i = !1;
    if (e && this.config.authDomain) {
      await this.getOrInitRedirectPersistenceManager();
      const a = (r = this.redirectUser) === null || r === void 0 ? void 0 : r._redirectEventId, o = s?._redirectEventId, c = await this.tryRedirectSignIn(e);
      (!a || a === o) && c?.user && (s = c.user, i = !0);
    }
    if (!s)
      return this.directlySetCurrentUser(null);
    if (!s._redirectEventId) {
      if (i)
        try {
          await this.beforeStateQueue.runMiddleware(s);
        } catch (a) {
          s = n, this._popupRedirectResolver._overrideRedirectResult(this, () => Promise.reject(a));
        }
      return s ? this.reloadAndSetCurrentUserOrClear(s) : this.directlySetCurrentUser(null);
    }
    return Ae(
      this._popupRedirectResolver,
      this,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    ), await this.getOrInitRedirectPersistenceManager(), this.redirectUser && this.redirectUser._redirectEventId === s._redirectEventId ? this.directlySetCurrentUser(s) : this.reloadAndSetCurrentUserOrClear(s);
  }
  async tryRedirectSignIn(e) {
    let r = null;
    try {
      r = await this._popupRedirectResolver._completeRedirectFn(this, e, !0);
    } catch {
      await this._setRedirectUser(null);
    }
    return r;
  }
  async reloadAndSetCurrentUserOrClear(e) {
    try {
      await Pi(e);
    } catch (r) {
      if (r?.code !== "auth/network-request-failed")
        return this.directlySetCurrentUser(null);
    }
    return this.directlySetCurrentUser(e);
  }
  useDeviceLanguage() {
    this.languageCode = p0();
  }
  async _delete() {
    this._deleted = !0;
  }
  async updateCurrentUser(e) {
    const r = e ? Un(e) : null;
    return r && Ae(
      r.auth.config.apiKey === this.config.apiKey,
      this,
      "invalid-user-token"
      /* AuthErrorCode.INVALID_AUTH */
    ), this._updateCurrentUser(r && r._clone(this));
  }
  async _updateCurrentUser(e, r = !1) {
    if (!this._deleted)
      return e && Ae(
        this.tenantId === e.tenantId,
        this,
        "tenant-id-mismatch"
        /* AuthErrorCode.TENANT_ID_MISMATCH */
      ), r || await this.beforeStateQueue.runMiddleware(e), this.queue(async () => {
        await this.directlySetCurrentUser(e), this.notifyAuthListeners();
      });
  }
  async signOut() {
    return await this.beforeStateQueue.runMiddleware(null), (this.redirectPersistenceManager || this._popupRedirectResolver) && await this._setRedirectUser(null), this._updateCurrentUser(
      null,
      /* skipBeforeStateCallbacks */
      !0
    );
  }
  setPersistence(e) {
    return this.queue(async () => {
      await this.assertedPersistence.setPersistence(Er(e));
    });
  }
  _getRecaptchaConfig() {
    return this.tenantId == null ? this._agentRecaptchaConfig : this._tenantRecaptchaConfigs[this.tenantId];
  }
  async validatePassword(e) {
    this._getPasswordPolicyInternal() || await this._updatePasswordPolicy();
    const r = this._getPasswordPolicyInternal();
    return r.schemaVersion !== this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION ? Promise.reject(this._errorFactory.create("unsupported-password-policy-schema-version", {})) : r.validatePassword(e);
  }
  _getPasswordPolicyInternal() {
    return this.tenantId === null ? this._projectPasswordPolicy : this._tenantPasswordPolicies[this.tenantId];
  }
  async _updatePasswordPolicy() {
    const e = await D0(this), r = new M0(e);
    this.tenantId === null ? this._projectPasswordPolicy = r : this._tenantPasswordPolicies[this.tenantId] = r;
  }
  _getPersistence() {
    return this.assertedPersistence.persistence.type;
  }
  _updateErrorMap(e) {
    this._errorFactory = new Vi("auth", "Firebase", e());
  }
  onAuthStateChanged(e, r, n) {
    return this.registerStateListener(this.authStateSubscription, e, r, n);
  }
  beforeAuthStateChanged(e, r) {
    return this.beforeStateQueue.pushCallback(e, r);
  }
  onIdTokenChanged(e, r, n) {
    return this.registerStateListener(this.idTokenSubscription, e, r, n);
  }
  authStateReady() {
    return new Promise((e, r) => {
      if (this.currentUser)
        e();
      else {
        const n = this.onAuthStateChanged(() => {
          n(), e();
        }, r);
      }
    });
  }
  /**
   * Revokes the given access token. Currently only supports Apple OAuth access tokens.
   */
  async revokeAccessToken(e) {
    if (this.currentUser) {
      const r = await this.currentUser.getIdToken(), n = {
        providerId: "apple.com",
        tokenType: "ACCESS_TOKEN",
        token: e,
        idToken: r
      };
      this.tenantId != null && (n.tenantId = this.tenantId), await O0(this, n);
    }
  }
  toJSON() {
    var e;
    return {
      apiKey: this.config.apiKey,
      authDomain: this.config.authDomain,
      appName: this.name,
      currentUser: (e = this._currentUser) === null || e === void 0 ? void 0 : e.toJSON()
    };
  }
  async _setRedirectUser(e, r) {
    const n = await this.getOrInitRedirectPersistenceManager(r);
    return e === null ? n.removeCurrentUser() : n.setCurrentUser(e);
  }
  async getOrInitRedirectPersistenceManager(e) {
    if (!this.redirectPersistenceManager) {
      const r = e && Er(e) || this._popupRedirectResolver;
      Ae(
        r,
        this,
        "argument-error"
        /* AuthErrorCode.ARGUMENT_ERROR */
      ), this.redirectPersistenceManager = await In.create(
        this,
        [Er(r._redirectPersistence)],
        "redirectUser"
        /* KeyName.REDIRECT_USER */
      ), this.redirectUser = await this.redirectPersistenceManager.getCurrentUser();
    }
    return this.redirectPersistenceManager;
  }
  async _redirectUserForId(e) {
    var r, n;
    return this._isInitialized && await this.queue(async () => {
    }), ((r = this._currentUser) === null || r === void 0 ? void 0 : r._redirectEventId) === e ? this._currentUser : ((n = this.redirectUser) === null || n === void 0 ? void 0 : n._redirectEventId) === e ? this.redirectUser : null;
  }
  async _persistUserIfCurrent(e) {
    if (e === this.currentUser)
      return this.queue(async () => this.directlySetCurrentUser(e));
  }
  /** Notifies listeners only if the user is current */
  _notifyListenersIfCurrent(e) {
    e === this.currentUser && this.notifyAuthListeners();
  }
  _key() {
    return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`;
  }
  _startProactiveRefresh() {
    this.isProactiveRefreshEnabled = !0, this.currentUser && this._currentUser._startProactiveRefresh();
  }
  _stopProactiveRefresh() {
    this.isProactiveRefreshEnabled = !1, this.currentUser && this._currentUser._stopProactiveRefresh();
  }
  /** Returns the current user cast as the internal type */
  get _currentUser() {
    return this.currentUser;
  }
  notifyAuthListeners() {
    var e, r;
    if (!this._isInitialized)
      return;
    this.idTokenSubscription.next(this.currentUser);
    const n = (r = (e = this.currentUser) === null || e === void 0 ? void 0 : e.uid) !== null && r !== void 0 ? r : null;
    this.lastNotifiedUid !== n && (this.lastNotifiedUid = n, this.authStateSubscription.next(this.currentUser));
  }
  registerStateListener(e, r, n, s) {
    if (this._deleted)
      return () => {
      };
    const i = typeof r == "function" ? r : r.next.bind(r);
    let a = !1;
    const o = this._isInitialized ? Promise.resolve() : this._initializationPromise;
    if (Ae(
      o,
      this,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), o.then(() => {
      a || i(this.currentUser);
    }), typeof r == "function") {
      const c = e.addObserver(r, n, s);
      return () => {
        a = !0, c();
      };
    } else {
      const c = e.addObserver(r);
      return () => {
        a = !0, c();
      };
    }
  }
  /**
   * Unprotected (from race conditions) method to set the current user. This
   * should only be called from within a queued callback. This is necessary
   * because the queue shouldn't rely on another queued callback.
   */
  async directlySetCurrentUser(e) {
    this.currentUser && this.currentUser !== e && this._currentUser._stopProactiveRefresh(), e && this.isProactiveRefreshEnabled && e._startProactiveRefresh(), this.currentUser = e, e ? await this.assertedPersistence.setCurrentUser(e) : await this.assertedPersistence.removeCurrentUser();
  }
  queue(e) {
    return this.operations = this.operations.then(e, e), this.operations;
  }
  get assertedPersistence() {
    return Ae(
      this.persistenceManager,
      this,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), this.persistenceManager;
  }
  _logFramework(e) {
    !e || this.frameworks.includes(e) || (this.frameworks.push(e), this.frameworks.sort(), this.clientVersion = od(this.config.clientPlatform, this._getFrameworks()));
  }
  _getFrameworks() {
    return this.frameworks;
  }
  async _getAdditionalHeaders() {
    var e;
    const r = {
      "X-Client-Version": this.clientVersion
    };
    this.app.options.appId && (r[
      "X-Firebase-gmpid"
      /* HttpHeader.X_FIREBASE_GMPID */
    ] = this.app.options.appId);
    const n = await ((e = this.heartbeatServiceProvider.getImmediate({
      optional: !0
    })) === null || e === void 0 ? void 0 : e.getHeartbeatsHeader());
    n && (r[
      "X-Firebase-Client"
      /* HttpHeader.X_FIREBASE_CLIENT */
    ] = n);
    const s = await this._getAppCheckToken();
    return s && (r[
      "X-Firebase-AppCheck"
      /* HttpHeader.X_FIREBASE_APP_CHECK */
    ] = s), r;
  }
  async _getAppCheckToken() {
    var e;
    const r = await ((e = this.appCheckServiceProvider.getImmediate({ optional: !0 })) === null || e === void 0 ? void 0 : e.getToken());
    return r?.error && l0(`Error while retrieving App Check token: ${r.error}`), r?.token;
  }
}
function Bi(t) {
  return Un(t);
}
class Bc {
  constructor(e) {
    this.auth = e, this.observer = null, this.addObserver = a0((r) => this.observer = r);
  }
  get next() {
    return Ae(
      this.observer,
      this.auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), this.observer.next.bind(this.observer);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let Wo = {
  async loadJS() {
    throw new Error("Unable to load external scripts");
  },
  recaptchaV2Script: "",
  recaptchaEnterpriseScript: "",
  gapiScript: ""
};
function L0(t) {
  Wo = t;
}
function U0(t) {
  return Wo.loadJS(t);
}
function F0() {
  return Wo.gapiScript;
}
function V0(t) {
  return `__${t}${Math.floor(Math.random() * 1e6)}`;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function q0(t, e) {
  const r = Ll(t, "auth");
  if (r.isInitialized()) {
    const s = r.getImmediate(), i = r.getOptions();
    if (Wl(i, e ?? {}))
      return s;
    mr(
      s,
      "already-initialized"
      /* AuthErrorCode.ALREADY_INITIALIZED */
    );
  }
  return r.initialize({ options: e });
}
function B0(t, e) {
  const r = e?.persistence || [], n = (Array.isArray(r) ? r : [r]).map(Er);
  e?.errorMap && t._updateErrorMap(e.errorMap), t._initializeWithPersistence(n, e?.popupRedirectResolver);
}
function z0(t, e, r) {
  const n = Bi(t);
  Ae(
    n._canInitEmulator,
    n,
    "emulator-config-failed"
    /* AuthErrorCode.EMULATOR_CONFIG_FAILED */
  ), Ae(
    /^https?:\/\//.test(e),
    n,
    "invalid-emulator-scheme"
    /* AuthErrorCode.INVALID_EMULATOR_SCHEME */
  );
  const s = !!r?.disableWarnings, i = cd(e), { host: a, port: o } = W0(e), c = o === null ? "" : `:${o}`;
  n.config.emulator = { url: `${i}//${a}${c}/` }, n.settings.appVerificationDisabledForTesting = !0, n.emulatorConfig = Object.freeze({
    host: a,
    port: o,
    protocol: i.replace(":", ""),
    options: Object.freeze({ disableWarnings: s })
  }), s || H0();
}
function cd(t) {
  const e = t.indexOf(":");
  return e < 0 ? "" : t.substr(0, e + 1);
}
function W0(t) {
  const e = cd(t), r = /(\/\/)?([^?#/]+)/.exec(t.substr(e.length));
  if (!r)
    return { host: "", port: null };
  const n = r[2].split("@").pop() || "", s = /^(\[[^\]]+\])(:|$)/.exec(n);
  if (s) {
    const i = s[1];
    return { host: i, port: zc(n.substr(i.length + 1)) };
  } else {
    const [i, a] = n.split(":");
    return { host: i, port: zc(a) };
  }
}
function zc(t) {
  if (!t)
    return null;
  const e = Number(t);
  return isNaN(e) ? null : e;
}
function H0() {
  function t() {
    const e = document.createElement("p"), r = e.style;
    e.innerText = "Running in emulator mode. Do not use with production credentials.", r.position = "fixed", r.width = "100%", r.backgroundColor = "#ffffff", r.border = ".1em solid #000000", r.color = "#b50000", r.bottom = "0px", r.left = "0px", r.margin = "0px", r.zIndex = "10000", r.textAlign = "center", e.classList.add("firebase-emulator-warning"), document.body.appendChild(e);
  }
  typeof console < "u" && typeof console.info == "function" && console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials."), typeof window < "u" && typeof document < "u" && (document.readyState === "loading" ? window.addEventListener("DOMContentLoaded", t) : t());
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ud {
  /** @internal */
  constructor(e, r) {
    this.providerId = e, this.signInMethod = r;
  }
  /**
   * Returns a JSON-serializable representation of this object.
   *
   * @returns a JSON-serializable representation of this object.
   */
  toJSON() {
    return _r("not implemented");
  }
  /** @internal */
  _getIdTokenResponse(e) {
    return _r("not implemented");
  }
  /** @internal */
  _linkToIdToken(e, r) {
    return _r("not implemented");
  }
  /** @internal */
  _getReauthenticationResolver(e) {
    return _r("not implemented");
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function On(t, e) {
  return y0(t, "POST", "/v1/accounts:signInWithIdp", qo(t, e));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Z0 = "http://localhost";
class fn extends ud {
  constructor() {
    super(...arguments), this.pendingToken = null;
  }
  /** @internal */
  static _fromParams(e) {
    const r = new fn(e.providerId, e.signInMethod);
    return e.idToken || e.accessToken ? (e.idToken && (r.idToken = e.idToken), e.accessToken && (r.accessToken = e.accessToken), e.nonce && !e.pendingToken && (r.nonce = e.nonce), e.pendingToken && (r.pendingToken = e.pendingToken)) : e.oauthToken && e.oauthTokenSecret ? (r.accessToken = e.oauthToken, r.secret = e.oauthTokenSecret) : mr(
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    ), r;
  }
  /** {@inheritdoc AuthCredential.toJSON}  */
  toJSON() {
    return {
      idToken: this.idToken,
      accessToken: this.accessToken,
      secret: this.secret,
      nonce: this.nonce,
      pendingToken: this.pendingToken,
      providerId: this.providerId,
      signInMethod: this.signInMethod
    };
  }
  /**
   * Static method to deserialize a JSON representation of an object into an
   * {@link  AuthCredential}.
   *
   * @param json - Input can be either Object or the stringified representation of the object.
   * When string is provided, JSON.parse would be called first.
   *
   * @returns If the JSON input does not represent an {@link  AuthCredential}, null is returned.
   */
  static fromJSON(e) {
    const r = typeof e == "string" ? JSON.parse(e) : e, { providerId: n, signInMethod: s } = r, i = Uo(r, ["providerId", "signInMethod"]);
    if (!n || !s)
      return null;
    const a = new fn(n, s);
    return a.idToken = i.idToken || void 0, a.accessToken = i.accessToken || void 0, a.secret = i.secret, a.nonce = i.nonce, a.pendingToken = i.pendingToken || null, a;
  }
  /** @internal */
  _getIdTokenResponse(e) {
    const r = this.buildRequest();
    return On(e, r);
  }
  /** @internal */
  _linkToIdToken(e, r) {
    const n = this.buildRequest();
    return n.idToken = r, On(e, n);
  }
  /** @internal */
  _getReauthenticationResolver(e) {
    const r = this.buildRequest();
    return r.autoCreate = !1, On(e, r);
  }
  buildRequest() {
    const e = {
      requestUri: Z0,
      returnSecureToken: !0
    };
    if (this.pendingToken)
      e.pendingToken = this.pendingToken;
    else {
      const r = {};
      this.idToken && (r.id_token = this.idToken), this.accessToken && (r.access_token = this.accessToken), this.secret && (r.oauth_token_secret = this.secret), r.providerId = this.providerId, this.nonce && !this.pendingToken && (r.nonce = this.nonce), e.postBody = As(r);
    }
    return e;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ho {
  /**
   * Constructor for generic OAuth providers.
   *
   * @param providerId - Provider for which credentials should be generated.
   */
  constructor(e) {
    this.providerId = e, this.defaultLanguageCode = null, this.customParameters = {};
  }
  /**
   * Set the language gode.
   *
   * @param languageCode - language code
   */
  setDefaultLanguage(e) {
    this.defaultLanguageCode = e;
  }
  /**
   * Sets the OAuth custom parameters to pass in an OAuth request for popup and redirect sign-in
   * operations.
   *
   * @remarks
   * For a detailed list, check the reserved required OAuth 2.0 parameters such as `client_id`,
   * `redirect_uri`, `scope`, `response_type`, and `state` are not allowed and will be ignored.
   *
   * @param customOAuthParameters - The custom OAuth parameters to pass in the OAuth request.
   */
  setCustomParameters(e) {
    return this.customParameters = e, this;
  }
  /**
   * Retrieve the current list of {@link CustomParameters}.
   */
  getCustomParameters() {
    return this.customParameters;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Cs extends Ho {
  constructor() {
    super(...arguments), this.scopes = [];
  }
  /**
   * Add an OAuth scope to the credential.
   *
   * @param scope - Provider OAuth scope to add.
   */
  addScope(e) {
    return this.scopes.includes(e) || this.scopes.push(e), this;
  }
  /**
   * Retrieve the current list of OAuth scopes.
   */
  getScopes() {
    return [...this.scopes];
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class jr extends Cs {
  constructor() {
    super(
      "facebook.com"
      /* ProviderId.FACEBOOK */
    );
  }
  /**
   * Creates a credential for Facebook.
   *
   * @example
   * ```javascript
   * // `event` from the Facebook auth.authResponseChange callback.
   * const credential = FacebookAuthProvider.credential(event.authResponse.accessToken);
   * const result = await signInWithCredential(credential);
   * ```
   *
   * @param accessToken - Facebook access token.
   */
  static credential(e) {
    return fn._fromParams({
      providerId: jr.PROVIDER_ID,
      signInMethod: jr.FACEBOOK_SIGN_IN_METHOD,
      accessToken: e
    });
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromResult(e) {
    return jr.credentialFromTaggedObject(e);
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
   * thrown during a sign-in, link, or reauthenticate operation.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromError(e) {
    return jr.credentialFromTaggedObject(e.customData || {});
  }
  static credentialFromTaggedObject({ _tokenResponse: e }) {
    if (!e || !("oauthAccessToken" in e) || !e.oauthAccessToken)
      return null;
    try {
      return jr.credential(e.oauthAccessToken);
    } catch {
      return null;
    }
  }
}
jr.FACEBOOK_SIGN_IN_METHOD = "facebook.com";
jr.PROVIDER_ID = "facebook.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ur extends Cs {
  constructor() {
    super(
      "google.com"
      /* ProviderId.GOOGLE */
    ), this.addScope("profile");
  }
  /**
   * Creates a credential for Google. At least one of ID token and access token is required.
   *
   * @example
   * ```javascript
   * // \`googleUser\` from the onsuccess Google Sign In callback.
   * const credential = GoogleAuthProvider.credential(googleUser.getAuthResponse().id_token);
   * const result = await signInWithCredential(credential);
   * ```
   *
   * @param idToken - Google ID token.
   * @param accessToken - Google access token.
   */
  static credential(e, r) {
    return fn._fromParams({
      providerId: ur.PROVIDER_ID,
      signInMethod: ur.GOOGLE_SIGN_IN_METHOD,
      idToken: e,
      accessToken: r
    });
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromResult(e) {
    return ur.credentialFromTaggedObject(e);
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
   * thrown during a sign-in, link, or reauthenticate operation.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromError(e) {
    return ur.credentialFromTaggedObject(e.customData || {});
  }
  static credentialFromTaggedObject({ _tokenResponse: e }) {
    if (!e)
      return null;
    const { oauthIdToken: r, oauthAccessToken: n } = e;
    if (!r && !n)
      return null;
    try {
      return ur.credential(r, n);
    } catch {
      return null;
    }
  }
}
ur.GOOGLE_SIGN_IN_METHOD = "google.com";
ur.PROVIDER_ID = "google.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Lr extends Cs {
  constructor() {
    super(
      "github.com"
      /* ProviderId.GITHUB */
    );
  }
  /**
   * Creates a credential for Github.
   *
   * @param accessToken - Github access token.
   */
  static credential(e) {
    return fn._fromParams({
      providerId: Lr.PROVIDER_ID,
      signInMethod: Lr.GITHUB_SIGN_IN_METHOD,
      accessToken: e
    });
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromResult(e) {
    return Lr.credentialFromTaggedObject(e);
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
   * thrown during a sign-in, link, or reauthenticate operation.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromError(e) {
    return Lr.credentialFromTaggedObject(e.customData || {});
  }
  static credentialFromTaggedObject({ _tokenResponse: e }) {
    if (!e || !("oauthAccessToken" in e) || !e.oauthAccessToken)
      return null;
    try {
      return Lr.credential(e.oauthAccessToken);
    } catch {
      return null;
    }
  }
}
Lr.GITHUB_SIGN_IN_METHOD = "github.com";
Lr.PROVIDER_ID = "github.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ur extends Cs {
  constructor() {
    super(
      "twitter.com"
      /* ProviderId.TWITTER */
    );
  }
  /**
   * Creates a credential for Twitter.
   *
   * @param token - Twitter access token.
   * @param secret - Twitter secret.
   */
  static credential(e, r) {
    return fn._fromParams({
      providerId: Ur.PROVIDER_ID,
      signInMethod: Ur.TWITTER_SIGN_IN_METHOD,
      oauthToken: e,
      oauthTokenSecret: r
    });
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromResult(e) {
    return Ur.credentialFromTaggedObject(e);
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
   * thrown during a sign-in, link, or reauthenticate operation.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromError(e) {
    return Ur.credentialFromTaggedObject(e.customData || {});
  }
  static credentialFromTaggedObject({ _tokenResponse: e }) {
    if (!e)
      return null;
    const { oauthAccessToken: r, oauthTokenSecret: n } = e;
    if (!r || !n)
      return null;
    try {
      return Ur.credential(r, n);
    } catch {
      return null;
    }
  }
}
Ur.TWITTER_SIGN_IN_METHOD = "twitter.com";
Ur.PROVIDER_ID = "twitter.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Dn {
  constructor(e) {
    this.user = e.user, this.providerId = e.providerId, this._tokenResponse = e._tokenResponse, this.operationType = e.operationType;
  }
  static async _fromIdTokenResponse(e, r, n, s = !1) {
    const i = await sn._fromIdTokenResponse(e, n, s), a = Wc(n);
    return new Dn({
      user: i,
      providerId: a,
      _tokenResponse: n,
      operationType: r
    });
  }
  static async _forOperation(e, r, n) {
    await e._updateTokensIfNecessary(
      n,
      /* reload */
      !0
    );
    const s = Wc(n);
    return new Dn({
      user: e,
      providerId: s,
      _tokenResponse: n,
      operationType: r
    });
  }
}
function Wc(t) {
  return t.providerId ? t.providerId : "phoneNumber" in t ? "phone" : null;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ii extends Ln {
  constructor(e, r, n, s) {
    var i;
    super(r.code, r.message), this.operationType = n, this.user = s, Object.setPrototypeOf(this, Ii.prototype), this.customData = {
      appName: e.name,
      tenantId: (i = e.tenantId) !== null && i !== void 0 ? i : void 0,
      _serverResponse: r.customData._serverResponse,
      operationType: n
    };
  }
  static _fromErrorAndOperation(e, r, n, s) {
    return new Ii(e, r, n, s);
  }
}
function ld(t, e, r, n) {
  return (e === "reauthenticate" ? r._getReauthenticationResolver(t) : r._getIdTokenResponse(t)).catch((i) => {
    throw i.code === "auth/multi-factor-auth-required" ? Ii._fromErrorAndOperation(t, i, e, n) : i;
  });
}
async function K0(t, e, r = !1) {
  const n = await ys(t, e._linkToIdToken(t.auth, await t.getIdToken()), r);
  return Dn._forOperation(t, "link", n);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function G0(t, e, r = !1) {
  const { auth: n } = t, s = "reauthenticate";
  try {
    const i = await ys(t, ld(n, s, e, t), r);
    Ae(
      i.idToken,
      n,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    const a = Bo(i.idToken);
    Ae(
      a,
      n,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    const { sub: o } = a;
    return Ae(
      t.uid === o,
      n,
      "user-mismatch"
      /* AuthErrorCode.USER_MISMATCH */
    ), Dn._forOperation(t, s, i);
  } catch (i) {
    throw i?.code === "auth/user-not-found" && mr(
      n,
      "user-mismatch"
      /* AuthErrorCode.USER_MISMATCH */
    ), i;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function J0(t, e, r = !1) {
  const n = "signIn", s = await ld(t, n, e), i = await Dn._fromIdTokenResponse(t, n, s);
  return r || await t._updateCurrentUser(i.user), i;
}
function Y0(t, e, r, n) {
  return Un(t).onIdTokenChanged(e, r, n);
}
function X0(t, e, r) {
  return Un(t).beforeAuthStateChanged(e, r);
}
const Oi = "__sak";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class dd {
  constructor(e, r) {
    this.storageRetriever = e, this.type = r;
  }
  _isAvailable() {
    try {
      return this.storage ? (this.storage.setItem(Oi, "1"), this.storage.removeItem(Oi), Promise.resolve(!0)) : Promise.resolve(!1);
    } catch {
      return Promise.resolve(!1);
    }
  }
  _set(e, r) {
    return this.storage.setItem(e, JSON.stringify(r)), Promise.resolve();
  }
  _get(e) {
    const r = this.storage.getItem(e);
    return Promise.resolve(r ? JSON.parse(r) : null);
  }
  _remove(e) {
    return this.storage.removeItem(e), Promise.resolve();
  }
  get storage() {
    return this.storageRetriever();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Q0() {
  const t = Ct();
  return zo(t) || qi(t);
}
const eE = 1e3, tE = 10;
class fd extends dd {
  constructor() {
    super(
      () => window.localStorage,
      "LOCAL"
      /* PersistenceType.LOCAL */
    ), this.boundEventHandler = (e, r) => this.onStorageEvent(e, r), this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.safariLocalStorageNotSynced = Q0() && C0(), this.fallbackToPolling = ad(), this._shouldAllowMigration = !0;
  }
  forAllChangedKeys(e) {
    for (const r of Object.keys(this.listeners)) {
      const n = this.storage.getItem(r), s = this.localCache[r];
      n !== s && e(r, s, n);
    }
  }
  onStorageEvent(e, r = !1) {
    if (!e.key) {
      this.forAllChangedKeys((a, o, c) => {
        this.notifyListeners(a, c);
      });
      return;
    }
    const n = e.key;
    if (r ? this.detachListener() : this.stopPolling(), this.safariLocalStorageNotSynced) {
      const a = this.storage.getItem(n);
      if (e.newValue !== a)
        e.newValue !== null ? this.storage.setItem(n, e.newValue) : this.storage.removeItem(n);
      else if (this.localCache[n] === e.newValue && !r)
        return;
    }
    const s = () => {
      const a = this.storage.getItem(n);
      !r && this.localCache[n] === a || this.notifyListeners(n, a);
    }, i = this.storage.getItem(n);
    N0() && i !== e.newValue && e.newValue !== e.oldValue ? setTimeout(s, tE) : s();
  }
  notifyListeners(e, r) {
    this.localCache[e] = r;
    const n = this.listeners[e];
    if (n)
      for (const s of Array.from(n))
        s(r && JSON.parse(r));
  }
  startPolling() {
    this.stopPolling(), this.pollTimer = setInterval(() => {
      this.forAllChangedKeys((e, r, n) => {
        this.onStorageEvent(
          new StorageEvent("storage", {
            key: e,
            oldValue: r,
            newValue: n
          }),
          /* poll */
          !0
        );
      });
    }, eE);
  }
  stopPolling() {
    this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null);
  }
  attachListener() {
    window.addEventListener("storage", this.boundEventHandler);
  }
  detachListener() {
    window.removeEventListener("storage", this.boundEventHandler);
  }
  _addListener(e, r) {
    Object.keys(this.listeners).length === 0 && (this.fallbackToPolling ? this.startPolling() : this.attachListener()), this.listeners[e] || (this.listeners[e] = /* @__PURE__ */ new Set(), this.localCache[e] = this.storage.getItem(e)), this.listeners[e].add(r);
  }
  _removeListener(e, r) {
    this.listeners[e] && (this.listeners[e].delete(r), this.listeners[e].size === 0 && delete this.listeners[e]), Object.keys(this.listeners).length === 0 && (this.detachListener(), this.stopPolling());
  }
  // Update local cache on base operations:
  async _set(e, r) {
    await super._set(e, r), this.localCache[e] = JSON.stringify(r);
  }
  async _get(e) {
    const r = await super._get(e);
    return this.localCache[e] = JSON.stringify(r), r;
  }
  async _remove(e) {
    await super._remove(e), delete this.localCache[e];
  }
}
fd.type = "LOCAL";
const rE = fd;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class hd extends dd {
  constructor() {
    super(
      () => window.sessionStorage,
      "SESSION"
      /* PersistenceType.SESSION */
    );
  }
  _addListener(e, r) {
  }
  _removeListener(e, r) {
  }
}
hd.type = "SESSION";
const pd = hd;
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function nE(t) {
  return Promise.all(t.map(async (e) => {
    try {
      return {
        fulfilled: !0,
        value: await e
      };
    } catch (r) {
      return {
        fulfilled: !1,
        reason: r
      };
    }
  }));
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class zi {
  constructor(e) {
    this.eventTarget = e, this.handlersMap = {}, this.boundEventHandler = this.handleEvent.bind(this);
  }
  /**
   * Obtain an instance of a Receiver for a given event target, if none exists it will be created.
   *
   * @param eventTarget - An event target (such as window or self) through which the underlying
   * messages will be received.
   */
  static _getInstance(e) {
    const r = this.receivers.find((s) => s.isListeningto(e));
    if (r)
      return r;
    const n = new zi(e);
    return this.receivers.push(n), n;
  }
  isListeningto(e) {
    return this.eventTarget === e;
  }
  /**
   * Fans out a MessageEvent to the appropriate listeners.
   *
   * @remarks
   * Sends an {@link Status.ACK} upon receipt and a {@link Status.DONE} once all handlers have
   * finished processing.
   *
   * @param event - The MessageEvent.
   *
   */
  async handleEvent(e) {
    const r = e, { eventId: n, eventType: s, data: i } = r.data, a = this.handlersMap[s];
    if (!a?.size)
      return;
    r.ports[0].postMessage({
      status: "ack",
      eventId: n,
      eventType: s
    });
    const o = Array.from(a).map(async (l) => l(r.origin, i)), c = await nE(o);
    r.ports[0].postMessage({
      status: "done",
      eventId: n,
      eventType: s,
      response: c
    });
  }
  /**
   * Subscribe an event handler for a particular event.
   *
   * @param eventType - Event name to subscribe to.
   * @param eventHandler - The event handler which should receive the events.
   *
   */
  _subscribe(e, r) {
    Object.keys(this.handlersMap).length === 0 && this.eventTarget.addEventListener("message", this.boundEventHandler), this.handlersMap[e] || (this.handlersMap[e] = /* @__PURE__ */ new Set()), this.handlersMap[e].add(r);
  }
  /**
   * Unsubscribe an event handler from a particular event.
   *
   * @param eventType - Event name to unsubscribe from.
   * @param eventHandler - Optinoal event handler, if none provided, unsubscribe all handlers on this event.
   *
   */
  _unsubscribe(e, r) {
    this.handlersMap[e] && r && this.handlersMap[e].delete(r), (!r || this.handlersMap[e].size === 0) && delete this.handlersMap[e], Object.keys(this.handlersMap).length === 0 && this.eventTarget.removeEventListener("message", this.boundEventHandler);
  }
}
zi.receivers = [];
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Zo(t = "", e = 10) {
  let r = "";
  for (let n = 0; n < e; n++)
    r += Math.floor(Math.random() * 10);
  return t + r;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class sE {
  constructor(e) {
    this.target = e, this.handlers = /* @__PURE__ */ new Set();
  }
  /**
   * Unsubscribe the handler and remove it from our tracking Set.
   *
   * @param handler - The handler to unsubscribe.
   */
  removeMessageHandler(e) {
    e.messageChannel && (e.messageChannel.port1.removeEventListener("message", e.onMessage), e.messageChannel.port1.close()), this.handlers.delete(e);
  }
  /**
   * Send a message to the Receiver located at {@link target}.
   *
   * @remarks
   * We'll first wait a bit for an ACK , if we get one we will wait significantly longer until the
   * receiver has had a chance to fully process the event.
   *
   * @param eventType - Type of event to send.
   * @param data - The payload of the event.
   * @param timeout - Timeout for waiting on an ACK from the receiver.
   *
   * @returns An array of settled promises from all the handlers that were listening on the receiver.
   */
  async _send(e, r, n = 50) {
    const s = typeof MessageChannel < "u" ? new MessageChannel() : null;
    if (!s)
      throw new Error(
        "connection_unavailable"
        /* _MessageError.CONNECTION_UNAVAILABLE */
      );
    let i, a;
    return new Promise((o, c) => {
      const l = Zo("", 20);
      s.port1.start();
      const f = setTimeout(() => {
        c(new Error(
          "unsupported_event"
          /* _MessageError.UNSUPPORTED_EVENT */
        ));
      }, n);
      a = {
        messageChannel: s,
        onMessage(h) {
          const y = h;
          if (y.data.eventId === l)
            switch (y.data.status) {
              case "ack":
                clearTimeout(f), i = setTimeout(
                  () => {
                    c(new Error(
                      "timeout"
                      /* _MessageError.TIMEOUT */
                    ));
                  },
                  3e3
                  /* _TimeoutDuration.COMPLETION */
                );
                break;
              case "done":
                clearTimeout(i), o(y.data.response);
                break;
              default:
                clearTimeout(f), clearTimeout(i), c(new Error(
                  "invalid_response"
                  /* _MessageError.INVALID_RESPONSE */
                ));
                break;
            }
        }
      }, this.handlers.add(a), s.port1.addEventListener("message", a.onMessage), this.target.postMessage({
        eventType: e,
        eventId: l,
        data: r
      }, [s.port2]);
    }).finally(() => {
      a && this.removeMessageHandler(a);
    });
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function fr() {
  return window;
}
function iE(t) {
  fr().location.href = t;
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function md() {
  return typeof fr().WorkerGlobalScope < "u" && typeof fr().importScripts == "function";
}
async function aE() {
  if (!navigator?.serviceWorker)
    return null;
  try {
    return (await navigator.serviceWorker.ready).active;
  } catch {
    return null;
  }
}
function oE() {
  var t;
  return ((t = navigator?.serviceWorker) === null || t === void 0 ? void 0 : t.controller) || null;
}
function cE() {
  return md() ? self : null;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const gd = "firebaseLocalStorageDb", uE = 1, Ai = "firebaseLocalStorage", yd = "fbase_key";
class Rs {
  constructor(e) {
    this.request = e;
  }
  toPromise() {
    return new Promise((e, r) => {
      this.request.addEventListener("success", () => {
        e(this.request.result);
      }), this.request.addEventListener("error", () => {
        r(this.request.error);
      });
    });
  }
}
function Wi(t, e) {
  return t.transaction([Ai], e ? "readwrite" : "readonly").objectStore(Ai);
}
function lE() {
  const t = indexedDB.deleteDatabase(gd);
  return new Rs(t).toPromise();
}
function La() {
  const t = indexedDB.open(gd, uE);
  return new Promise((e, r) => {
    t.addEventListener("error", () => {
      r(t.error);
    }), t.addEventListener("upgradeneeded", () => {
      const n = t.result;
      try {
        n.createObjectStore(Ai, { keyPath: yd });
      } catch (s) {
        r(s);
      }
    }), t.addEventListener("success", async () => {
      const n = t.result;
      n.objectStoreNames.contains(Ai) ? e(n) : (n.close(), await lE(), e(await La()));
    });
  });
}
async function Hc(t, e, r) {
  const n = Wi(t, !0).put({
    [yd]: e,
    value: r
  });
  return new Rs(n).toPromise();
}
async function dE(t, e) {
  const r = Wi(t, !1).get(e), n = await new Rs(r).toPromise();
  return n === void 0 ? null : n.value;
}
function Zc(t, e) {
  const r = Wi(t, !0).delete(e);
  return new Rs(r).toPromise();
}
const fE = 800, hE = 3;
class vd {
  constructor() {
    this.type = "LOCAL", this._shouldAllowMigration = !0, this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.pendingWrites = 0, this.receiver = null, this.sender = null, this.serviceWorkerReceiverAvailable = !1, this.activeServiceWorker = null, this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then(() => {
    }, () => {
    });
  }
  async _openDb() {
    return this.db ? this.db : (this.db = await La(), this.db);
  }
  async _withRetries(e) {
    let r = 0;
    for (; ; )
      try {
        const n = await this._openDb();
        return await e(n);
      } catch (n) {
        if (r++ > hE)
          throw n;
        this.db && (this.db.close(), this.db = void 0);
      }
  }
  /**
   * IndexedDB events do not propagate from the main window to the worker context.  We rely on a
   * postMessage interface to send these events to the worker ourselves.
   */
  async initializeServiceWorkerMessaging() {
    return md() ? this.initializeReceiver() : this.initializeSender();
  }
  /**
   * As the worker we should listen to events from the main window.
   */
  async initializeReceiver() {
    this.receiver = zi._getInstance(cE()), this.receiver._subscribe("keyChanged", async (e, r) => ({
      keyProcessed: (await this._poll()).includes(r.key)
    })), this.receiver._subscribe("ping", async (e, r) => [
      "keyChanged"
      /* _EventType.KEY_CHANGED */
    ]);
  }
  /**
   * As the main window, we should let the worker know when keys change (set and remove).
   *
   * @remarks
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/ready | ServiceWorkerContainer.ready}
   * may not resolve.
   */
  async initializeSender() {
    var e, r;
    if (this.activeServiceWorker = await aE(), !this.activeServiceWorker)
      return;
    this.sender = new sE(this.activeServiceWorker);
    const n = await this.sender._send(
      "ping",
      {},
      800
      /* _TimeoutDuration.LONG_ACK */
    );
    n && !((e = n[0]) === null || e === void 0) && e.fulfilled && !((r = n[0]) === null || r === void 0) && r.value.includes(
      "keyChanged"
      /* _EventType.KEY_CHANGED */
    ) && (this.serviceWorkerReceiverAvailable = !0);
  }
  /**
   * Let the worker know about a changed key, the exact key doesn't technically matter since the
   * worker will just trigger a full sync anyway.
   *
   * @remarks
   * For now, we only support one service worker per page.
   *
   * @param key - Storage key which changed.
   */
  async notifyServiceWorker(e) {
    if (!(!this.sender || !this.activeServiceWorker || oE() !== this.activeServiceWorker))
      try {
        await this.sender._send(
          "keyChanged",
          { key: e },
          // Use long timeout if receiver has previously responded to a ping from us.
          this.serviceWorkerReceiverAvailable ? 800 : 50
          /* _TimeoutDuration.ACK */
        );
      } catch {
      }
  }
  async _isAvailable() {
    try {
      if (!indexedDB)
        return !1;
      const e = await La();
      return await Hc(e, Oi, "1"), await Zc(e, Oi), !0;
    } catch {
    }
    return !1;
  }
  async _withPendingWrite(e) {
    this.pendingWrites++;
    try {
      await e();
    } finally {
      this.pendingWrites--;
    }
  }
  async _set(e, r) {
    return this._withPendingWrite(async () => (await this._withRetries((n) => Hc(n, e, r)), this.localCache[e] = r, this.notifyServiceWorker(e)));
  }
  async _get(e) {
    const r = await this._withRetries((n) => dE(n, e));
    return this.localCache[e] = r, r;
  }
  async _remove(e) {
    return this._withPendingWrite(async () => (await this._withRetries((r) => Zc(r, e)), delete this.localCache[e], this.notifyServiceWorker(e)));
  }
  async _poll() {
    const e = await this._withRetries((s) => {
      const i = Wi(s, !1).getAll();
      return new Rs(i).toPromise();
    });
    if (!e)
      return [];
    if (this.pendingWrites !== 0)
      return [];
    const r = [], n = /* @__PURE__ */ new Set();
    if (e.length !== 0)
      for (const { fbase_key: s, value: i } of e)
        n.add(s), JSON.stringify(this.localCache[s]) !== JSON.stringify(i) && (this.notifyListeners(s, i), r.push(s));
    for (const s of Object.keys(this.localCache))
      this.localCache[s] && !n.has(s) && (this.notifyListeners(s, null), r.push(s));
    return r;
  }
  notifyListeners(e, r) {
    this.localCache[e] = r;
    const n = this.listeners[e];
    if (n)
      for (const s of Array.from(n))
        s(r);
  }
  startPolling() {
    this.stopPolling(), this.pollTimer = setInterval(async () => this._poll(), fE);
  }
  stopPolling() {
    this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null);
  }
  _addListener(e, r) {
    Object.keys(this.listeners).length === 0 && this.startPolling(), this.listeners[e] || (this.listeners[e] = /* @__PURE__ */ new Set(), this._get(e)), this.listeners[e].add(r);
  }
  _removeListener(e, r) {
    this.listeners[e] && (this.listeners[e].delete(r), this.listeners[e].size === 0 && delete this.listeners[e]), Object.keys(this.listeners).length === 0 && this.stopPolling();
  }
}
vd.type = "LOCAL";
const pE = vd;
new Ns(3e4, 6e4);
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function bd(t, e) {
  return e ? Er(e) : (Ae(
    t._popupRedirectResolver,
    t,
    "argument-error"
    /* AuthErrorCode.ARGUMENT_ERROR */
  ), t._popupRedirectResolver);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ko extends ud {
  constructor(e) {
    super(
      "custom",
      "custom"
      /* ProviderId.CUSTOM */
    ), this.params = e;
  }
  _getIdTokenResponse(e) {
    return On(e, this._buildIdpRequest());
  }
  _linkToIdToken(e, r) {
    return On(e, this._buildIdpRequest(r));
  }
  _getReauthenticationResolver(e) {
    return On(e, this._buildIdpRequest());
  }
  _buildIdpRequest(e) {
    const r = {
      requestUri: this.params.requestUri,
      sessionId: this.params.sessionId,
      postBody: this.params.postBody,
      tenantId: this.params.tenantId,
      pendingToken: this.params.pendingToken,
      returnSecureToken: !0,
      returnIdpCredential: !0
    };
    return e && (r.idToken = e), r;
  }
}
function mE(t) {
  return J0(t.auth, new Ko(t), t.bypassAuthState);
}
function gE(t) {
  const { auth: e, user: r } = t;
  return Ae(
    r,
    e,
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  ), G0(r, new Ko(t), t.bypassAuthState);
}
async function yE(t) {
  const { auth: e, user: r } = t;
  return Ae(
    r,
    e,
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  ), K0(r, new Ko(t), t.bypassAuthState);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class wd {
  constructor(e, r, n, s, i = !1) {
    this.auth = e, this.resolver = n, this.user = s, this.bypassAuthState = i, this.pendingPromise = null, this.eventManager = null, this.filter = Array.isArray(r) ? r : [r];
  }
  execute() {
    return new Promise(async (e, r) => {
      this.pendingPromise = { resolve: e, reject: r };
      try {
        this.eventManager = await this.resolver._initialize(this.auth), await this.onExecution(), this.eventManager.registerConsumer(this);
      } catch (n) {
        this.reject(n);
      }
    });
  }
  async onAuthEvent(e) {
    const { urlResponse: r, sessionId: n, postBody: s, tenantId: i, error: a, type: o } = e;
    if (a) {
      this.reject(a);
      return;
    }
    const c = {
      auth: this.auth,
      requestUri: r,
      sessionId: n,
      tenantId: i || void 0,
      postBody: s || void 0,
      user: this.user,
      bypassAuthState: this.bypassAuthState
    };
    try {
      this.resolve(await this.getIdpTask(o)(c));
    } catch (l) {
      this.reject(l);
    }
  }
  onError(e) {
    this.reject(e);
  }
  getIdpTask(e) {
    switch (e) {
      case "signInViaPopup":
      case "signInViaRedirect":
        return mE;
      case "linkViaPopup":
      case "linkViaRedirect":
        return yE;
      case "reauthViaPopup":
      case "reauthViaRedirect":
        return gE;
      default:
        mr(
          this.auth,
          "internal-error"
          /* AuthErrorCode.INTERNAL_ERROR */
        );
    }
  }
  resolve(e) {
    Pr(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.resolve(e), this.unregisterAndCleanUp();
  }
  reject(e) {
    Pr(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.reject(e), this.unregisterAndCleanUp();
  }
  unregisterAndCleanUp() {
    this.eventManager && this.eventManager.unregisterConsumer(this), this.pendingPromise = null, this.cleanUp();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const vE = new Ns(2e3, 1e4);
async function bE(t, e, r) {
  const n = Bi(t);
  d0(t, e, Ho);
  const s = bd(n, r);
  return new tn(n, "signInViaPopup", e, s).executeNotNull();
}
class tn extends wd {
  constructor(e, r, n, s, i) {
    super(e, r, s, i), this.provider = n, this.authWindow = null, this.pollId = null, tn.currentPopupAction && tn.currentPopupAction.cancel(), tn.currentPopupAction = this;
  }
  async executeNotNull() {
    const e = await this.execute();
    return Ae(
      e,
      this.auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), e;
  }
  async onExecution() {
    Pr(this.filter.length === 1, "Popup operations only handle one event");
    const e = Zo();
    this.authWindow = await this.resolver._openPopup(
      this.auth,
      this.provider,
      this.filter[0],
      // There's always one, see constructor
      e
    ), this.authWindow.associatedEvent = e, this.resolver._originValidation(this.auth).catch((r) => {
      this.reject(r);
    }), this.resolver._isIframeWebStorageSupported(this.auth, (r) => {
      r || this.reject(dr(
        this.auth,
        "web-storage-unsupported"
        /* AuthErrorCode.WEB_STORAGE_UNSUPPORTED */
      ));
    }), this.pollUserCancellation();
  }
  get eventId() {
    var e;
    return ((e = this.authWindow) === null || e === void 0 ? void 0 : e.associatedEvent) || null;
  }
  cancel() {
    this.reject(dr(
      this.auth,
      "cancelled-popup-request"
      /* AuthErrorCode.EXPIRED_POPUP_REQUEST */
    ));
  }
  cleanUp() {
    this.authWindow && this.authWindow.close(), this.pollId && window.clearTimeout(this.pollId), this.authWindow = null, this.pollId = null, tn.currentPopupAction = null;
  }
  pollUserCancellation() {
    const e = () => {
      var r, n;
      if (!((n = (r = this.authWindow) === null || r === void 0 ? void 0 : r.window) === null || n === void 0) && n.closed) {
        this.pollId = window.setTimeout(
          () => {
            this.pollId = null, this.reject(dr(
              this.auth,
              "popup-closed-by-user"
              /* AuthErrorCode.POPUP_CLOSED_BY_USER */
            ));
          },
          8e3
          /* _Timeout.AUTH_EVENT */
        );
        return;
      }
      this.pollId = window.setTimeout(e, vE.get());
    };
    e();
  }
}
tn.currentPopupAction = null;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const wE = "pendingRedirect", ri = /* @__PURE__ */ new Map();
class _E extends wd {
  constructor(e, r, n = !1) {
    super(e, [
      "signInViaRedirect",
      "linkViaRedirect",
      "reauthViaRedirect",
      "unknown"
      /* AuthEventType.UNKNOWN */
    ], r, void 0, n), this.eventId = null;
  }
  /**
   * Override the execute function; if we already have a redirect result, then
   * just return it.
   */
  async execute() {
    let e = ri.get(this.auth._key());
    if (!e) {
      try {
        const n = await EE(this.resolver, this.auth) ? await super.execute() : null;
        e = () => Promise.resolve(n);
      } catch (r) {
        e = () => Promise.reject(r);
      }
      ri.set(this.auth._key(), e);
    }
    return this.bypassAuthState || ri.set(this.auth._key(), () => Promise.resolve(null)), e();
  }
  async onAuthEvent(e) {
    if (e.type === "signInViaRedirect")
      return super.onAuthEvent(e);
    if (e.type === "unknown") {
      this.resolve(null);
      return;
    }
    if (e.eventId) {
      const r = await this.auth._redirectUserForId(e.eventId);
      if (r)
        return this.user = r, super.onAuthEvent(e);
      this.resolve(null);
    }
  }
  async onExecution() {
  }
  cleanUp() {
  }
}
async function EE(t, e) {
  const r = kE(e), n = $E(t);
  if (!await n._isAvailable())
    return !1;
  const s = await n._get(r) === "true";
  return await n._remove(r), s;
}
function SE(t, e) {
  ri.set(t._key(), e);
}
function $E(t) {
  return Er(t._redirectPersistence);
}
function kE(t) {
  return ti(wE, t.config.apiKey, t.name);
}
async function TE(t, e, r = !1) {
  const n = Bi(t), s = bd(n, e), a = await new _E(n, s, r).execute();
  return a && !r && (delete a.user._redirectEventId, await n._persistUserIfCurrent(a.user), await n._setRedirectUser(null, e)), a;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PE = 10 * 60 * 1e3;
class IE {
  constructor(e) {
    this.auth = e, this.cachedEventUids = /* @__PURE__ */ new Set(), this.consumers = /* @__PURE__ */ new Set(), this.queuedRedirectEvent = null, this.hasHandledPotentialRedirect = !1, this.lastProcessedEventTime = Date.now();
  }
  registerConsumer(e) {
    this.consumers.add(e), this.queuedRedirectEvent && this.isEventForConsumer(this.queuedRedirectEvent, e) && (this.sendToConsumer(this.queuedRedirectEvent, e), this.saveEventToCache(this.queuedRedirectEvent), this.queuedRedirectEvent = null);
  }
  unregisterConsumer(e) {
    this.consumers.delete(e);
  }
  onEvent(e) {
    if (this.hasEventBeenHandled(e))
      return !1;
    let r = !1;
    return this.consumers.forEach((n) => {
      this.isEventForConsumer(e, n) && (r = !0, this.sendToConsumer(e, n), this.saveEventToCache(e));
    }), this.hasHandledPotentialRedirect || !OE(e) || (this.hasHandledPotentialRedirect = !0, r || (this.queuedRedirectEvent = e, r = !0)), r;
  }
  sendToConsumer(e, r) {
    var n;
    if (e.error && !_d(e)) {
      const s = ((n = e.error.code) === null || n === void 0 ? void 0 : n.split("auth/")[1]) || "internal-error";
      r.onError(dr(this.auth, s));
    } else
      r.onAuthEvent(e);
  }
  isEventForConsumer(e, r) {
    const n = r.eventId === null || !!e.eventId && e.eventId === r.eventId;
    return r.filter.includes(e.type) && n;
  }
  hasEventBeenHandled(e) {
    return Date.now() - this.lastProcessedEventTime >= PE && this.cachedEventUids.clear(), this.cachedEventUids.has(Kc(e));
  }
  saveEventToCache(e) {
    this.cachedEventUids.add(Kc(e)), this.lastProcessedEventTime = Date.now();
  }
}
function Kc(t) {
  return [t.type, t.eventId, t.sessionId, t.tenantId].filter((e) => e).join("-");
}
function _d({ type: t, error: e }) {
  return t === "unknown" && e?.code === "auth/no-auth-event";
}
function OE(t) {
  switch (t.type) {
    case "signInViaRedirect":
    case "linkViaRedirect":
    case "reauthViaRedirect":
      return !0;
    case "unknown":
      return _d(t);
    default:
      return !1;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function AE(t, e = {}) {
  return Fn(t, "GET", "/v1/projects", e);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const NE = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/, CE = /^https?/;
async function RE(t) {
  if (t.config.emulator)
    return;
  const { authorizedDomains: e } = await AE(t);
  for (const r of e)
    try {
      if (DE(r))
        return;
    } catch {
    }
  mr(
    t,
    "unauthorized-domain"
    /* AuthErrorCode.INVALID_ORIGIN */
  );
}
function DE(t) {
  const e = ja(), { protocol: r, hostname: n } = new URL(e);
  if (t.startsWith("chrome-extension://")) {
    const a = new URL(t);
    return a.hostname === "" && n === "" ? r === "chrome-extension:" && t.replace("chrome-extension://", "") === e.replace("chrome-extension://", "") : r === "chrome-extension:" && a.hostname === n;
  }
  if (!CE.test(r))
    return !1;
  if (NE.test(t))
    return n === t;
  const s = t.replace(/\./g, "\\.");
  return new RegExp("^(.+\\." + s + "|" + s + ")$", "i").test(n);
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const xE = new Ns(3e4, 6e4);
function Gc() {
  const t = fr().___jsl;
  if (t?.H) {
    for (const e of Object.keys(t.H))
      if (t.H[e].r = t.H[e].r || [], t.H[e].L = t.H[e].L || [], t.H[e].r = [...t.H[e].L], t.CP)
        for (let r = 0; r < t.CP.length; r++)
          t.CP[r] = null;
  }
}
function ME(t) {
  return new Promise((e, r) => {
    var n, s, i;
    function a() {
      Gc(), gapi.load("gapi.iframes", {
        callback: () => {
          e(gapi.iframes.getContext());
        },
        ontimeout: () => {
          Gc(), r(dr(
            t,
            "network-request-failed"
            /* AuthErrorCode.NETWORK_REQUEST_FAILED */
          ));
        },
        timeout: xE.get()
      });
    }
    if (!((s = (n = fr().gapi) === null || n === void 0 ? void 0 : n.iframes) === null || s === void 0) && s.Iframe)
      e(gapi.iframes.getContext());
    else if (!((i = fr().gapi) === null || i === void 0) && i.load)
      a();
    else {
      const o = V0("iframefcb");
      return fr()[o] = () => {
        gapi.load ? a() : r(dr(
          t,
          "network-request-failed"
          /* AuthErrorCode.NETWORK_REQUEST_FAILED */
        ));
      }, U0(`${F0()}?onload=${o}`).catch((c) => r(c));
    }
  }).catch((e) => {
    throw ni = null, e;
  });
}
let ni = null;
function jE(t) {
  return ni = ni || ME(t), ni;
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const LE = new Ns(5e3, 15e3), UE = "__/auth/iframe", FE = "emulator/auth/iframe", VE = {
  style: {
    position: "absolute",
    top: "-100px",
    width: "1px",
    height: "1px"
  },
  "aria-hidden": "true",
  tabindex: "-1"
}, qE = /* @__PURE__ */ new Map([
  ["identitytoolkit.googleapis.com", "p"],
  ["staging-identitytoolkit.sandbox.googleapis.com", "s"],
  ["test-identitytoolkit.sandbox.googleapis.com", "t"]
  // test
]);
function BE(t) {
  const e = t.config;
  Ae(
    e.authDomain,
    t,
    "auth-domain-config-required"
    /* AuthErrorCode.MISSING_AUTH_DOMAIN */
  );
  const r = e.emulator ? Vo(e, FE) : `https://${t.config.authDomain}/${UE}`, n = {
    apiKey: e.apiKey,
    appName: t.name,
    v: Os
  }, s = qE.get(t.config.apiHost);
  s && (n.eid = s);
  const i = t._getFrameworks();
  return i.length && (n.fw = i.join(",")), `${r}?${As(n).slice(1)}`;
}
async function zE(t) {
  const e = await jE(t), r = fr().gapi;
  return Ae(
    r,
    t,
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  ), e.open({
    where: document.body,
    url: BE(t),
    messageHandlersFilter: r.iframes.CROSS_ORIGIN_IFRAMES_FILTER,
    attributes: VE,
    dontclear: !0
  }, (n) => new Promise(async (s, i) => {
    await n.restyle({
      // Prevent iframe from closing on mouse out.
      setHideOnLeave: !1
    });
    const a = dr(
      t,
      "network-request-failed"
      /* AuthErrorCode.NETWORK_REQUEST_FAILED */
    ), o = fr().setTimeout(() => {
      i(a);
    }, LE.get());
    function c() {
      fr().clearTimeout(o), s(n);
    }
    n.ping(c).then(c, () => {
      i(a);
    });
  }));
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const WE = {
  location: "yes",
  resizable: "yes",
  statusbar: "yes",
  toolbar: "no"
}, HE = 500, ZE = 600, KE = "_blank", GE = "http://localhost";
class Jc {
  constructor(e) {
    this.window = e, this.associatedEvent = null;
  }
  close() {
    if (this.window)
      try {
        this.window.close();
      } catch {
      }
  }
}
function JE(t, e, r, n = HE, s = ZE) {
  const i = Math.max((window.screen.availHeight - s) / 2, 0).toString(), a = Math.max((window.screen.availWidth - n) / 2, 0).toString();
  let o = "";
  const c = Object.assign(Object.assign({}, WE), {
    width: n.toString(),
    height: s.toString(),
    top: i,
    left: a
  }), l = Ct().toLowerCase();
  r && (o = td(l) ? KE : r), ed(l) && (e = e || GE, c.scrollbars = "yes");
  const f = Object.entries(c).reduce((y, [S, E]) => `${y}${S}=${E},`, "");
  if (A0(l) && o !== "_self")
    return YE(e || "", o), new Jc(null);
  const h = window.open(e || "", o, f);
  Ae(
    h,
    t,
    "popup-blocked"
    /* AuthErrorCode.POPUP_BLOCKED */
  );
  try {
    h.focus();
  } catch {
  }
  return new Jc(h);
}
function YE(t, e) {
  const r = document.createElement("a");
  r.href = t, r.target = e;
  const n = document.createEvent("MouseEvent");
  n.initMouseEvent("click", !0, !0, window, 1, 0, 0, 0, 0, !1, !1, !1, !1, 1, null), r.dispatchEvent(n);
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const XE = "__/auth/handler", QE = "emulator/auth/handler", eS = encodeURIComponent("fac");
async function Yc(t, e, r, n, s, i) {
  Ae(
    t.config.authDomain,
    t,
    "auth-domain-config-required"
    /* AuthErrorCode.MISSING_AUTH_DOMAIN */
  ), Ae(
    t.config.apiKey,
    t,
    "invalid-api-key"
    /* AuthErrorCode.INVALID_API_KEY */
  );
  const a = {
    apiKey: t.config.apiKey,
    appName: t.name,
    authType: r,
    redirectUrl: n,
    v: Os,
    eventId: s
  };
  if (e instanceof Ho) {
    e.setDefaultLanguage(t.languageCode), a.providerId = e.providerId || "", i0(e.getCustomParameters()) || (a.customParameters = JSON.stringify(e.getCustomParameters()));
    for (const [f, h] of Object.entries(i || {}))
      a[f] = h;
  }
  if (e instanceof Cs) {
    const f = e.getScopes().filter((h) => h !== "");
    f.length > 0 && (a.scopes = f.join(","));
  }
  t.tenantId && (a.tid = t.tenantId);
  const o = a;
  for (const f of Object.keys(o))
    o[f] === void 0 && delete o[f];
  const c = await t._getAppCheckToken(), l = c ? `#${eS}=${encodeURIComponent(c)}` : "";
  return `${tS(t)}?${As(o).slice(1)}${l}`;
}
function tS({ config: t }) {
  return t.emulator ? Vo(t, QE) : `https://${t.authDomain}/${XE}`;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ua = "webStorageSupport";
class rS {
  constructor() {
    this.eventManagers = {}, this.iframes = {}, this.originValidationPromises = {}, this._redirectPersistence = pd, this._completeRedirectFn = TE, this._overrideRedirectResult = SE;
  }
  // Wrapping in async even though we don't await anywhere in order
  // to make sure errors are raised as promise rejections
  async _openPopup(e, r, n, s) {
    var i;
    Pr((i = this.eventManagers[e._key()]) === null || i === void 0 ? void 0 : i.manager, "_initialize() not called before _openPopup()");
    const a = await Yc(e, r, n, ja(), s);
    return JE(e, a, Zo());
  }
  async _openRedirect(e, r, n, s) {
    await this._originValidation(e);
    const i = await Yc(e, r, n, ja(), s);
    return iE(i), new Promise(() => {
    });
  }
  _initialize(e) {
    const r = e._key();
    if (this.eventManagers[r]) {
      const { manager: s, promise: i } = this.eventManagers[r];
      return s ? Promise.resolve(s) : (Pr(i, "If manager is not set, promise should be"), i);
    }
    const n = this.initAndGetManager(e);
    return this.eventManagers[r] = { promise: n }, n.catch(() => {
      delete this.eventManagers[r];
    }), n;
  }
  async initAndGetManager(e) {
    const r = await zE(e), n = new IE(e);
    return r.register("authEvent", (s) => (Ae(
      s?.authEvent,
      e,
      "invalid-auth-event"
      /* AuthErrorCode.INVALID_AUTH_EVENT */
    ), {
      status: n.onEvent(s.authEvent) ? "ACK" : "ERROR"
      /* GapiOutcome.ERROR */
    }), gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER), this.eventManagers[e._key()] = { manager: n }, this.iframes[e._key()] = r, n;
  }
  _isIframeWebStorageSupported(e, r) {
    this.iframes[e._key()].send(ua, { type: ua }, (s) => {
      var i;
      const a = (i = s?.[0]) === null || i === void 0 ? void 0 : i[ua];
      a !== void 0 && r(!!a), mr(
        e,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
    }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER);
  }
  _originValidation(e) {
    const r = e._key();
    return this.originValidationPromises[r] || (this.originValidationPromises[r] = RE(e)), this.originValidationPromises[r];
  }
  get _shouldInitProactively() {
    return ad() || zo() || qi();
  }
}
const nS = rS;
var Xc = "@firebase/auth", Qc = "1.6.0";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class sS {
  constructor(e) {
    this.auth = e, this.internalListeners = /* @__PURE__ */ new Map();
  }
  getUid() {
    var e;
    return this.assertAuthConfigured(), ((e = this.auth.currentUser) === null || e === void 0 ? void 0 : e.uid) || null;
  }
  async getToken(e) {
    return this.assertAuthConfigured(), await this.auth._initializationPromise, this.auth.currentUser ? { accessToken: await this.auth.currentUser.getIdToken(e) } : null;
  }
  addAuthTokenListener(e) {
    if (this.assertAuthConfigured(), this.internalListeners.has(e))
      return;
    const r = this.auth.onIdTokenChanged((n) => {
      e(n?.stsTokenManager.accessToken || null);
    });
    this.internalListeners.set(e, r), this.updateProactiveRefresh();
  }
  removeAuthTokenListener(e) {
    this.assertAuthConfigured();
    const r = this.internalListeners.get(e);
    r && (this.internalListeners.delete(e), r(), this.updateProactiveRefresh());
  }
  assertAuthConfigured() {
    Ae(
      this.auth._initializationPromise,
      "dependent-sdk-initialized-before-auth"
      /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */
    );
  }
  updateProactiveRefresh() {
    this.internalListeners.size > 0 ? this.auth._startProactiveRefresh() : this.auth._stopProactiveRefresh();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function iS(t) {
  switch (t) {
    case "Node":
      return "node";
    case "ReactNative":
      return "rn";
    case "Worker":
      return "webworker";
    case "Cordova":
      return "cordova";
    case "WebExtension":
      return "web-extension";
    default:
      return;
  }
}
function aS(t) {
  ms(new Lc(
    "auth",
    (e, { options: r }) => {
      const n = e.getProvider("app").getImmediate(), s = e.getProvider("heartbeat"), i = e.getProvider("app-check-internal"), { apiKey: a, authDomain: o } = n.options;
      Ae(a && !a.includes(":"), "invalid-api-key", { appName: n.name });
      const c = {
        apiKey: a,
        authDomain: o,
        clientPlatform: t,
        apiHost: "identitytoolkit.googleapis.com",
        tokenApiHost: "securetoken.googleapis.com",
        apiScheme: "https",
        sdkClientVersion: od(t)
      }, l = new j0(n, s, i, c);
      return B0(l, r), l;
    },
    "PUBLIC"
    /* ComponentType.PUBLIC */
  ).setInstantiationMode(
    "EXPLICIT"
    /* InstantiationMode.EXPLICIT */
  ).setInstanceCreatedCallback((e, r, n) => {
    e.getProvider(
      "auth-internal"
      /* _ComponentName.AUTH_INTERNAL */
    ).initialize();
  })), ms(new Lc(
    "auth-internal",
    (e) => {
      const r = Bi(e.getProvider(
        "auth"
        /* _ComponentName.AUTH */
      ).getImmediate());
      return ((n) => new sS(n))(r);
    },
    "PRIVATE"
    /* ComponentType.PRIVATE */
  ).setInstantiationMode(
    "EXPLICIT"
    /* InstantiationMode.EXPLICIT */
  )), Pn(Xc, Qc, iS(t)), Pn(Xc, Qc, "esm2017");
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const oS = 5 * 60, cS = zl("authIdTokenMaxAge") || oS;
let eu = null;
const uS = (t) => async (e) => {
  const r = e && await e.getIdTokenResult(), n = r && ((/* @__PURE__ */ new Date()).getTime() - Date.parse(r.issuedAtTime)) / 1e3;
  if (n && n > cS)
    return;
  const s = r?.token;
  eu !== s && (eu = s, await fetch(t, {
    method: s ? "POST" : "DELETE",
    headers: s ? {
      Authorization: `Bearer ${s}`
    } : {}
  }));
};
function lS(t = N_()) {
  const e = Ll(t, "auth");
  if (e.isInitialized())
    return e.getImmediate();
  const r = q0(t, {
    popupRedirectResolver: nS,
    persistence: [
      pE,
      rE,
      pd
    ]
  }), n = zl("authTokenSyncURL");
  if (n) {
    const i = uS(n);
    X0(r, i, () => i(r.currentUser)), Y0(r, (a) => i(a));
  }
  const s = Y_("auth");
  return s && z0(r, `http://${s}`), r;
}
function dS() {
  var t, e;
  return (e = (t = document.getElementsByTagName("head")) === null || t === void 0 ? void 0 : t[0]) !== null && e !== void 0 ? e : document;
}
L0({
  loadJS(t) {
    return new Promise((e, r) => {
      const n = document.createElement("script");
      n.setAttribute("src", t), n.onload = e, n.onerror = (s) => {
        const i = dr(
          "internal-error"
          /* AuthErrorCode.INTERNAL_ERROR */
        );
        i.customData = s, r(i);
      }, n.type = "text/javascript", n.charset = "UTF-8", dS().appendChild(n);
    });
  },
  gapiScript: "https://apis.google.com/js/api.js",
  recaptchaV2Script: "https://www.google.com/recaptcha/api.js",
  recaptchaEnterpriseScript: "https://www.google.com/recaptcha/enterprise.js?render="
});
aS(
  "Browser"
  /* ClientPlatform.BROWSER */
);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const fS = 1e3 * 60 * 60, tu = "google:credentials:accessToken";
class hS {
  get() {
    const e = globalThis.sessionStorage.getItem(tu);
    if (!e)
      return;
    const { key: r, expires: n } = JSON.parse(e);
    if (!(n < Date.now()))
      return r;
  }
  set(e) {
    if (!e)
      return;
    const r = {
      key: e,
      expires: Date.now() + fS
    };
    globalThis.sessionStorage.setItem(tu, JSON.stringify(r));
  }
}
const pS = {
  invoke: async (t) => {
    const { API_KEY: e, AUTH_DOMAIN: r, PROJECT_ID: n, scopes: s } = t;
    if (!e)
      throw "API Key is required to get credentials.";
    if (!r)
      throw "The domain for the popup is required to get credentials.";
    if (!n)
      throw "The GCP project ID is required to get credentials.";
    Ul({
      apiKey: e,
      authDomain: r,
      projectId: n
    });
    const i = lS(), a = new ur();
    (s || []).forEach((l) => a.addScope(l));
    const o = new hS();
    let c = o.get();
    if (!c) {
      const l = await bE(i, a);
      c = ur.credentialFromResult(l)?.accessToken, o.set(c);
    }
    return { accessToken: c };
  }
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const mS = async () => {
  if (!globalThis.document)
    throw new Error("Cannot load gapi outside of a browser environment");
  return globalThis.gapi || new Promise((t) => {
    const e = document.createElement("script");
    e.src = "https://apis.google.com/js/api.js", e.onload = () => {
      t(globalThis.gapi);
    }, e.async = !0, e.defer = !0, document.body.appendChild(e);
  });
}, gS = async (t) => t.client || new Promise((e) => {
  t.load("client", () => {
    e(t.client);
  });
}), yS = async (t, e) => {
  const r = Object.entries(e).filter(([n, s]) => !t[s]).map(([n, s]) => n);
  return await t.init({
    discoveryDocs: r
  }), t;
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const vS = "https://www.googleapis.com/discovery/v1/apis/drive/v3/rest", bS = {
  invoke: async (t) => {
    const { accessToken: e, q: r } = t, n = await mS(), s = await yS(await gS(n), {
      [vS]: "drive"
    });
    return n.auth.getToken() || n.auth.setToken({
      access_token: e
    }), { list: await s.drive?.files.list({
      q: r
    }) };
  }
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const wS = async (t, e) => {
  if (t) {
    const r = await Gt.fromBreadboardCapability(t);
    return {
      async transform(n, s) {
        const i = { chunk: n }, a = await r.runOnce(i, {
          ...e,
          // TODO: figure out how to send diagnostics from streams transformer.
          probe: void 0
        });
        s.enqueue({ chunk: a.chunk });
      }
    };
  } else
    return {
      transform(r, n) {
        n.enqueue(r);
      }
    };
}, _S = {
  invoke: async (t, e) => {
    const { stream: r, board: n, decode: s = !1 } = t;
    if (!r)
      throw new Error("The `stream` input is required");
    if (!lu(r))
      throw new Error("The `stream` input must be a `StreamCapability`.");
    const i = await wS(n, e), a = r, o = s ? new TextDecoderStream() : new TransformStream(), c = a.stream.pipeThrough(o).pipeThrough(new TransformStream(i));
    return { stream: new Ci(c) };
  }
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const ES = {
  invoke: async (t) => {
    const { list: e } = t;
    if (!e)
      throw new Error("The `list` input is required");
    if (!Array.isArray(e))
      throw new Error("The `list` input must be an array");
    const r = new ReadableStream({
      async start(n) {
        for (const s of e)
          n.enqueue({ chunk: s }), n.enqueue({ chunk: " " });
        n.close();
      }
    });
    return { stream: new Ci(r) };
  }
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Ed = new gr({
  url: "npm:@google-labs/node-nursery-web"
}).build({
  credentials: pS,
  driveList: bS,
  transformStream: _S,
  listToStream: ES
}), Sd = xn(Ed), SS = {
  generateMessage: [
    {
      name: "chat-bison-001",
      version: "001",
      displayName: "Chat Bison",
      description: "Chat-optimized generative language model.",
      inputTokenLimit: 4096,
      outputTokenLimit: 1024,
      temperature: 0.25,
      topP: 0.95,
      topK: 40
    }
  ],
  generateText: [
    {
      name: "text-bison-001",
      version: "001",
      displayName: "Text Bison",
      description: "Model targeted for text generation.",
      inputTokenLimit: 8196,
      outputTokenLimit: 1024,
      temperature: 0.7,
      topP: 0.95,
      topK: 40
    }
  ],
  embedText: [
    {
      name: "embedding-gecko-001",
      version: "001",
      displayName: "Embedding Gecko",
      description: "Obtain a distributed representation of a text.",
      inputTokenLimit: 1024,
      outputTokenLimit: 1
    }
  ]
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class $S {
  candidateCount;
  maxOutputTokens;
  prompt = { text: "" };
  safetySettings;
  stopSequences;
  temperature;
  topK;
  topP;
  /**
   * Creates a new instance of a `GenerateTextRequest` builder. You can pass this instance directly into `palm().text()`. The builder follows the typical pattern of builder classes, where you can chain methods together to build the request, like so:
   *
   * ```typescript
   * const text = new Text();
   * text
   * .text("Hello there!").
   * .addSafetySetting("HARM_CATEGORY_DEROGATORY", "BLOCK_LOW_AND_ABOVE")
   * .addStopSequence("==");
   * const data = await fetch(palm(PALM_KEY).text(text));
   * const response = await data.json();
   * ```
   * @param request A partial request object. Just put things like `temperature` and `candidateCount` into it and they will be used in the built instance.
   */
  constructor(e) {
    Object.assign(this, e);
  }
  /**
   * Helper for setting the `text` property of the prompt.
   * @param text Prompt text
   * @returns The builder instance.
   */
  text(e) {
    return this.prompt.text = e, this;
  }
  /**
   * Helper for adding a `SafetySetting` to the request.
   * @param category A valid `SafetyCategory` enum value.
   * @param threshold A valid `SafetyThreshold` enum value.
   * @returns The builder instance.
   */
  addSafetySetting(e, r) {
    return this.safetySettings || (this.safetySettings = []), this.safetySettings.push({ category: e, threshold: r }), this;
  }
  /**
   * Helper for adding a stop sequence to the request.
   * @param sequence A stop sequence to add to the request.
   * @returns The builder instance.
   */
  addStopSequence(e) {
    return this.stopSequences || (this.stopSequences = []), this.stopSequences.push(e), this;
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const kS = "https://generativelanguage.googleapis.com/v1beta2/models";
var ru;
(function(t) {
  t.GenerateMessage = "generateMessage", t.GenerateText = "generateText", t.EmbedText = "embedText";
})(ru || (ru = {}));
const $d = (t) => SS[t][0].name, la = (t, e, r, n) => {
  n || (n = $d(e));
  const s = `${kS}/${n}:${e}?key=${t}`;
  return new Request(s, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(r)
  });
};
class TS {
  key;
  constructor(e) {
    this.key = e;
  }
  /**
   * Produces the `Request` object for the PaLM API `generateMessage` method. The produced object can be supplied directly to `fetch` method.
   * @param request `GenerateMessageRequest` object.
   * @param model Optional model name. If not supplied, the first model in the list of models that support `generateMessage` will be used.
   * @returns a `Request` object.
   */
  message(e, r) {
    return la(this.key, "generateMessage", e, r);
  }
  /**
   * Produces the `Request` object for the PaLM API `generateText` method. The produced object can be supplied directly to `fetch` method.
   * @param request `GenerateTextRequest` object.
   * @param model Optional model name. If not supplied, the first model in the list of models that support `generateText` will be used.
   * @returns a `Request` object.
   */
  text(e, r) {
    return la(this.key, "generateText", e, r);
  }
  /**
   * Produces the `Request` object for the PaLM API `embedText` method. The produced object can be supplied directly to `fetch` method.
   * @param request `EmbedTextRequest` object.
   * @param model Optional model name. If not supplied, the first model in the list of models that support `embedText` will be used.
   * @returns a `Request` object.
   */
  embedding(e, r) {
    return la(this.key, "embedText", e, r);
  }
  /**
   * Returns the id, including name and version, of the model used.
   * @param method PaLM API method, from @enum ModelMethod.
   * @returns a string representing the model id.
   */
  getModelId(e) {
    return $d(e);
  }
}
const kd = (t) => new TS(t);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const PS = (t) => {
  const e = t;
  if (!e.PALM_KEY)
    throw new Error("Text completion requires `PALM_KEY` input");
  if (!e.text)
    throw new Error("Text completion requires `text` input");
  const r = new $S().text(e.text);
  return (e.stopSequences || []).forEach((i) => r.addStopSequence(i)), (e.safetySettings || []).forEach((i) => r.addSafetySetting(i.category, i.threshold)), kd(e.PALM_KEY).text(r);
}, IS = async (t) => {
  const e = await t.json(), n = e?.candidates?.[0]?.output;
  return n ? { completion: n, ...e } : {
    $error: {
      kind: "error",
      error: new Error("Palm generateText failed: " + (t.ok ? JSON.stringify(e) : t.statusText)),
      status: t.status,
      ...e
    }
  };
}, OS = async () => ({
  inputSchema: {
    type: "object",
    properties: {
      text: {
        title: "text",
        description: "Prompt for text completion.",
        type: "string"
      },
      PALM_KEY: {
        title: "PALM_KEY",
        description: "The Google Cloud Platform API key",
        type: "string"
      },
      stopSequences: {
        title: "stopSequences",
        description: "Stop sequences",
        type: "array",
        items: {
          type: "string"
        }
      },
      safetySettings: {
        title: "safetySettings",
        description: "Safety settings",
        type: "array",
        items: {
          type: "object",
          required: ["category", "threshold"]
        }
      }
    },
    required: ["text", "PALM_KEY"]
  },
  outputSchema: {
    type: "object",
    properties: {
      completion: {
        title: "completion",
        description: "The generated text completion of the supplied text input.",
        type: "string"
      },
      $error: {
        title: "$error",
        description: "Error information, if any.",
        type: "object"
      }
    }
  }
}), AS = {
  describe: OS,
  invoke: async (t) => await IS(await fetch(PS(t)))
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const NS = async () => ({
  inputSchema: {
    type: "object",
    properties: {
      text: {
        title: "text",
        description: "Prompt for text completion.",
        type: "string"
      },
      PALM_KEY: {
        title: "PALM_KEY",
        description: "The Google Cloud Platform API key",
        type: "string"
      }
    },
    required: ["text", "PALM_KEY"]
  },
  outputSchema: {
    type: "object",
    properties: {
      embedding: {
        title: "embedding",
        description: "The embedding of the text.",
        type: "array",
        items: {
          type: "number"
        },
        minItems: 768,
        maxItems: 768
      }
    },
    required: ["embedding"]
  }
}), CS = {
  describe: NS,
  invoke: async (t) => {
    const e = t;
    if (!e.PALM_KEY)
      throw new Error("Embedding requires `PALM_KEY` input");
    if (!e.text)
      throw new Error("Embedding requires `text` input");
    const r = { text: e.text };
    let n, s = 3;
    for (; !n && s-- > 0; )
      try {
        const i = kd(e.PALM_KEY).embedding(r);
        n = (await (await fetch(i)).json())?.embedding?.value;
      } catch {
      }
    if (!n)
      throw new Error(`No embedding returned for "${e.text}"`);
    return { embedding: n };
  }
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const RS = new gr({
  title: "PaLM Kit",
  description: "A Breadboard Kit with nodes to access PaLM APIs.",
  url: "npm:@google-labs/palm-kit",
  namespacePrefix: "palm-"
}), Td = RS.build({
  /**
   * Places an `generateText` node on the board.
   *
   * Use this node to generate text from a prompt.
   *
   * See [`generateText` node
   * reference](https://github.com/breadboard-ai/breadboard/blob/main/packages/palm-kit/README.md) for more information.
   */
  generateText: AS,
  /**
   * Places an `embedText` node on the board.
   *
   * Use this node to embed text.
   *
   * See [`embedText` node
   * reference](https://github.com/breadboard-ai/breadboard/blob/main/packages/palm-kit/README.md) for more information.
   */
  embedText: CS
});
xn(Td, "palm-");
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Hi = new Gt({
  title: "Pinecone API configuration helper",
  description: "Loads the Pinecone API key and other necessary variables from the environment. Currently looks for the following environment variables: `PINECONE_API_KEY`, `PINECONE_INDEX`, `PINECONE_PROJECT_ID`, `PINECONE_ENVIRONMENT`.",
  version: "0.0.1"
}), Hs = Hi.addKit(Ir), DS = Hi.addKit(Is);
DS.jsonata({
  expression: "$",
  $id: "start"
}).wire("<-PINECONE_INDEX", Hs.secrets({ keys: ["PINECONE_INDEX"] })).wire("<-PINECONE_PROJECT_ID", Hs.secrets({ keys: ["PINECONE_PROJECT_ID"] })).wire("<-PINECONE_ENVIRONMENT", Hs.secrets({ keys: ["PINECONE_ENVIRONMENT"] })).wire("<-PINECONE_API_KEY", Hs.secrets({ keys: ["PINECONE_API_KEY"] })).wire("result->config", Hi.output({
  $id: "result",
  schema: {
    type: "object",
    properties: {
      config: {
        type: "object",
        title: "Pinecone API configuration",
        description: "The Pinecone API configuration",
        properties: {
          PINECONE_INDEX: {
            type: "string",
            title: "Pinecone index",
            description: "The name of the Pinecone index to use"
          },
          PINECONE_PROJECT_ID: {
            type: "string",
            title: "Pinecone project ID",
            description: "The ID of the Pinecone project to use"
          },
          PINECONE_ENVIRONMENT: {
            type: "string",
            title: "Pinecone environment",
            description: "The Pinecone environment to use"
          },
          PINECONE_API_KEY: {
            type: "string",
            title: "Pinecone API key",
            description: "The Pinecone API key to use"
          }
        },
        required: ["PINECONE_ENVIRONMENT", "PINECONE_API_KEY"]
      }
    },
    reqired: ["config"]
  }
}));
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const bs = new Gt({
  title: "Pinecone API query invocation",
  description: "This board invokes the Pinecone [`query`](https://docs.pinecone.io/reference/query) API.",
  version: "0.0.1"
}), da = bs.addKit(Ir), xS = bs.addKit(Is), MS = xS.jsonata({
  expression: '{ "vector": $, "topK": 10, "includeMetadata": true }',
  $id: "make-body"
}), jS = da.include({ $id: "vector", $ref: "#vector" }).wire("<-call", da.passthrough({ $id: "query-api", call: "query" })).wire("<-config", da.include({ $id: "config", $ref: "#config" }));
bs.input({
  $id: "query",
  schema: {
    type: "object",
    properties: {
      embedding: {
        type: "array",
        title: "Embedding",
        description: "The embedding to query -- an array of floats",
        items: {
          type: "number"
        }
      }
    }
  }
}).wire("embedding->json", MS.wire("result->body", jS.wire("response->", bs.output({ $id: "response" }))));
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Ni = new Gt({
  title: "Pinecone API upsert invocation",
  description: "This board invokes the Pinecone [`vectors/upsert`](https://docs.pinecone.io/reference/upsert) API.",
  version: "0.0.1"
}), fa = Ni.addKit(Ir), LS = fa.include({ $id: "vector", $ref: "#vector" }).wire("<-call", fa.passthrough({ $id: "upsert", call: "vectors/upsert" })).wire("<-config", fa.include({ $id: "config", $ref: "#config" }));
Ni.input({
  $id: "vectors",
  schema: {
    type: "object",
    title: "The body of the API call",
    properties: {
      vectors: {
        type: "array",
        title: "Vectors",
        description: "The vectors to upsert -- an array of objects with `id`, `values` and `metadata` properties",
        items: {
          type: "object",
          properties: {
            id: {
              type: "string",
              title: "ID",
              description: "The ID of the vector"
            },
            values: {
              type: "array",
              title: "Values",
              description: "The vector: a list of floats",
              items: {
                type: "number"
              }
            },
            metadata: {
              type: "object",
              title: "Metadata",
              description: "The metadata associated with the vector"
            }
          }
        }
      }
    }
  }
}).wire("vectors->body", LS.wire("response->", Ni.output()));
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Vn = new Gt({
  title: "Pinecone API vector call builder",
  description: "This board helps making [vector API calls](https://docs.pinecone.io/reference/describe_index_stats_post) to Pinecone.",
  version: "0.0.1"
}), US = Vn.addKit(Fi), FS = Vn.addKit(Ir), Pd = Vn.addKit(Is), Ua = Vn.input({
  $id: "api",
  schema: {
    type: "object",
    properties: {
      api: {
        type: "string",
        title: "API call",
        description: "The API call to make"
      },
      body: {
        type: "object",
        title: "Body",
        description: "The body of the API call"
      },
      config: {
        type: "object",
        title: "Pinecone API configuration",
        description: "The Pinecone API configuration, as returned by the `pinecone-api-config` board",
        properties: {
          PINECONE_INDEX: {
            type: "string",
            title: "Pinecone index",
            description: "The name of the Pinecone index to use"
          },
          PINECONE_PROJECT_ID: {
            type: "string",
            title: "Pinecone project ID",
            description: "The ID of the Pinecone project to use"
          },
          PINECONE_ENVIRONMENT: {
            type: "string",
            title: "Pinecone environment",
            description: "The Pinecone environment to use"
          },
          PINECONE_API_KEY: {
            type: "string",
            title: "Pinecone API key",
            description: "The Pinecone API key to use"
          }
        },
        required: [
          "PINECONE_ENVIRONMENT",
          "PINECONE_API_KEY",
          "PINECONE_INDEX",
          "PINECONE_PROJECT_ID"
        ]
      }
    },
    required: ["api"]
  }
}), si = Pd.jsonata({
  expression: "config",
  $id: "config",
  raw: !0
}).wire("<-config", Ua), VS = Pd.jsonata({
  expression: '{ "Api-Key": $, "Accept": "application/json", "Content-Type": "application/json" }',
  $id: "make-headers"
}).wire("json<-PINECONE_API_KEY", si);
FS.fetch({
  $id: "pinecone-api-call",
  method: "POST"
}).wire("headers<-result", VS).wire("<-url", US.urlTemplate({
  $id: "make-pinecone-url",
  template: "https://{PINECONE_INDEX}-{PINECONE_PROJECT_ID}.svc.{PINECONE_ENVIRONMENT}.pinecone.io/{+call}"
}).wire("<-PINECONE_INDEX", si).wire("<-PINECONE_PROJECT_ID", si).wire("<-PINECONE_ENVIRONMENT", si).wire("<-call", Ua)).wire("<-body", Ua).wire("response->", Vn.output({ $id: "response" }));
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Go = new Gt({
  title: "Pinecone API Node Kit",
  description: "This board is actually a kit: a collection of nodes for working with the Pinecone API.",
  version: "0.0.1"
}), Zi = Go.addKit(Ir);
Go.graphs = {
  config: Hi,
  query: bs,
  upsert: Ni,
  vector: Vn
};
Zi.include({ $id: "config", $ref: "#config" });
Zi.include({ $id: "query", $ref: "#query" });
Zi.include({ $id: "upsert", $ref: "#upsert" });
Zi.include({ $id: "vector", $ref: "#vector" });
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const qS = "https://raw.githubusercontent.com/breadboard-ai/breadboard/main/packages/pinecone-kit/graphs/kit.json", BS = "pinecone-api-", zS = "npm:@google-labs/pinecone-kit", Kn = await Di.create(Go, qS, [
  ii(Fi),
  ii(Ir)
]), WS = new gr(Kn.populateDescriptor({
  url: zS,
  namespacePrefix: BS
})), HS = WS.build({
  config: Kn.handlerForNode("config"),
  query: Kn.handlerForNode("query"),
  upsert: Kn.handlerForNode("upsert"),
  vector: Kn.handlerForNode("vector")
});
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const ZS = {
  title: "Gemini Pro Generator",
  description: "The text generator board powered by the Gemini Pro model",
  version: "0.0.2"
}, KS = [
  {
    name: "The_Calculator_Board",
    description: "A simple AI pattern that leans on the power of the LLMs to generate language to solve math problems.",
    parameters: {
      type: "object",
      properties: {
        text: {
          type: "string",
          description: "Ask a math question"
        }
      },
      required: ["text"]
    }
  },
  {
    name: "The_Search_Summarizer_Board",
    description: "A simple AI pattern that first uses Google Search to find relevant bits of information and then summarizes them using LLM.",
    parameters: {
      type: "object",
      properties: {
        text: {
          type: "string",
          description: "What would you like to search for?"
        }
      },
      required: ["text"]
    }
  }
], GS = [
  {
    role: "user",
    parts: [
      {
        text: "You are a pirate. Please talk like a pirate."
      }
    ]
  },
  {
    role: "model",
    parts: [
      {
        text: "Arr, matey!"
      }
    ]
  }
], JS = {
  type: "object",
  properties: {
    text: {
      type: "string",
      title: "Text",
      description: "The text to generate",
      examples: ["What is the square root of pi?"]
    },
    tools: {
      type: "array",
      title: "Tools",
      description: "An array of functions to use for tool-calling",
      items: {
        type: "string"
      },
      default: "[]",
      examples: [JSON.stringify(KS, null, 2)]
    },
    context: {
      type: "array",
      title: "Context",
      description: "An array of messages to use as conversation context",
      items: {
        type: "object"
      },
      default: "[]",
      examples: [JSON.stringify(GS, null, 2)]
    },
    useStreaming: {
      type: "boolean",
      title: "Stream",
      description: "Whether to stream the output",
      default: "false"
    },
    stopSequences: {
      type: "array",
      title: "Stop Sequences",
      description: "An array of strings that will stop the output",
      items: {
        type: "string"
      },
      default: "[]"
    }
  },
  // TODO: Make text not required when context ends with user turn
  required: ["text"]
}, YS = {
  type: "object",
  properties: {
    text: {
      type: "string",
      title: "Text",
      description: "The generated text"
    },
    context: {
      type: "array",
      title: "Context",
      description: "The conversation context"
    }
  }
}, XS = {
  type: "object",
  properties: {
    toolCalls: {
      type: "array",
      title: "Tool Calls",
      description: "The generated tool calls"
    },
    context: {
      type: "array",
      title: "Context",
      description: "The conversation context"
    }
  }
}, QS = {
  type: "object",
  properties: {
    stream: {
      type: "object",
      title: "Stream",
      format: "stream",
      description: "The generated text"
    }
  }
}, e$ = await yi(() => {
  const t = Zt.input({
    $id: "parameters",
    schema: JS
  });
  function e({ useStreaming: c }) {
    return { method: c ? "streamGenerateContent" : "generateContent", sseOption: c ? "&alt=sse" : "" };
  }
  const r = $n.runJavascript({
    $id: "chooseMethod",
    name: "chooseMethodFunction",
    code: e.toString(),
    raw: !0,
    useStreaming: t
  }), n = Il.urlTemplate({
    $id: "makeURL",
    template: "https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:{method}?key={GEMINI_KEY}{+sseOption}",
    GEMINI_KEY: $n.secrets({ keys: ["GEMINI_KEY"] }),
    ...r
  }), s = Tn.jsonata({
    $id: "makeBody",
    expression: `(
      $context := $append(
          context ? context, $not(context) or context[-1].role!="user" ? [
              {
                  "role": "user",
                  "parts": [
                      {
                          "text": text
                      }
                  ]
              }
          ]);
      text ? {
          "contents": $context,
          "generationConfig": stopSequences ? {
            "stopSequences": stopSequences
          },
          "tools": tools ? {
            "function_declarations": tools
          }
      } : {
          "$error": "\`text\` input is required"
      }
    )`,
    ...t
  }), i = $n.fetch({
    $id: "callGeminiAPI",
    method: "POST",
    stream: t.useStreaming,
    url: n.url,
    body: s.result
  }), a = Tn.jsonata({
    $id: "formatResponse",
    expression: `
  response.candidates[0].content.parts.{
    "text": text ? text,
    "toolCalls": functionCall ? [ functionCall ],
    "context": $append($$.context, %.$)
  }`,
    raw: !0,
    response: i
  }), o = Sd.transformStream({
    $id: "streamTransform",
    board: yi(() => {
      const c = Tn.jsonata({
        $id: "transformChunk",
        expression: "candidates[0].content.parts.text ? $join(candidates[0].content.parts.text) : ''",
        json: Zt.input({}).chunk
      });
      return Zt.output({ chunk: c.result });
    }),
    stream: i
  });
  return Zt.output({
    $id: "textOutput",
    schema: YS,
    context: a,
    text: a
  }), Zt.output({
    $id: "toolCallsOutput",
    schema: XS,
    context: a,
    toolCalls: a
  }), Zt.output({
    $id: "streamOutput",
    schema: QS,
    stream: o
  });
}).serialize(ZS);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const t$ = {
  title: "Gemini Pro Vision",
  description: "A simple example of using `gemini-pro-vision` model",
  version: "0.0.2"
}, r$ = {
  type: "object",
  properties: {
    parts: {
      type: "array",
      format: "multipart",
      title: "Content",
      description: "Add content here",
      minItems: 1,
      items: [
        {
          type: "object",
          title: "Text",
          format: "text_part",
          description: "A text part, which consists of plain text",
          properties: {
            text: {
              type: "string"
            }
          }
        },
        {
          type: "object",
          title: "Image",
          format: "image_part",
          description: "An image part. Can be a JPEG or PNG image"
        }
      ]
    },
    useStreaming: {
      type: "boolean",
      title: "Stream",
      description: "Whether to stream the output",
      default: "false"
    }
  },
  required: ["parts"]
}, n$ = {
  type: "object",
  properties: {
    error: {
      type: "string",
      title: "Error"
    }
  }
}, s$ = {
  properties: {
    stream: {
      type: "object",
      title: "Result",
      format: "stream"
    }
  }
}, i$ = {
  type: "object",
  properties: {
    result: {
      type: "string",
      title: "Result"
    }
  }
}, a$ = await yi(() => {
  const t = Zt.input({ $id: "parameters", schema: r$ }), e = Tn.jsonata({
    $id: "makeBody",
    expression: '{ "contents": { "parts": $.parts }}',
    parts: t
  });
  function r({ useStreaming: o }) {
    return { method: o ? "streamGenerateContent" : "generateContent", sseOption: o ? "&alt=sse" : "" };
  }
  const n = $n.runJavascript({
    $id: "chooseMethod",
    name: "chooseMethodFunction",
    code: r.toString(),
    raw: !0,
    useStreaming: t
  }), s = Il.urlTemplate({
    $id: "makeURL",
    template: "https://generativelanguage.googleapis.com/v1beta/models/gemini-pro-vision:{method}?key={GEMINI_KEY}{+sseOption}",
    GEMINI_KEY: $n.secrets({ keys: ["GEMINI_KEY"] }),
    method: n,
    sseOption: n
  }), i = $n.fetch({
    method: "POST",
    stream: t.useStreaming,
    url: s.url,
    body: e.result
  });
  i.$error.as("json").to(Tn.jsonata({
    $id: "formatError",
    expression: "error.message"
  })).result.as("error").to(Zt.output({ $id: "errorOutput", schema: n$ }));
  const a = Sd.transformStream({
    $id: "chunkToText",
    board: yi(() => Zt.input({}).chunk.to(Xp(({ chunk: o }) => ({
      chunk: o.candidates[0].content.parts[0].text
    }))()).to(Zt.output({}))),
    stream: i.stream
  });
  return Zt.output({
    $id: "streamOutput",
    schema: s$,
    stream: a
  }), Tn.jsonata({
    $id: "formatOutput",
    expression: "$join(candidates.content.parts.text)",
    json: i.response
  }).result.to(Zt.output({
    $id: "textOutput",
    schema: i$
  }));
}).serialize(t$);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Jo = new Gt({
  title: "Gemini API Kit",
  description: "This board is actually a kit: a collection of nodes for working with the Gemini API.",
  version: "0.0.1"
}), Id = Jo.addKit(Ir);
Jo.graphs = {
  text: e$,
  vision: a$
};
Id.invoke({ $id: "text", path: "#text" });
Id.invoke({ $id: "vision", path: "#vision" });
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const o$ = "https://raw.githubusercontent.com/breadboard-ai/breadboard/main/packages/gemini-kit/graphs/kit.json", Fa = await Di.create(Jo, o$, []), c$ = new gr(Fa.populateDescriptor({
  url: "npm:@google-labs/gemini-kit"
  // TODO: This currently doesn't work, because "addKit" below translates
  // handler id directly into the node name. We need to make it work without
  // prefix.
  // namespacePrefix: "gemini-api-",
})), Od = c$.build({
  text: Fa.handlerForNode("text"),
  vision: Fa.handlerForNode("vision")
});
xn(Od);
var u$ = { BASE_URL: "/", MODE: "production", DEV: !1, PROD: !0, SSR: !1 };
const Va = [
  "palm-generateText",
  "palm-embedText",
  "secrets",
  "fetch"
  // TODO: These are only meaningful when proxying to main thread,
  //       not anywhere else. Need to figure out what to do here.
  // "credentials",
  // "driveList",
], l$ = "/worker.js", d$ = "bb-harness", Ad = "proxy-server", qa = "worker", Nd = u$.VITE_PROXY_SERVER_URL, f$ = Nd ? Ad : qa, Cd = [
  Fi,
  Ir,
  HS,
  Td,
  Od,
  Ed,
  Is
].map((t) => ii(t)), S$ = (t) => {
  const e = globalThis.localStorage.getItem(d$) ?? f$, r = [];
  return e === Ad ? r.push({
    location: "http",
    url: Nd,
    nodes: Va
  }) : e === qa && r.push({ location: "main", nodes: Va }), { url: t, kits: Cd, remote: e === qa && {
    type: "worker",
    url: l$
  }, proxy: r, diagnostics: !0 };
}, $$ = ch({
  transport: "worker",
  kits: [{ proxy: Va }, ...Cd],
  diagnostics: !0
});
export {
  Gt as B,
  $f as D,
  m$ as I,
  gr as K,
  xf as P,
  y$ as R,
  Mf as W,
  g$ as a,
  sf as b,
  S$ as c,
  nh as d,
  ii as e,
  v$ as f,
  jf as g,
  eh as h,
  h$ as i,
  $$ as j,
  wa as k,
  Cu as l,
  Bs as m,
  kf as p,
  b$ as s,
  Dt as t
};
