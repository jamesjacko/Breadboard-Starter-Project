import { p as Ye, b as Lt, d as Fe, B as Ze, D as Ke, t as Mt, K as Ge, e as Je, P as Xe, I as Qe, W as Jt, f as tr, g as er, R as rr, h as ir, i as sr, a as or } from "./config-QQQDC_TM.js";
(function() {
  const t = document.createElement("link").relList;
  if (t && t.supports && t.supports("modulepreload"))
    return;
  for (const s of document.querySelectorAll('link[rel="modulepreload"]'))
    r(s);
  new MutationObserver((s) => {
    for (const o of s)
      if (o.type === "childList")
        for (const n of o.addedNodes)
          n.tagName === "LINK" && n.rel === "modulepreload" && r(n);
  }).observe(document, { childList: !0, subtree: !0 });
  function e(s) {
    const o = {};
    return s.integrity && (o.integrity = s.integrity), s.referrerPolicy && (o.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? o.credentials = "include" : s.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o;
  }
  function r(s) {
    if (s.ep)
      return;
    s.ep = !0;
    const o = e(s);
    fetch(s.href, o);
  }
})();
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const nr = () => new TransformStream({
  transform(i, t) {
    i.startsWith("data: ") && t.enqueue(i.slice(6));
  }
}), ar = () => {
  const i = new TransformStream(), t = i.writable.getWriter();
  return new TransformStream({
    transform(e, r) {
      const s = Ye(e, (n) => {
        if (n !== 0)
          throw new Error("HTTPClientTransport does not support multiple streams at the moment.");
        return i.readable;
      }), [o] = Array.isArray(s) ? s : [];
      o === "http-stream-chunk" ? t.write(s[1].chunk) : o === "http-stream-end" ? t.close() : r.enqueue(s);
    }
  });
}, dr = () => {
  let i = [];
  return new TransformStream({
    transform(t, e) {
      const r = !t.endsWith(`
`), s = t.split(`
`).filter(Boolean);
      for (i.length && !r && (e.enqueue(`${i.join("")}${s.shift()}`), i = []); s.length > 1; )
        e.enqueue(s.shift());
      const o = s.shift();
      o && (r ? i.push(o) : e.enqueue(o));
    },
    flush() {
      if (i.length)
        throw new Error("Unexpected end of stream.");
    }
  });
};
class lr {
  #t;
  #e;
  #i;
  constructor(t, e) {
    this.#t = t, this.#e = {
      ...e,
      method: "POST",
      headers: { "Content-Type": "application/json" }
    }, this.#i = this.#e.fetch ?? globalThis.fetch.bind(globalThis);
  }
  createClientStream() {
    let t;
    const e = new Promise((s) => {
      t = s;
    }), r = this;
    return {
      readableResponses: new ReadableStream({
        async pull(s) {
          const n = (await e).getReader();
          for (; ; ) {
            const a = await n.read();
            if (a.done)
              break;
            console.log("%cServer-Sent Event Chunk", "background: #009; color: #FFF", a.value), s.enqueue(a.value);
          }
          s.close();
        }
      }),
      writableRequests: new WritableStream({
        async write(s, o) {
          if (!t)
            throw new Error("HTTPClientTransport supports only one write per stream instance.");
          const n = await r.#i(r.#t, {
            ...r.#e,
            body: JSON.stringify(s)
          });
          n.ok || o.error(new Error(`HTTP error: ${n.status}`)), t(n.body?.pipeThrough(new TextDecoderStream()).pipeThrough(dr()).pipeThrough(nr()).pipeThrough(ar())), t = void 0;
        }
      })
    };
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const cr = (i) => {
  const e = (() => {
    if (i.type === "nodestart")
      return i.state;
  })(), r = structuredClone(i.data);
  return {
    type: i.type,
    data: r,
    state: e,
    reply: async () => {
    }
  };
}, hr = (i) => {
  const { type: t, node: e, timestamp: r } = i;
  if (t === "input") {
    const { inputArguments: s } = i;
    return {
      type: t,
      data: {
        node: e,
        inputArguments: s
      },
      reply: async (o) => {
        i.inputs = o.inputs;
      }
    };
  } else if (t === "output") {
    const { outputs: s } = i;
    return {
      type: t,
      data: {
        node: e,
        outputs: s,
        timestamp: r
      },
      reply: async () => {
      }
    };
  }
  throw new Error(`Unknown result type "${t}".`);
}, ur = () => ({
  type: "end",
  data: { timestamp: Mt() },
  reply: async () => {
  }
}), pr = (i) => ({
  type: "error",
  data: { error: i, timestamp: Mt() },
  reply: async () => {
  }
});
async function* br(i, t) {
  yield* Lt(async (e) => {
    const r = Fe(i), s = await Ze.load(i.url, { base: r });
    try {
      const o = i.diagnostics ? new Ke(async (n) => {
        await e(cr(n));
      }) : void 0;
      for await (const n of s.run({ probe: o, kits: t }))
        await e(hr(n));
      await e(ur());
    } catch (o) {
      let n = o, a = "";
      for (; n?.cause; )
        n = n.cause.error ?? {
          name: "Unexpected Error",
          message: JSON.stringify(n.cause, null, 2)
        }, n && "message" in n && (a += `
${n.message}`);
      console.error(a, n), await e(pr(a));
    }
  });
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const ye = (i) => {
  const t = new Ge({
    url: "secret-asking-kit"
  }).build({
    secrets: async (e) => {
      const { keys: r } = e;
      if (!r)
        return {};
      let s = {};
      return await i({
        type: "secret",
        data: { keys: r, timestamp: Mt() },
        reply: async (o) => {
          s = o.inputs;
        }
      }), s;
    }
  });
  return Je(t);
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const fr = (i) => {
  const e = `import "${new URL(i, location.href)}";`, r = new Blob([e], { type: "text/javascript" }), s = URL.createObjectURL(r);
  return new Worker(s, { type: "module" });
};
async function* gr(i, t, e) {
  const r = fr(i), s = new Xe(r), o = new Qe(new Jt(s.send("load"))), n = new tr(new er(s.receive("proxy"))), a = new rr(new Jt(s.send("run")));
  await o.load(t.url), yield* Lt(async (d) => {
    const h = [ye(d), ...t.kits], u = t.proxy?.[0]?.nodes;
    n.serve({ kits: h, proxy: u });
    for await (const c of a.run(e))
      await d(c);
  });
}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const mr = (i) => {
  const t = i.proxy?.[0];
  if (!t)
    return i.kits;
  if (t.location !== "http")
    throw new Error("Only HTTP node proxy server is supported at this time.");
  if (!t.url)
    throw new Error("No node proxy server URL provided.");
  return [new ir(new lr(t.url)).createProxyKit(t.nodes), ...i.kits];
};
async function* Ni(i) {
  if (!i.remote)
    yield* Lt(async (t) => {
      const e = [ye(t), ...mr(i)];
      for await (const r of br(i, e))
        await t(r);
    });
  else if (i.remote.type === "worker") {
    const t = i.remote && i.remote.url;
    if (!t)
      throw new Error("Worker harness requires a worker URL");
    yield* gr(t, i);
  } else
    throw new Error(`Unsupported harness configuration: ${JSON.stringify(i, null, 2)}`);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Dt = globalThis, gt = Dt.trustedTypes, Xt = gt ? gt.createPolicy("lit-html", { createHTML: (i) => i }) : void 0, jt = "$lit$", S = `lit$${(Math.random() + "").slice(9)}$`, Bt = "?" + S, vr = `<${Bt}>`, I = document, it = () => I.createComment(""), st = (i) => i === null || typeof i != "object" && typeof i != "function", $e = Array.isArray, we = (i) => $e(i) || typeof i?.[Symbol.iterator] == "function", Ct = `[ 	
\f\r]`, K = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, Qt = /-->/g, te = />/g, C = RegExp(`>|${Ct}(?:([^\\s"'>=/]+)(${Ct}*=${Ct}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), ee = /'/g, re = /"/g, xe = /^(?:script|style|textarea|title)$/i, yr = (i) => (t, ...e) => ({ _$litType$: i, strings: t, values: e }), l = yr(1), x = Symbol.for("lit-noChange"), g = Symbol.for("lit-nothing"), ie = /* @__PURE__ */ new WeakMap(), O = I.createTreeWalker(I, 129);
function _e(i, t) {
  if (!Array.isArray(i) || !i.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return Xt !== void 0 ? Xt.createHTML(t) : t;
}
const ke = (i, t) => {
  const e = i.length - 1, r = [];
  let s, o = t === 2 ? "<svg>" : "", n = K;
  for (let a = 0; a < e; a++) {
    const d = i[a];
    let h, u, c = -1, f = 0;
    for (; f < d.length && (n.lastIndex = f, u = n.exec(d), u !== null); )
      f = n.lastIndex, n === K ? u[1] === "!--" ? n = Qt : u[1] !== void 0 ? n = te : u[2] !== void 0 ? (xe.test(u[2]) && (s = RegExp("</" + u[2], "g")), n = C) : u[3] !== void 0 && (n = C) : n === C ? u[0] === ">" ? (n = s ?? K, c = -1) : u[1] === void 0 ? c = -2 : (c = n.lastIndex - u[2].length, h = u[1], n = u[3] === void 0 ? C : u[3] === '"' ? re : ee) : n === re || n === ee ? n = C : n === Qt || n === te ? n = K : (n = C, s = void 0);
    const b = n === C && i[a + 1].startsWith("/>") ? " " : "";
    o += n === K ? d + vr : c >= 0 ? (r.push(h), d.slice(0, c) + jt + d.slice(c) + S + b) : d + S + (c === -2 ? a : b);
  }
  return [_e(i, o + (i[e] || "<?>") + (t === 2 ? "</svg>" : "")), r];
};
class ot {
  constructor({ strings: t, _$litType$: e }, r) {
    let s;
    this.parts = [];
    let o = 0, n = 0;
    const a = t.length - 1, d = this.parts, [h, u] = ke(t, e);
    if (this.el = ot.createElement(h, r), O.currentNode = this.el.content, e === 2) {
      const c = this.el.content.firstChild;
      c.replaceWith(...c.childNodes);
    }
    for (; (s = O.nextNode()) !== null && d.length < a; ) {
      if (s.nodeType === 1) {
        if (s.hasAttributes())
          for (const c of s.getAttributeNames())
            if (c.endsWith(jt)) {
              const f = u[n++], b = s.getAttribute(c).split(S), m = /([.?@])?(.*)/.exec(f);
              d.push({ type: 1, index: o, name: m[2], strings: b, ctor: m[1] === "." ? Ee : m[1] === "?" ? ze : m[1] === "@" ? Se : ht }), s.removeAttribute(c);
            } else
              c.startsWith(S) && (d.push({ type: 6, index: o }), s.removeAttribute(c));
        if (xe.test(s.tagName)) {
          const c = s.textContent.split(S), f = c.length - 1;
          if (f > 0) {
            s.textContent = gt ? gt.emptyScript : "";
            for (let b = 0; b < f; b++)
              s.append(c[b], it()), O.nextNode(), d.push({ type: 2, index: ++o });
            s.append(c[f], it());
          }
        }
      } else if (s.nodeType === 8)
        if (s.data === Bt)
          d.push({ type: 2, index: o });
        else {
          let c = -1;
          for (; (c = s.data.indexOf(S, c + 1)) !== -1; )
            d.push({ type: 7, index: o }), c += S.length - 1;
        }
      o++;
    }
  }
  static createElement(t, e) {
    const r = I.createElement("template");
    return r.innerHTML = t, r;
  }
}
function U(i, t, e = i, r) {
  if (t === x)
    return t;
  let s = r !== void 0 ? e._$Co?.[r] : e._$Cl;
  const o = st(t) ? void 0 : t._$litDirective$;
  return s?.constructor !== o && (s?._$AO?.(!1), o === void 0 ? s = void 0 : (s = new o(i), s._$AT(i, e, r)), r !== void 0 ? (e._$Co ??= [])[r] = s : e._$Cl = s), s !== void 0 && (t = U(i, s._$AS(i, t.values), s, r)), t;
}
let Ae = class {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    const { el: { content: e }, parts: r } = this._$AD, s = (t?.creationScope ?? I).importNode(e, !0);
    O.currentNode = s;
    let o = O.nextNode(), n = 0, a = 0, d = r[0];
    for (; d !== void 0; ) {
      if (n === d.index) {
        let h;
        d.type === 2 ? h = new W(o, o.nextSibling, this, t) : d.type === 1 ? h = new d.ctor(o, d.name, d.strings, this, t) : d.type === 6 && (h = new Ne(o, this, t)), this._$AV.push(h), d = r[++a];
      }
      n !== d?.index && (o = O.nextNode(), n++);
    }
    return O.currentNode = I, s;
  }
  p(t) {
    let e = 0;
    for (const r of this._$AV)
      r !== void 0 && (r.strings !== void 0 ? (r._$AI(t, r, e), e += r.strings.length - 2) : r._$AI(t[e])), e++;
  }
};
class W {
  get _$AU() {
    return this._$AM?._$AU ?? this._$Cv;
  }
  constructor(t, e, r, s) {
    this.type = 2, this._$AH = g, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = r, this.options = s, this._$Cv = s?.isConnected ?? !0;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && t?.nodeType === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = U(this, t, e), st(t) ? t === g || t == null || t === "" ? (this._$AH !== g && this._$AR(), this._$AH = g) : t !== this._$AH && t !== x && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : we(t) ? this.k(t) : this._(t);
  }
  S(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  T(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.S(t));
  }
  _(t) {
    this._$AH !== g && st(this._$AH) ? this._$AA.nextSibling.data = t : this.T(I.createTextNode(t)), this._$AH = t;
  }
  $(t) {
    const { values: e, _$litType$: r } = t, s = typeof r == "number" ? this._$AC(t) : (r.el === void 0 && (r.el = ot.createElement(_e(r.h, r.h[0]), this.options)), r);
    if (this._$AH?._$AD === s)
      this._$AH.p(e);
    else {
      const o = new Ae(s, this), n = o.u(this.options);
      o.p(e), this.T(n), this._$AH = o;
    }
  }
  _$AC(t) {
    let e = ie.get(t.strings);
    return e === void 0 && ie.set(t.strings, e = new ot(t)), e;
  }
  k(t) {
    $e(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let r, s = 0;
    for (const o of t)
      s === e.length ? e.push(r = new W(this.S(it()), this.S(it()), this, this.options)) : r = e[s], r._$AI(o), s++;
    s < e.length && (this._$AR(r && r._$AB.nextSibling, s), e.length = s);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    for (this._$AP?.(!1, !0, e); t && t !== this._$AB; ) {
      const r = t.nextSibling;
      t.remove(), t = r;
    }
  }
  setConnected(t) {
    this._$AM === void 0 && (this._$Cv = t, this._$AP?.(t));
  }
}
class ht {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t, e, r, s, o) {
    this.type = 1, this._$AH = g, this._$AN = void 0, this.element = t, this.name = e, this._$AM = s, this.options = o, r.length > 2 || r[0] !== "" || r[1] !== "" ? (this._$AH = Array(r.length - 1).fill(new String()), this.strings = r) : this._$AH = g;
  }
  _$AI(t, e = this, r, s) {
    const o = this.strings;
    let n = !1;
    if (o === void 0)
      t = U(this, t, e, 0), n = !st(t) || t !== this._$AH && t !== x, n && (this._$AH = t);
    else {
      const a = t;
      let d, h;
      for (t = o[0], d = 0; d < o.length - 1; d++)
        h = U(this, a[r + d], e, d), h === x && (h = this._$AH[d]), n ||= !st(h) || h !== this._$AH[d], h === g ? t = g : t !== g && (t += (h ?? "") + o[d + 1]), this._$AH[d] = h;
    }
    n && !s && this.j(t);
  }
  j(t) {
    t === g ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
}
class Ee extends ht {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === g ? void 0 : t;
  }
}
class ze extends ht {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    this.element.toggleAttribute(this.name, !!t && t !== g);
  }
}
class Se extends ht {
  constructor(t, e, r, s, o) {
    super(t, e, r, s, o), this.type = 5;
  }
  _$AI(t, e = this) {
    if ((t = U(this, t, e, 0) ?? g) === x)
      return;
    const r = this._$AH, s = t === g && r !== g || t.capture !== r.capture || t.once !== r.once || t.passive !== r.passive, o = t !== g && (r === g || s);
    s && this.element.removeEventListener(this.name, this, r), o && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    typeof this._$AH == "function" ? this._$AH.call(this.options?.host ?? this.element, t) : this._$AH.handleEvent(t);
  }
}
class Ne {
  constructor(t, e, r) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = r;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    U(this, t);
  }
}
const $r = { P: jt, A: S, C: Bt, M: 1, L: ke, R: Ae, D: we, V: U, I: W, H: ht, N: ze, U: Se, B: Ee, F: Ne }, wr = Dt.litHtmlPolyfillSupport;
wr?.(ot, W), (Dt.litHtmlVersions ??= []).push("3.1.2");
const xr = (i, t, e) => {
  const r = e?.renderBefore ?? t;
  let s = r._$litPart$;
  if (s === void 0) {
    const o = e?.renderBefore ?? null;
    r._$litPart$ = s = new W(t.insertBefore(it(), o), o, void 0, e ?? {});
  }
  return s._$AI(i), s;
};
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { I: _r } = $r, kr = (i) => i === null || typeof i != "object" && typeof i != "function", Ti = (i, t) => t === void 0 ? i?._$litType$ !== void 0 : i?._$litType$ === t, Ci = (i) => i?._$litType$?.h != null, Ar = (i) => i.strings === void 0, se = () => document.createComment(""), G = (i, t, e) => {
  const r = i._$AA.parentNode, s = t === void 0 ? i._$AB : t._$AA;
  if (e === void 0) {
    const o = r.insertBefore(se(), s), n = r.insertBefore(se(), s);
    e = new _r(o, n, i, i.options);
  } else {
    const o = e._$AB.nextSibling, n = e._$AM, a = n !== i;
    if (a) {
      let d;
      e._$AQ?.(i), e._$AM = i, e._$AP !== void 0 && (d = i._$AU) !== n._$AU && e._$AP(d);
    }
    if (o !== s || a) {
      let d = e._$AA;
      for (; d !== o; ) {
        const h = d.nextSibling;
        r.insertBefore(d, s), d = h;
      }
    }
  }
  return e;
}, R = (i, t, e = i) => (i._$AI(t, e), i), Er = {}, Pe = (i, t = Er) => i._$AH = t, zr = (i) => i._$AH, Rt = (i) => {
  i._$AP?.(!1, !0);
  let t = i._$AA;
  const e = i._$AB.nextSibling;
  for (; t !== e; ) {
    const r = t.nextSibling;
    t.remove(), t = r;
  }
}, Ri = (i) => {
  i._$AR();
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const At = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 }, M = (i) => (...t) => ({ _$litDirective$: i, values: t });
let Y = class {
  constructor(t) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t, e, r) {
    this._$Ct = t, this._$AM = e, this._$Ci = r;
  }
  _$AS(t, e) {
    return this.update(t, e);
  }
  update(t, e) {
    return this.render(...e);
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const tt = (i, t) => {
  const e = i._$AN;
  if (e === void 0)
    return !1;
  for (const r of e)
    r._$AO?.(t, !1), tt(r, t);
  return !0;
}, mt = (i) => {
  let t, e;
  do {
    if ((t = i._$AM) === void 0)
      break;
    e = t._$AN, e.delete(i), i = t;
  } while (e?.size === 0);
}, Te = (i) => {
  for (let t; t = i._$AM; i = t) {
    let e = t._$AN;
    if (e === void 0)
      t._$AN = e = /* @__PURE__ */ new Set();
    else if (e.has(i))
      break;
    e.add(i), Pr(t);
  }
};
function Sr(i) {
  this._$AN !== void 0 ? (mt(this), this._$AM = i, Te(this)) : this._$AM = i;
}
function Nr(i, t = !1, e = 0) {
  const r = this._$AH, s = this._$AN;
  if (s !== void 0 && s.size !== 0)
    if (t)
      if (Array.isArray(r))
        for (let o = e; o < r.length; o++)
          tt(r[o], !1), mt(r[o]);
      else
        r != null && (tt(r, !1), mt(r));
    else
      tt(this, i);
}
const Pr = (i) => {
  i.type == At.CHILD && (i._$AP ??= Nr, i._$AQ ??= Sr);
};
let Ce = class extends Y {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(t, e, r) {
    super._$AT(t, e, r), Te(this), this.isConnected = t._$AU;
  }
  _$AO(t, e = !0) {
    t !== this.isConnected && (this.isConnected = t, t ? this.reconnected?.() : this.disconnected?.()), e && (tt(this, t), mt(this));
  }
  setValue(t) {
    if (Ar(this._$Ct))
      this._$Ct._$AI(t, this);
    else {
      const e = [...this._$Ct._$AH];
      e[this._$Ci] = t, this._$Ct._$AI(e, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
};
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const N = () => new Tr();
let Tr = class {
};
const Ot = /* @__PURE__ */ new WeakMap(), z = M(class extends Ce {
  render(i) {
    return g;
  }
  update(i, [t]) {
    const e = t !== this.Y;
    return e && this.Y !== void 0 && this.rt(void 0), (e || this.lt !== this.ct) && (this.Y = t, this.ht = i.options?.host, this.rt(this.ct = i.element)), g;
  }
  rt(i) {
    if (typeof this.Y == "function") {
      const t = this.ht ?? globalThis;
      let e = Ot.get(t);
      e === void 0 && (e = /* @__PURE__ */ new WeakMap(), Ot.set(t, e)), e.get(this.Y) !== void 0 && this.Y.call(this.ht, void 0), e.set(this.Y, i), i !== void 0 && this.Y.call(this.ht, i);
    } else
      this.Y.value = i;
  }
  get lt() {
    return typeof this.Y == "function" ? Ot.get(this.ht ?? globalThis)?.get(this.Y) : this.Y?.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const $ = (i) => (t, e) => {
  e !== void 0 ? e.addInitializer(() => {
    customElements.define(i, t);
  }) : customElements.define(i, t);
};
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ft = globalThis, Ht = ft.ShadowRoot && (ft.ShadyCSS === void 0 || ft.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, Vt = Symbol(), oe = /* @__PURE__ */ new WeakMap();
let Re = class {
  constructor(t, e, r) {
    if (this._$cssResult$ = !0, r !== Vt)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = e;
  }
  get styleSheet() {
    let t = this.o;
    const e = this.t;
    if (Ht && t === void 0) {
      const r = e !== void 0 && e.length === 1;
      r && (t = oe.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), r && oe.set(e, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
};
const Cr = (i) => new Re(typeof i == "string" ? i : i + "", void 0, Vt), w = (i, ...t) => {
  const e = i.length === 1 ? i[0] : t.reduce((r, s, o) => r + ((n) => {
    if (n._$cssResult$ === !0)
      return n.cssText;
    if (typeof n == "number")
      return n;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + n + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s) + i[o + 1], i[0]);
  return new Re(e, i, Vt);
}, Rr = (i, t) => {
  if (Ht)
    i.adoptedStyleSheets = t.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet);
  else
    for (const e of t) {
      const r = document.createElement("style"), s = ft.litNonce;
      s !== void 0 && r.setAttribute("nonce", s), r.textContent = e.cssText, i.appendChild(r);
    }
}, ne = Ht ? (i) => i : (i) => i instanceof CSSStyleSheet ? ((t) => {
  let e = "";
  for (const r of t.cssRules)
    e += r.cssText;
  return Cr(e);
})(i) : i;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: Or, defineProperty: Ir, getOwnPropertyDescriptor: Ur, getOwnPropertyNames: Lr, getOwnPropertySymbols: Mr, getPrototypeOf: Dr } = Object, Et = globalThis, ae = Et.trustedTypes, jr = ae ? ae.emptyScript : "", Br = Et.reactiveElementPolyfillSupport, et = (i, t) => i, vt = { toAttribute(i, t) {
  switch (t) {
    case Boolean:
      i = i ? jr : null;
      break;
    case Object:
    case Array:
      i = i == null ? i : JSON.stringify(i);
  }
  return i;
}, fromAttribute(i, t) {
  let e = i;
  switch (t) {
    case Boolean:
      e = i !== null;
      break;
    case Number:
      e = i === null ? null : Number(i);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(i);
      } catch {
        e = null;
      }
  }
  return e;
} }, qt = (i, t) => !Or(i, t), de = { attribute: !0, type: String, converter: vt, reflect: !1, hasChanged: qt };
Symbol.metadata ??= Symbol("metadata"), Et.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
class D extends HTMLElement {
  static addInitializer(t) {
    this._$Ei(), (this.l ??= []).push(t);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t, e = de) {
    if (e.state && (e.attribute = !1), this._$Ei(), this.elementProperties.set(t, e), !e.noAccessor) {
      const r = Symbol(), s = this.getPropertyDescriptor(t, r, e);
      s !== void 0 && Ir(this.prototype, t, s);
    }
  }
  static getPropertyDescriptor(t, e, r) {
    const { get: s, set: o } = Ur(this.prototype, t) ?? { get() {
      return this[e];
    }, set(n) {
      this[e] = n;
    } };
    return { get() {
      return s?.call(this);
    }, set(n) {
      const a = s?.call(this);
      o.call(this, n), this.requestUpdate(t, a, r);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) ?? de;
  }
  static _$Ei() {
    if (this.hasOwnProperty(et("elementProperties")))
      return;
    const t = Dr(this);
    t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(et("finalized")))
      return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(et("properties"))) {
      const e = this.properties, r = [...Lr(e), ...Mr(e)];
      for (const s of r)
        this.createProperty(s, e[s]);
    }
    const t = this[Symbol.metadata];
    if (t !== null) {
      const e = litPropertyMetadata.get(t);
      if (e !== void 0)
        for (const [r, s] of e)
          this.elementProperties.set(r, s);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [e, r] of this.elementProperties) {
      const s = this._$Eu(e, r);
      s !== void 0 && this._$Eh.set(s, e);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const r = new Set(t.flat(1 / 0).reverse());
      for (const s of r)
        e.unshift(ne(s));
    } else
      t !== void 0 && e.push(ne(t));
    return e;
  }
  static _$Eu(t, e) {
    const r = e.attribute;
    return r === !1 ? void 0 : typeof r == "string" ? r : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise((t) => this.enableUpdating = t), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t) => t(this));
  }
  addController(t) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t), this.renderRoot !== void 0 && this.isConnected && t.hostConnected?.();
  }
  removeController(t) {
    this._$EO?.delete(t);
  }
  _$E_() {
    const t = /* @__PURE__ */ new Map(), e = this.constructor.elementProperties;
    for (const r of e.keys())
      this.hasOwnProperty(r) && (t.set(r, this[r]), delete this[r]);
    t.size > 0 && (this._$Ep = t);
  }
  createRenderRoot() {
    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return Rr(t, this.constructor.elementStyles), t;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(!0), this._$EO?.forEach((t) => t.hostConnected?.());
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    this._$EO?.forEach((t) => t.hostDisconnected?.());
  }
  attributeChangedCallback(t, e, r) {
    this._$AK(t, r);
  }
  _$EC(t, e) {
    const r = this.constructor.elementProperties.get(t), s = this.constructor._$Eu(t, r);
    if (s !== void 0 && r.reflect === !0) {
      const o = (r.converter?.toAttribute !== void 0 ? r.converter : vt).toAttribute(e, r.type);
      this._$Em = t, o == null ? this.removeAttribute(s) : this.setAttribute(s, o), this._$Em = null;
    }
  }
  _$AK(t, e) {
    const r = this.constructor, s = r._$Eh.get(t);
    if (s !== void 0 && this._$Em !== s) {
      const o = r.getPropertyOptions(s), n = typeof o.converter == "function" ? { fromAttribute: o.converter } : o.converter?.fromAttribute !== void 0 ? o.converter : vt;
      this._$Em = s, this[s] = n.fromAttribute(e, o.type), this._$Em = null;
    }
  }
  requestUpdate(t, e, r) {
    if (t !== void 0) {
      if (r ??= this.constructor.getPropertyOptions(t), !(r.hasChanged ?? qt)(this[t], e))
        return;
      this.P(t, e, r);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$ET());
  }
  P(t, e, r) {
    this._$AL.has(t) || this._$AL.set(t, e), r.reflect === !0 && this._$Em !== t && (this._$Ej ??= /* @__PURE__ */ new Set()).add(t);
  }
  async _$ET() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (e) {
      Promise.reject(e);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [s, o] of this._$Ep)
          this[s] = o;
        this._$Ep = void 0;
      }
      const r = this.constructor.elementProperties;
      if (r.size > 0)
        for (const [s, o] of r)
          o.wrapped !== !0 || this._$AL.has(s) || this[s] === void 0 || this.P(s, this[s], o);
    }
    let t = !1;
    const e = this._$AL;
    try {
      t = this.shouldUpdate(e), t ? (this.willUpdate(e), this._$EO?.forEach((r) => r.hostUpdate?.()), this.update(e)) : this._$EU();
    } catch (r) {
      throw t = !1, this._$EU(), r;
    }
    t && this._$AE(e);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    this._$EO?.forEach((e) => e.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    this._$Ej &&= this._$Ej.forEach((e) => this._$EC(e, this[e])), this._$EU();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
}
D.elementStyles = [], D.shadowRootOptions = { mode: "open" }, D[et("elementProperties")] = /* @__PURE__ */ new Map(), D[et("finalized")] = /* @__PURE__ */ new Map(), Br?.({ ReactiveElement: D }), (Et.reactiveElementVersions ??= []).push("2.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Hr = { attribute: !0, type: String, converter: vt, reflect: !1, hasChanged: qt }, Vr = (i = Hr, t, e) => {
  const { kind: r, metadata: s } = e;
  let o = globalThis.litPropertyMetadata.get(s);
  if (o === void 0 && globalThis.litPropertyMetadata.set(s, o = /* @__PURE__ */ new Map()), o.set(e.name, i), r === "accessor") {
    const { name: n } = e;
    return { set(a) {
      const d = t.get.call(this);
      t.set.call(this, a), this.requestUpdate(n, d, i);
    }, init(a) {
      return a !== void 0 && this.P(n, void 0, i), a;
    } };
  }
  if (r === "setter") {
    const { name: n } = e;
    return function(a) {
      const d = this[n];
      t.call(this, a), this.requestUpdate(n, d, i);
    };
  }
  throw Error("Unsupported decorator location: " + r);
};
function p(i) {
  return (t, e) => typeof e == "object" ? Vr(i, t, e) : ((r, s, o) => {
    const n = s.hasOwnProperty(o);
    return s.constructor.createProperty(o, n ? { ...r, wrapped: !0 } : r), n ? Object.getOwnPropertyDescriptor(s, o) : void 0;
  })(i, t, e);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function P(i) {
  return p({ ...i, state: !0, attribute: !1 });
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let y = class extends D {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    const t = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t.firstChild, t;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = xr(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this._$Do?.setConnected(!0);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._$Do?.setConnected(!1);
  }
  render() {
    return x;
  }
};
y._$litElement$ = !0, y.finalized = !0, globalThis.litElementHydrateSupport?.({ LitElement: y });
const qr = globalThis.litElementPolyfillSupport;
qr?.({ LitElement: y });
(globalThis.litElementVersions ??= []).push("4.0.4");
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Wr = "multipart-input-", le = (i) => i.type == "array" && i.format == "multipart", Oe = (i) => `${Wr}${i}`, Yr = (i, t) => new Ie(Oe(t)), Fr = async (i, t) => await i.querySelector(`#${Oe(t)}`)?.getValue();
class Ie extends HTMLElement {
  constructor(t) {
    super(), this.id = t;
    const e = this.attachShadow({ mode: "open" });
    e.innerHTML = `<style>
          :host {
            width: 100%;
            display: grid;
            grid-template-columns: 1fr 1fr;
            column-gap: calc(var(--bb-grid-size) * 2);
            flex-direction: column;
            flex: 1;
            position: relative;
          }

          * {
            white-space: initial;
          }

          textarea {
            width: var(--bb-input-width, 80%);
          }

          #controls {
            position: absolute;
            top: -32px;
            right: 40px;
            height: 24px;
          }

          button {
            cursor: pointer;
            background-color: transparent;
            margin-left: calc(var(--bb-grid-size) * 2);
            padding-left: calc(var(--bb-grid-size) * 5);
            border: none;
            position: relative;
            z-index: 1;
            height: 25px;
            transition: opacity var(--bb-easing-duration-out) var(--bb-easing);
            opacity: 0.5;
            font-size: 0;
          }

          button:hover {
            transition: opacity var(--bb-easing-duration-in) var(--bb-easing);
            opacity: 1;
          }

          button::before {
            content: '';
            width: 24px;
            height: 24px;
            background: red;
            position: absolute;
            left: calc(var(--bb-grid-size) * 1);
            top: 0;
            pointer-events: none;
          }

          #add-text::before {
            background: var(--bb-icon-add-note) center center no-repeat;
          }

          #add-image::before {
            background: var(--bb-icon-add-photo) center center no-repeat;
          }

          @media (min-width: 910px) {
            button {
              font-size: var(--bb-text-medium);
              padding-left: calc(var(--bb-grid-size) * 8);
            }
          }

          ::slotted(.full-width) {
            grid-column: 1 / 5;
          }

      </style>
      <div id="controls">
        <button id="add-text">Add text</button>
        <button id="add-image">Add image</button>
      </div>
      <slot name="text"></slot>
      <slot name="image"></slot>`;
    const r = () => {
      const s = new Me();
      s.classList.add("full-width"), s.slot = "text", this.append(s);
    };
    e.querySelector("#add-text")?.addEventListener("click", r), e.querySelector("#add-image")?.addEventListener("click", () => {
      const s = new Le();
      s.classList.add("reserved"), s.slot = "image", this.append(s);
    }), r();
  }
  async getValue() {
    const t = [], e = [], r = [];
    return await Promise.all(Array.from(this.children).map(async (s) => {
      const o = await s.getData();
      t.push(o.value), e.push(o.html), r.push(o.type);
    })), { value: t, html: e, type: r };
  }
}
class Ue extends HTMLElement {
  constructor() {
    super();
    const t = this.attachShadow({ mode: "open" });
    t.innerHTML = `
      <style>
        :host {
          display: flex;
          width: 100%;
          position: relative;
          margin-bottom: calc(var(--bb-grid-size) * 2);
          min-height: calc(var(--bb-grid-size) * 32);
        }

        :host(.reserved) {
          border-radius: calc(var(--bb-grid-size) * 8);
          background: rgb(255, 255, 255);
          border: 1px solid rgb(209, 209, 209);
        }

        :host(.pending)::before {
          content: '';
          width: calc(100% - var(--bb-grid-size) * 12);
          height: calc(var(--bb-grid-size) * 31);
          margin: calc(var(--bb-grid-size) * 2);
          border-radius: calc(var(--bb-grid-size) * 6);
          background: rgb(240, 240, 240);
          box-sizing: border-box;
        }

        * {
          box-sizing: border-box;
        }

        #delete {
          width: 2rem;
          height: 2rem;
          cursor: pointer;
        }

        button {
          border: none;
          background-color: transparent;
        }

        .multiline {
          grid-column: 1 / 5;
          flex: 1;
          width: 100%;
          overflow: hidden;
          border-radius: calc(var(--bb-grid-size) * 10);
          border: 1px solid rgb(209, 209, 209);
          height: 100%;
        }

        textarea {
          resize: none;
          line-height: 1.4;
          border: none;
          width: 100%;
          height: 100%;
          border-radius: calc(var(--bb-grid-size) * 10);
          background: rgb(255, 255, 255);
          min-height: calc(var(--bb-grid-size) * 12);
          padding: calc(var(--bb-grid-size) * 4) calc(var(--bb-grid-size) * 10) calc(var(--bb-grid-size) * 4) calc(var(--bb-grid-size) * 8);
        }

        img {
          width: calc(100% - 32px);
          height: calc(var(--bb-grid-size) * 36);
          padding: calc(var(--bb-grid-size) * 2);
          border-radius: calc(var(--bb-grid-size) * 8);
          object-fit: cover;
          aspect-ratio: auto;
        }

        #delete {
          position: absolute;
          top: 50%;
          right: calc(var(--bb-grid-size) * 2);
          background: rgb(255, 255, 255);
          border-radius: 50%;
          background: var(--bb-icon-delete) center center no-repeat;
          font-size: 0;
          translate: 0 -50%;
        }
      </style>
      <button id="delete" title="Delete">Delete</button>
    `, t.querySelector("#delete")?.addEventListener("click", () => {
      this.remove();
    });
  }
}
class Le extends Ue {
  #t;
  constructor() {
    super(), this.classList.add("pending");
    const t = document.createElement("input");
    t.type = "file", t.accept = "image/png, image/jpeg", t.addEventListener("change", () => {
      if (!t?.files?.length)
        return;
      const e = document.createElement("img");
      this.#t = t.files[0], e.src = URL.createObjectURL(this.#t), this.shadowRoot?.prepend(e), this.classList.remove("pending");
    }), t.addEventListener("cancel", () => {
      this.remove();
    }), t.click();
  }
  async getData() {
    if (!this.#t)
      throw new Error("Improperly initialized part input");
    const t = new FileReader();
    return new Promise((e) => {
      t.addEventListener("loadend", async () => {
        const r = t.result, s = document.createElement("img");
        s.src = r;
        const o = r.slice(r.indexOf(",") + 1);
        e({
          value: {
            inline_data: { mime_type: "image/png", data: o }
          },
          html: s,
          type: "image"
        });
      }), this.#t && t.readAsDataURL(this.#t);
    });
  }
}
class Me extends Ue {
  constructor() {
    super();
    const t = document.createElement("div");
    t.classList.add("multiline");
    const e = t.appendChild(document.createElement("textarea"));
    e.placeholder = "Enter your text", e.required = !0, this.shadowRoot?.prepend(t);
  }
  async getData() {
    const t = this.shadowRoot?.querySelector("textarea");
    if (!t)
      throw new Error("Improperly initialized part input");
    const e = t.value, r = document.createElement("div");
    return r.textContent = e, { value: { text: e }, html: r, type: "string" };
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class zt extends Event {
  static {
    this.eventName = "breadboardstart";
  }
  constructor(t) {
    super(zt.eventName, {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }), this.url = t;
  }
}
var B;
(function(i) {
  i.INFORMATION = "information", i.WARNING = "warning", i.ERROR = "error";
})(B || (B = {}));
class ut extends Event {
  static {
    this.eventName = "breadboardtoast";
  }
  constructor(t, e) {
    super(ut.eventName, {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }), this.message = t, this.toastType = e;
  }
}
class De extends Event {
  static {
    this.eventName = "breadboarddelay";
  }
  constructor(t) {
    super(De.eventName, {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }), this.duration = t;
  }
}
class Wt extends Event {
  static {
    this.eventName = "breadboardnodeselect";
  }
  constructor(t) {
    super(Wt.eventName, {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }), this.id = t;
  }
}
class yt extends Event {
  static {
    this.eventName = "breadboardinputenter";
  }
  constructor(t, e) {
    super(yt.eventName, {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }), this.id = t, this.data = e;
  }
}
class je extends Event {
  static {
    this.eventName = "breadboardboardunload";
  }
  constructor() {
    super(je.eventName, {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    });
  }
}
class Yt extends Event {
  static {
    this.eventName = "breadboardmessagetraversal";
  }
  constructor(t) {
    super(Yt.eventName, {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }), this.index = t;
  }
}
class Be extends Event {
  static {
    this.eventName = "breadboardresume";
  }
  constructor() {
    super(Be.eventName, {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    });
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function J(i) {
  if (i === null)
    throw new Error("There is no shadow root");
}
function Zr(i) {
  if (!(i instanceof HTMLElement))
    throw new Error("Element is not HTMLElement");
}
function ce(i) {
  if (!(i instanceof SVGElement))
    throw new Error("Element is not HTMLElement");
}
function he(i) {
  if (!(i instanceof PointerEvent))
    throw new Error("Not a pointer event");
}
function Kr(i) {
  if (!(i instanceof WheelEvent))
    throw new Error("Not a wheel event");
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Gr = `.node.active > * {
  stroke-width: 4px;
  stroke: #4CE8F6 !important;
}

.node.default > * {
  stroke: #ffab40;
  fill: #fff2ccff;
  color: #000;
}

.node.secrets > * {
  stroke: #db4437;
  fill: #f4cccc;
}

.node.input > * {
  stroke: #3c78d8;
  fill: #c9daf8ff;
}

.node.output > * {
  stroke: #38761d;
  fill: #b6d7a8ff;
}

.node.passthrough {
  stroke: #a64d79;
  fill: #ead1dcff;
}

.node.slot {
  stroke: #a64d79;
  fill: #ead1dcff;
}

.node.slotted {
  stroke: #a64d79;
}
`;
var v;
(function(i) {
  i[i.SELECT = 0] = "SELECT", i[i.PAN = 1] = "PAN", i[i.ZOOM_IN = 2] = "ZOOM_IN", i[i.ZOOM_OUT = 3] = "ZOOM_OUT";
})(v || (v = {}));
class Jr extends HTMLElement {
  #t = v.SELECT;
  #e = { x: Number.NaN, y: Number.NaN };
  #i = { x: "50%", y: "50%" };
  #s = { w: Number.NaN, h: Number.NaN };
  #r = { w: Number.NaN, h: Number.NaN };
  #o = 0.85;
  #d = !1;
  #n = { x: 0, y: 0 };
  #a = { ...this.#e };
  constructor() {
    super();
    const t = this.attachShadow({ mode: "open" });
    J(t), t.innerHTML = `
      <style>
        :host {
          background-color: rgb(244, 247, 252);
          background-image: var(--bb-grid-pattern);
          background-position: var(--diagram-x, 0) var(--diagram-y, 0);
          overflow: auto;
          position: relative;
          user-select: none;
          pointer-events: auto;
          width: 100%;
        }

        :host(.pan) {
          cursor: grab;
        }

        :host(.zoom-in) {
          cursor: zoom-in;
        }

        :host(.zoom-out) {
          cursor: zoom-out;
        }

        svg {
          display: block;
          pointer-events: none;
        }

        :host(.select) svg g {
          pointer-events: auto;
          cursor: pointer;
        }

        #mermaid {
          width: 100%;
          height: 100%;
        }

        #controls {
          width: calc(var(--bb-grid-size) * 8);
          position: absolute;
          top: calc(var(--bb-grid-size) * 4);
          left: calc(var(--bb-grid-size) * 4);
          padding: calc(var(--bb-grid-size) * 0.5);
          background: rgb(255, 255, 255);
          border: 1px solid rgb(237, 237, 237);
          border-radius: calc(var(--bb-grid-size) * 2);
          cursor: auto;
          z-index: 1;
        }

        #controls > button {
          width: 32px;
          height: 32px;
          font-size: 0;
          border-radius: calc(var(--bb-grid-size) * 1.5);
          border: none;
          background-color: rgb(255, 255, 255);
          background-position: center center;
          background-repeat: no-repeat;
          opacity: 0.5;
          display: block;
          margin-top: 4px;
          cursor: pointer;
        }

        #controls > button:first-of-type {
          margin-top: 0;
        }

        #controls > button#select {
          background-image: var(--bb-icon-arrow);
        }

        #controls > button#pan {
          background-image: var(--bb-icon-pan);
        }

        #controls > button#zoom-in {
          background-image: var(--bb-icon-zoom-in);
        }

        #controls > button#zoom-out {
          background-image: var(--bb-icon-zoom-out);
        }

        #controls > button#fit {
          background-image: var(--bb-icon-fit);
        }

        #controls > button:hover,
        #controls > button.active {
          background-color: rgb(230, 241, 242);
          opacity: 1;
        }
      </style>
      <div id="controls">
        <button id="select" title="Select">Select</button>
        <button id="pan" title="Pan">Pan</button>
        <button id="zoom-in" title="Zoom In">Zoom In</button>
        <button id="zoom-out" title="Zoom Out">Zoom Out</button>
        <button id="fit" title="Fit to Screen">Fit to Screen</button>
      </div>
      <div id="mermaid"></div>
    `, this.reset(), this.#p(), this.#m(), this.addEventListener("pointerdown", (r) => this.#l(r)), this.addEventListener("pointermove", (r) => {
      this.#g(r);
    }), document.body.addEventListener("pointerup", () => {
      this.#v();
    });
    let e = null;
    document.body.addEventListener("keydown", (r) => {
      r.code !== "Space" || e !== null || (e = this.#t, this.#t = v.PAN, this.#m());
    }), document.body.addEventListener("keyup", (r) => {
      r.code !== "Space" || e === null || (this.#t = e, e = null, this.#p(), this.#m());
    }), t.addEventListener("click", (r) => this.#h(r)), this.addEventListener("mousewheel", (r) => this.#c(r)), window.addEventListener("resize", () => this.#f());
  }
  #c(t) {
    Kr(t), t.preventDefault(), this.#o *= 1 + t.deltaY / 200, this.#u(), this.#b();
  }
  #u() {
    this.#o < 0.1 ? this.#o = 0.1 : this.#o > 10 && (this.#o = 10);
  }
  #h(t) {
    const e = t.composedPath()[0];
    if (e instanceof HTMLButtonElement) {
      switch (e.id) {
        case "select":
          this.#t = v.SELECT;
          break;
        case "pan":
          this.#t = v.PAN;
          break;
        case "zoom-in":
          this.#t = v.ZOOM_IN;
          break;
        case "zoom-out":
          this.#t = v.ZOOM_OUT;
          break;
        case "fit": {
          this.#o = 0.85, this.#e.x = 0, this.#e.y = 0, this.#t = v.PAN, this.#b();
          break;
        }
        default:
          this.#t === v.ZOOM_IN ? this.#o *= 1.2 : this.#t === v.ZOOM_OUT && (this.#o *= 0.8), this.#u(), this.#b();
          break;
      }
      this.#p(), this.#m();
    } else if (this.#t === v.SELECT) {
      for (const r of t.composedPath())
        if (r instanceof SVGElement && r.classList.contains("node")) {
          const s = r.querySelector(".nodeLabel");
          if (!s || !s.textContent)
            break;
          const o = s.textContent.replace(/.*?id='(.*?)'.*?/gim, "$1");
          this.dispatchEvent(new Wt(o));
        }
    }
  }
  #l(t) {
    this.#d = !0, this.#p(), he(t), this.#n.x = t.clientX, this.#n.y = t.clientY, this.#a.x = this.#e.x, this.#a.y = this.#e.y;
  }
  #g(t) {
    !this.#d || this.#t !== v.PAN || (he(t), this.setPointerCapture(t.pointerId), this.#e.x = this.#a.x - (t.clientX - this.#n.x), this.#e.y = this.#a.y - (t.clientY - this.#n.y), this.#b());
  }
  #v() {
    this.#d = !1, this.#n.x = 0, this.#n.y = 0;
  }
  #f() {
    const t = this.shadowRoot;
    J(t);
    const e = t.querySelector("svg");
    e && (this.#r.w = e.clientWidth, this.#r.h = e.clientHeight, this.#b());
  }
  #p() {
    const t = this.shadowRoot;
    J(t);
    const e = t.querySelector("#controls");
    Zr(e);
    const r = Array.from(e.querySelectorAll("button"));
    for (const n of r)
      n.classList.remove("active");
    let s = "#select";
    switch (this.#t) {
      case v.SELECT:
        s = "#select";
        break;
      case v.PAN:
        s = "#pan";
        break;
      case v.ZOOM_IN:
        s = "#zoom-in";
        break;
      case v.ZOOM_OUT:
        s = "#zoom-out";
        break;
    }
    const o = t.querySelector(s);
    o && o.classList.add("active");
  }
  #m() {
    switch (this.#t) {
      case v.SELECT:
        this.classList.remove("pan", "zoom-in", "zoom-out"), this.classList.add("select");
        break;
      case v.PAN:
        this.classList.remove("select", "zoom-in", "zoom-out"), this.classList.add("pan");
        break;
      case v.ZOOM_IN:
        this.classList.remove("select", "pan", "zoom-out"), this.classList.add("zoom-in");
        break;
      case v.ZOOM_OUT:
        this.classList.remove("select", "pan", "zoom-in"), this.classList.add("zoom-out");
        break;
    }
  }
  #b() {
    const t = this.shadowRoot;
    J(t);
    const e = t.querySelector("svg");
    if (!e || !e?.getAttribute("viewBox"))
      return;
    const s = this.#s.w, o = this.#s.h;
    if (this.#r.w === 0 || this.#r.h === 0)
      return;
    const n = e.querySelector("g");
    ce(n), n.style.transformOrigin = `${this.#i.x} ${this.#i.y}`, n.style.transform = `scale(${this.#o}, ${this.#o})`;
    const a = Math.min(this.#r.w / s, this.#r.h / o), d = `${this.#e.x / a} ${this.#e.y / a} ${s} ${o}`;
    e.setAttribute("viewBox", d), this.style.setProperty("--diagram-x", `${-this.#e.x}px`), this.style.setProperty("--diagram-y", `${-this.#e.y}px`);
  }
  #y() {
    const t = this.shadowRoot;
    J(t);
    const e = t.querySelector("svg");
    if (!e)
      return;
    const r = e?.getAttribute("viewBox");
    if (!r)
      return;
    const [, , s, o] = r.split(" ").map((n) => parseFloat(n) || 0);
    this.#s.w = s, this.#s.h = o;
  }
  #$() {
    this.#e.x = 0, this.#e.y = 0;
  }
  async render(t, e) {
    if (typeof t != "string") {
      if (!t.diagram)
        throw new Error("No diagram string provided");
      t = t.diagram;
    }
    e = e.replace(/-/g, ""), e && (t += `
class ${e} active`);
    const { default: r } = await import("./mermaid.core-zryH3lCi.js").then((d) => d.b4);
    r.initialize({ startOnLoad: !1, themeCSS: Gr });
    const { svg: s } = await r.render("graphDiv", t), o = this.shadowRoot;
    if (!o)
      throw new Error("Unable to find shadow root");
    const n = o.querySelector("#mermaid");
    if (!n)
      return;
    n.innerHTML = s;
    const a = o.querySelector("svg");
    ce(a), a.removeAttribute("style"), a.setAttribute("width", "100%"), a.setAttribute("height", "100%"), a.setAttribute("preserveAspectRatio", "xMidYMid"), (Number.isNaN(this.#s.w) || Number.isNaN(this.#s.h)) && this.#y(), (Number.isNaN(this.#e.x) || Number.isNaN(this.#e.y)) && this.#$(), (Number.isNaN(this.#r.w) || Number.isNaN(this.#r.h)) && this.#f(), this.#b();
  }
  reset() {
    this.#t = v.SELECT, this.#e.x = Number.NaN, this.#e.y = Number.NaN, this.#s.w = Number.NaN, this.#s.w = Number.NaN, this.#r.w = Number.NaN, this.#r.h = Number.NaN, this.#o = 0.85, this.#i.x = "50%", this.#i.y = "50%";
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var j;
(function(i) {
  i.DONE = "done", i.ERROR = "error", i.INPUT = "input", i.LOAD = "load", i.OUTPUT = "output", i.NODESTART = "nodestart", i.NODEEND = "nodeend", i.SECRETS = "secrets", i.GRAPHSTART = "graphstart", i.GRAPHEND = "graphend";
})(j || (j = {}));
var $t;
(function(i) {
  i.RUNNING = "running", i.PAUSED = "paused", i.STOPPED = "stopped";
})($t || ($t = {}));
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
class Xr {
  constructor(t) {
    this.Y = t;
  }
  disconnect() {
    this.Y = void 0;
  }
  reconnect(t) {
    this.Y = t;
  }
  deref() {
    return this.Y;
  }
}
let Qr = class {
  constructor() {
    this.Z = void 0, this.q = void 0;
  }
  get() {
    return this.Z;
  }
  pause() {
    this.Z ??= new Promise((t) => this.q = t);
  }
  resume() {
    this.q?.(), this.Z = this.q = void 0;
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ue = (i) => !kr(i) && typeof i.then == "function", pe = 1073741823;
let ti = class extends Ce {
  constructor() {
    super(...arguments), this._$Cwt = pe, this._$Cbt = [], this._$CK = new Xr(this), this._$CX = new Qr();
  }
  render(...t) {
    return t.find((e) => !ue(e)) ?? x;
  }
  update(t, e) {
    const r = this._$Cbt;
    let s = r.length;
    this._$Cbt = e;
    const o = this._$CK, n = this._$CX;
    this.isConnected || this.disconnected();
    for (let a = 0; a < e.length && !(a > this._$Cwt); a++) {
      const d = e[a];
      if (!ue(d))
        return this._$Cwt = a, d;
      a < s && d === r[a] || (this._$Cwt = pe, s = 0, Promise.resolve(d).then(async (h) => {
        for (; n.get(); )
          await n.get();
        const u = o.deref();
        if (u !== void 0) {
          const c = u._$Cbt.indexOf(d);
          c > -1 && c < u._$Cwt && (u._$Cwt = c, u.setValue(h));
        }
      }));
    }
    return x;
  }
  disconnected() {
    this._$CK.disconnect(), this._$CX.pause();
  }
  reconnected() {
    this._$CK.reconnect(this), this._$CX.resume();
  }
};
const Ft = M(ti);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var T = function(i, t, e, r) {
  var s = arguments.length, o = s < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, n;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(i, t, e, r);
  else
    for (var a = i.length - 1; a >= 0; a--)
      (n = i[a]) && (o = (s < 3 ? n(o) : s > 3 ? n(t, e, o) : n(t, e)) || o);
  return s > 3 && o && Object.defineProperty(t, e, o), o;
};
let wt = class extends y {
  constructor() {
    super(...arguments), this.boards = [], this.bootWithUrl = null;
  }
  static {
    this.styles = w`
    :host {
      display: block;
      container-type: inline-size;
    }

    #boards {
      margin: 32px;
      display: grid;
      grid-template-columns: auto;
      column-gap: calc(var(--bb-grid-size) * 6);
      row-gap: calc(var(--bb-grid-size) * 6);
    }

    @container (min-width: 640px) {
      #boards {
        grid-template-columns: auto auto;
      }
    }

    @container (min-width: 1040px) {
      #boards {
        grid-template-columns: auto auto auto;
      }
    }

    @container (min-width: 1440px) {
      #boards {
        grid-template-columns: auto auto auto auto;
      }
    }

    @container (min-width: 1840px) {
      #boards {
        grid-template-columns: auto auto auto auto auto;
      }
    }

    @container (min-width: 2240px) {
      #boards {
        grid-template-columns: auto auto auto auto auto auto;
      }
    }
  `;
  }
  render() {
    return l`<div id="boards">
      ${this.boards.map((t) => l`<bb-board-item
          .boardTitle=${t.title}
          .boardVersion=${t.version}
          .boardUrl=${t.url}
        ></bb-board-item>`)}
    </div>`;
  }
  firstUpdated() {
    this.bootWithUrl && this.dispatchEvent(new zt(this.bootWithUrl));
  }
};
T([
  p()
], wt.prototype, "boards", void 0);
T([
  p()
], wt.prototype, "bootWithUrl", void 0);
wt = T([
  $("bb-board-list")
], wt);
let H = class extends y {
  constructor() {
    super(...arguments), this.boardTitle = null, this.boardDescription = null, this.boardUrl = null, this.boardVersion = null, this.#t = !1;
  }
  #t;
  static {
    this.styles = w`
    :host {
      display: block;
      position: relative;
    }

    div {
      display: flex;
      height: 100%;
      flex-direction: column;
    }

    div > a {
      flex: 1;
      display: block;
      box-sizing: border-box;
      text-decoration: none;
      padding: calc(var(--bb-grid-size) * 7) calc(var(--bb-grid-size) * 5);
      border-radius: calc(var(--bb-grid-size) * 3);
      background: rgb(255, 255, 255);
      border: 1px solid rgb(233, 233, 233);
      transition: all 0.3s cubic-bezier(0, 0, 0.3, 1);
    }

    div > a:hover {
      background: rgb(113, 106, 162);
      border: 1px solid rgb(88, 79, 138);
      box-shadow: 0 2px 7px 0 rgba(0, 0, 0, 0.14),
        0 13px 27px 0 rgba(0, 0, 0, 0.23);
      transition: all 0.15s cubic-bezier(0, 0, 0.3, 1);
    }

    h1 {
      font-size: var(--bb-text-large);
      color: rgb(57, 57, 57);
      margin: 0;
      max-width: 80%;
    }

    h2 {
      font-size: var(--bb-text-medium);
      color: rgb(57, 57, 57);
      margin: calc(var(--bb-grid-size) * 2)) 0 0 0;
    }

    p {
      font-size: var(--bb-text-small);
      color: rgb(57, 57, 57);
      line-height: 1.5;
      margin: calc(var(--bb-grid-size) * 6) 0;
    }

    :hover h1,
    :hover h2,
    :hover p,
    :hover a {
      color: #fff;
    }

    #copy-to-clipboard {
      width: 32px;
      height: 32px;
      font-size: 0;
      display: inline-block;
      background: var(--bb-icon-copy-to-clipboard) center center no-repeat;
      vertical-align: middle;
      border: none;
      cursor: pointer;
      transition: opacity var(--bb-easing-duration-out) var(--bb-easing);
      opacity: 0.5;
      position: absolute;
      top: 16px;
      right: 16px;
      border-radius: 50%;
    }

    #copy-to-clipboard:hover {
      background-color: #ffffffcc;
      transition: opacity var(--bb-easing-duration-in) var(--bb-easing),
        background-color var(--bb-easing-duration-in) var(--bb-easing);
      opacity: 1;
    }
  `;
  }
  #e(t) {
    const e = [];
    let r = 0;
    for (const o of t.matchAll(/\[(.*?)\]\((.*?)\)/gim)) {
      const n = o.index;
      if (n === void 0)
        continue;
      const a = t.slice(r, n);
      e.push(a);
      const [d, h, u] = o;
      e.push(l`<a href="${u}">${h}</a>`), r = n + d.length;
    }
    const s = t.slice(r);
    return e.push(s), e;
  }
  async #i() {
    if (!this.boardUrl || !this.boardTitle)
      return Promise.resolve("Unable to load description");
    const e = await (await fetch(this.boardUrl)).json();
    return this.#e(e.description || "No description");
  }
  async #s(t) {
    if (this.#t || !this.boardUrl)
      return;
    t.stopImmediatePropagation(), t.preventDefault(), this.#t = !0;
    const e = new URL(window.location.href);
    e.searchParams.set("board", this.boardUrl), await navigator.clipboard.writeText(e.toString()), this.dispatchEvent(new ut("Board URL copied to clipboard", B.INFORMATION)), this.#t = !1;
  }
  #r(t) {
    if (t.preventDefault(), !this.boardUrl) {
      console.warn("No board URL");
      return;
    }
    this.dispatchEvent(new zt(this.boardUrl));
  }
  render() {
    return l`<div>
      <a @click=${this.#r} href="?board=${this.boardUrl}">
        <button
          id="copy-to-clipboard"
          @click=${this.#s}
          title="Copy board URL"
        >
          Copy board URL
        </button>
        <h1>${this.boardTitle}</h1>
        <h2>${this.boardVersion || "Unversioned"}</h2>
        <p>${Ft(this.#i(), l`Loading...`)}</p>
      </a>
    </div>`;
  }
};
T([
  p()
], H.prototype, "boardTitle", void 0);
T([
  P()
], H.prototype, "boardDescription", void 0);
T([
  p()
], H.prototype, "boardUrl", void 0);
T([
  p()
], H.prototype, "boardVersion", void 0);
H = T([
  $("bb-board-item")
], H);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var St = function(i, t, e, r) {
  var s = arguments.length, o = s < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, n;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(i, t, e, r);
  else
    for (var a = i.length - 1; a >= 0; a--)
      (n = i[a]) && (o = (s < 3 ? n(o) : s > 3 ? n(t, e, o) : n(t, e)) || o);
  return s > 3 && o && Object.defineProperty(t, e, o), o;
};
let V = class extends y {
  constructor() {
    super(...arguments), this.type = "image/png", this.error = "", this.strokeColor = "#333333", this.#t = !1, this.#e = N(), this.#i = { x: 0, y: 0 }, this.#s = { x: 0, y: 0 }, this.#r = { w: 0, h: 0 }, this.#o = this.#c.bind(this);
  }
  #t;
  #e;
  #i;
  #s;
  #r;
  #o;
  static {
    this.styles = w`
    :host {
      --default-bb-box-shadow: 0 6px 9px 0 rgba(0, 0, 0, 0.12),
        0 2px 3px 0 rgba(0, 0, 0, 0.23);
      --default-bb-border-radius: 8px;
      --default-bb-input-background-color: #fff;

      position: relative;
      display: block;
      width: 100%;
      background-color: var(
        --bb-input-background-color,
        var(--default-bb-input-background-color)
      );
      box-shadow: var(--bb-box-shadow, var(--default-bb-box-shadow));
      border-radius: var(--bb-border-radius, var(--default-bb-border-radius));
      aspect-ratio: 4/3;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      opacity: 0;
      border-radius: var(--bb-border-radius, var(--default-bb-border-radius));
      animation: fadeIn 0.3s cubic-bezier(0, 0, 0.3, 1) both;
      animation-delay: 0.3s;
    }

    canvas.active {
      animation: fadeIn 0.3s cubic-bezier(0, 0, 0.3, 1) both;
      animation-delay: 0.3s;
    }

    #controls {
      width: calc(var(--bb-grid-size) * 8);
      position: absolute;
      top: calc(var(--bb-grid-size) * 4);
      left: calc(var(--bb-grid-size) * 4);
      padding: calc(var(--bb-grid-size) * 0.5);
      background: rgb(255, 255, 255);
      border: 1px solid rgb(237, 237, 237);
      border-radius: calc(var(--bb-grid-size) * 2);
      cursor: auto;
      z-index: 1;
    }

    #controls > button#reset-image {
      background-image: var(--bb-icon-reset-image);
    }

    #controls > button:first-child {
      margin-top: 0px;
    }

    #color-input,
    #controls > button {
      width: 32px;
      height: 32px;
      font-size: 0;
      border-radius: calc(var(--bb-grid-size) * 1.5);
      border: none;
      background: none;
      display: block;
      margin-top: 4px;
      cursor: pointer;
    }

    #controls > button {
      background-color: rgb(255, 255, 255);
      background-position: center center;
      background-repeat: no-repeat;
      opacity: 0.5;
    }

    #controls > button:hover,
    #controls > button.active {
      background-color: rgb(230, 241, 242);
      opacity: 1;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }
  `;
  }
  connectedCallback() {
    super.connectedCallback(), window.addEventListener("resize", this.#o);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), window.removeEventListener("resize", this.#o);
  }
  #d(t) {
    t.target instanceof HTMLInputElement && (this.strokeColor = t.target.value);
  }
  #n() {
    if (!this.#e.value)
      return;
    const t = this.#e.value.getContext("2d");
    t && (t.fillStyle = "#FFF", t.fillRect(0, 0, this.#r.w, this.#r.h));
  }
  #a() {
    this.#n();
  }
  #c() {
    if (!this.#e.value)
      return;
    const t = this.#e.value, e = t.getContext("2d", { willReadFrequently: !0 });
    if (!e)
      return;
    let { width: r, height: s } = t.getBoundingClientRect();
    r = Math.floor(r), s = Math.floor(s);
    let o = null;
    this.#r.w !== 0 && this.#r.h !== 0 && (o = e.getImageData(0, 0, this.#r.w, this.#r.h)), t.width = r, t.height = s, this.#r.w = r, this.#r.h = s, this.#n(), o !== null && e.putImageData(o, 0, 0);
  }
  #u(t) {
    if (!this.#e.value)
      return;
    const e = this.#e.value, r = e.getContext("2d", { willReadFrequently: !0 });
    if (!r || t.composedPath()[0] !== e)
      return;
    const s = e.getBoundingClientRect(), { x: o, y: n } = s, a = Math.floor(s.width), d = Math.floor(s.height);
    (this.#r.w !== a || this.#r.h !== d) && this.#c(), e.setPointerCapture(t.pointerId), this.#t = !0, this.#i.x = o, this.#i.y = n, r.strokeStyle = this.strokeColor, r.lineCap = "round", r.lineWidth = 3;
    const h = t.pageX - this.#i.x + window.scrollX, u = t.pageY - this.#i.y - window.scrollY;
    r.beginPath(), r.moveTo(h, u), this.#s.x = h, this.#s.y = u;
  }
  #h() {
    if (!this.#t || (this.#t = !1, !this.#e.value))
      return;
    const e = this.#e.value.getContext("2d", { willReadFrequently: !0 });
    e && e.closePath();
  }
  #l(t) {
    if (!this.#t || !this.#e.value)
      return;
    const r = this.#e.value.getContext("2d", { willReadFrequently: !0 });
    if (!r)
      return;
    r.moveTo(this.#s.x, this.#s.y);
    const s = t.pageX - this.#i.x + window.scrollX, o = t.pageY - this.#i.y - window.scrollY;
    r.lineTo(s, o), r.stroke(), this.#s.x = s, this.#s.y = o;
  }
  get value() {
    const t = { inline_data: { data: "", mime_type: this.type } }, e = this.#e.value?.toDataURL(this.type, 80);
    if (!e)
      return t;
    const r = `data:${this.type};base64,`;
    return t.inline_data.data = e.substring(r.length), t;
  }
  set value(t) {
    console.warn("Value set on drawable, but values are not supported");
  }
  render() {
    return this.error ? l`${this.error}` : l`<div id="controls">
        <button @click=${this.#a} id="reset-image">Reset image</button>
        <input
          @input=${this.#d}
          type="color"
          id="color-input"
          value="${this.strokeColor}"
        />
      </div>
      <canvas
        @pointerdown=${this.#u}
        @pointermove=${this.#l}
        @pointerup=${this.#h}
        ${z(this.#e)}
      ></canvas>`;
  }
};
St([
  p()
], V.prototype, "type", void 0);
St([
  P()
], V.prototype, "error", void 0);
St([
  P()
], V.prototype, "strokeColor", void 0);
V = St([
  $("bb-drawable-input")
], V);
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const nt = M(class extends Y {
  constructor(i) {
    if (super(i), i.type !== At.ATTRIBUTE || i.name !== "class" || i.strings?.length > 2)
      throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(i) {
    return " " + Object.keys(i).filter((t) => i[t]).join(" ") + " ";
  }
  update(i, [t]) {
    if (this.st === void 0) {
      this.st = /* @__PURE__ */ new Set(), i.strings !== void 0 && (this.nt = new Set(i.strings.join(" ").split(/\s/).filter((r) => r !== "")));
      for (const r in t)
        t[r] && !this.nt?.has(r) && this.st.add(r);
      return this.render(t);
    }
    const e = i.element.classList;
    for (const r of this.st)
      r in t || (e.remove(r), this.st.delete(r));
    for (const r in t) {
      const s = !!t[r];
      s === this.st.has(r) || this.nt?.has(r) || (s ? (e.add(r), this.st.add(r)) : (e.remove(r), this.st.delete(r)));
    }
    return x;
  }
});
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ei = M(class extends Y {
  constructor() {
    super(...arguments), this.key = g;
  }
  render(i, t) {
    return this.key = i, t;
  }
  update(i, [t, e]) {
    return t !== this.key && (Pe(i), this.key = t), e;
  }
});
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const ri = w`
  :host {
    font-size: var(--bb-text-nano, 12px);
    position: relative;
    overflow: auto;
  }

  * {
    box-sizing: border-box;
  }

  #history-list {
    overflow-y: scroll;
    scrollbar-gutter: stable;
    height: 100%;
  }

  .empty {
    font-family: var(--bb-font-family);
    font-style: italic;
    color: #777;
  }

  table {
    width: 100%;
    min-width: 1px;
    padding: 0;
    margin: 0;
    table-layout: fixed;
    cursor: default;
  }

  thead,
  tr,
  td {
    padding: 0;
    margin: 0;
  }

  thead {
    position: sticky;
    top: 0;
    font-weight: bold;
    z-index: 1;
  }

  thead tr {
    height: calc(var(--bb-grid-size) * 6);
  }

  thead td:first-of-type {
    padding-left: calc(var(--bb-grid-size) * 11.5);
    width: calc(var(--bb-grid-size) * 35);
  }

  thead td:last-of-type {
    padding-right: calc(var(--bb-grid-size) * 5);
  }

  thead td {
    background: #fff;
    border-bottom: 1px solid #e3e3e3;
  }

  td {
    background: #fff;
    border-bottom: 1px solid #ebebeb;
    height: calc(var(--bb-grid-size) * 8);
    max-width: 100%;
    min-width: 1px;
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
    vertical-align: baseline;
    line-height: calc(var(--bb-grid-size) * 8);
    padding-right: calc(var(--bb-grid-size) * 1);
  }

  thead td.id,
  thead td.initiator {
    width: calc(var(--bb-grid-size) * 30);
  }

  tbody td.value {
    width: 100%;
    font-size: 0.95em;
    font-family: var(--bb-font-family-mono);
  }

  td:last-of-type {
    padding-right: calc(var(--bb-grid-size) * 5);
  }

  tbody tr[data-depth="0"].expanded td,
  tbody tr[data-depth="1"] td {
    background: var(--bb-depth-1);
  }

  tbody tr[data-depth="1"].expanded td,
  tbody tr[data-depth="2"] td {
    background: var(--bb-depth-2);
  }

  tbody tr[data-depth="2"].expanded td,
  tbody tr[data-depth="3"] td {
    background: var(--bb-depth-3);
  }

  tbody tr[data-depth="3"].expanded td,
  tbody tr[data-depth="4"] td {
    background: var(--bb-depth-4);
  }

  tbody tr:not([data-parent=""]) {
    display: none;
  }

  tbody tr:not([data-parent=""]).visible {
    display: table-row;
  }

  tr .toggle {
    width: 16px;
    height: 16px;
    display: inline-block;
    vertical-align: middle;
    position: relative;
    margin: 0 calc(var(--bb-grid-size) * 0.5) 0 calc(var(--bb-grid-size) * 1.5);
  }

  tr .marker {
    width: 8px;
    height: 100%;
    display: inline-block;
    vertical-align: middle;
    position: relative;
    margin: 0 calc(var(--bb-grid-size) * 2) 0 0;
  }

  tr .marker::after {
    content: "";
    width: 8px;
    height: 8px;
    border: 1px solid #666;
    background: #eee;
    border-radius: 50%;
    position: absolute;
    top: 50%;
    left: 50%;
    translate: -50% -50%;
    box-sizing: border-box;
  }

  tr .marker.nodeend::after {
    border: 1px solid hsl(33.6, 100%, 52.5%);
    background: hsl(44.7, 100%, 80%);
  }

  tr .marker.graphstart::after,
  tr .marker.graphend::after {
    background: rgb(110, 84, 139);
    border: 1px solid rgb(90, 64, 119);
  }

  tr .marker.error::after {
    background: #cc0000;
    border: 1px solid #cc0000;
  }

  tr .marker.result::after {
    background: #ffa500;
    border: 1px solid #ffa500;
  }

  tr .marker.input::after {
    background: #c9daf8ff;
    border: 1px solid #3c78d8;
  }

  tr .marker.secrets::after {
    background: #f4cccc;
    border: 1px solid #db4437;
  }

  tr .marker.output::after {
    background: #b6d7a8ff;
    border: 1px solid #38761d;
  }

  tr .marker.load::after,
  tr .marker.end::after {
    background: var(--bb-done-color);
    border: 1px solid var(--bb-done-color);
  }

  tr .marker.nodestart::after {
    background: radial-gradient(
        var(--bb-progress-color-faded) 0%,
        var(--bb-progress-color-faded) 60%,
        transparent 60%,
        transparent 100%
      ),
      conic-gradient(transparent 0deg, var(--bb-progress-color) 360deg),
      linear-gradient(
        var(--bb-progress-color-faded),
        var(--bb-progress-color-faded)
      );

    border: none;
    animation: rotate 0.5s linear infinite;
  }

  tr .marker::before {
    background: #dadada;
  }

  tr.children.expanded .marker::before,
  tr:not([data-parent=""]) .marker::before {
    content: "";
    width: 2px;
    height: calc(100% + 2px);
    position: absolute;
    top: -1px;
    left: 50%;
    translate: -50% 0;
    box-sizing: border-box;
  }

  tr[data-parent=""].children.expanded .marker::before {
    height: 50%;
    translate: -50% 100%;
  }

  tr:not(.children) .marker.nodestart::before,
  tr[data-depth="0"].last .marker:not(.nodestart)::before,
  tr[data-depth="1"].last .marker:not(.nodestart)::before {
    height: 50%;
  }

  tr.children .toggle {
    background: var(--bb-icon-expand) center center no-repeat;
    background-size: contain;
  }

  tr.children.expanded .toggle {
    background: var(--bb-icon-collapse) center center no-repeat;
    background-size: contain;
  }

  tr .toggle input {
    opacity: 0;
    margin: 0;
    vertical-align: top;
  }

  tbody tr:hover td {
    background: var(--bb-depth-1);
  }

  tbody tr[data-depth="1"]:hover td {
    background: var(--bb-depth-2);
  }

  tbody tr[data-depth="2"]:hover td {
    background: var(--bb-depth-3);
  }

  tbody tr[data-depth="3"]:hover td {
    background: var(--bb-depth-4);
  }

  tbody tr[data-depth="4"]:hover td {
    background: var(--bb-depth-5);
  }

  #selected {
    overflow: auto;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    position: absolute;
    z-index: 2;
    pointer-events: none;
  }

  #content {
    position: absolute;
    top: 0;
    right: 0;
    height: 100%;
    width: 80%;
    background: #fff;
    box-shadow: 0 0 3px 0 rgba(0, 0, 0, 0.24);
    display: flex;
    flex-direction: column;
    pointer-events: auto;
    overflow: auto;
  }

  #content header {
    position: sticky;
    top: 0;
    background: #fcfcfc;
    border-bottom: 1px solid #e3e3e3;
    height: calc(var(--bb-grid-size) * 6);
    line-height: calc(var(--bb-grid-size) * 6);
  }

  #content header #close {
    background: var(--bb-icon-close) center center no-repeat;
    background-size: contain;
    vertical-align: middle;
    width: 14px;
    height: 14px;
    font-size: 0;
    border: none;
    padding: 0;
    margin: 0 calc(var(--bb-grid-size) * 2);
  }

  #content #data {
    padding: calc(var(--bb-grid-size) * 2);
    padding-bottom: calc(var(--bb-grid-size) * 4);
    overflow-y: scroll;
    scrollbar-gutter: stable;
    box-sizing: border-box;
  }

  @keyframes rotate {
    from {
      transform: rotate(0);
    }

    to {
      transform: rotate(360deg);
    }
  }
`;
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var F = function(i, t, e, r) {
  var s = arguments.length, o = s < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, n;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(i, t, e, r);
  else
    for (var a = i.length - 1; a >= 0; a--)
      (n = i[a]) && (o = (s < 3 ? n(o) : s > 3 ? n(t, e, o) : n(t, e)) || o);
  return s > 3 && o && Object.defineProperty(t, e, o), o;
}, rt;
(function(i) {
  i.COLLAPSED = "collapsed", i.EXPANDED = "expanded";
})(rt || (rt = {}));
const bt = (i) => i.type === "nodestart" || i.type === "nodeend" || i.type === "graphstart" || i.type === "graphend", ii = (i) => i.type === "nodestart", X = (i, t) => {
  const e = t === "graphstart" || t === "graphend";
  return i.length == 0 && e ? t === "graphstart" ? "path-main-graph-start" : "path-main-graph-end" : `path-${i.join("-")}`;
}, si = (i) => i.type === "nodestart" || i.type === "nodeend" || i.type === "graphstart" || i.type === "graphend" || i.type === "end";
let L = class extends y {
  constructor() {
    super(...arguments), this.messages = null, this.messagePosition = 0, this.lastUpdate = Number.NaN, this.expandCollapseState = /* @__PURE__ */ new Map(), this.selected = null, this.#t = /* @__PURE__ */ new Map(), this.#e = /* @__PURE__ */ new Set(), this.#i = this.#s.bind(this);
  }
  #t;
  #e;
  #i;
  static {
    this.styles = ri;
  }
  #s(t) {
    t.key === "Escape" && (this.selected = null);
  }
  #r(t) {
    switch (t.type) {
      case "graphstart":
        return t.data.path.length > 0 ? "Inner board started" : "Board started";
      case "graphend":
        return t.data.path.length > 0 ? "Inner board finished" : "Board finished";
      case "error":
        return "Error";
      case "skip":
        return "Skip";
      case "end":
        return "Complete";
      case "input":
        return "Input";
      case "output":
        return "Output";
      case "secret":
        return "Secret";
      default:
        return t.data.node.type;
    }
  }
  #o(t) {
    return t.type === "nodestart" || t.type === "nodeend" ? t.data.node.id : "";
  }
  #d(t, e = void 0, r = "", s = !1, o = 0, n = !0) {
    let a;
    t.graphNodeData === null ? a = l`<span class="empty">(pending)</span>` : t.graphNodeData === void 0 ? a = l`<span class="empty">(none)</span>` : a = l`${JSON.stringify(t.graphNodeData)}`, t.type === j.NODESTART ? this.#e.add(t.id) : t.type === j.NODEEND && this.#e.delete(t.id), this.#t.set(t.guid, t);
    const d = this.expandCollapseState.has(t.id) ? this.expandCollapseState.get(t.id) === rt.EXPANDED : this.#e.has(t.id), h = this.#r(t), u = h.replaceAll(/\s/gim, "-").toLocaleLowerCase(), c = this.#o(t);
    return l`<tr
        class="${nt({
      expanded: d,
      visible: n,
      children: t.children.length > 0,
      last: s
    })}"
        id="${t.id || g}"
        data-parent="${r}"
        data-guid="${t.guid}"
        data-depth="${o}"
        @click="${this.#n}"
      >
        <td>
          <span class="toggle"
            >${t.children.length > 0 ? l`<input
                  @input=${this.#a}
                  value="${t.id}"
                  class="toggle"
                  type="checkbox"
                  ?checked=${d}
                />` : g}</span
          >
          <span
            class="${nt({
      marker: !0,
      [t.type]: !0,
      [u]: !0
    })}"
          ></span>
          ${h}
        </td>
        <td class="id">${c || l`<span class="empty">(none)</span>`}</td>
        <td class="initiator">
          ${e || l`<span class="empty">(none)</span>`}
        </td>
        <td class="value">${a}</td>
      </tr>
      ${t.children.map((f, b, m) => this.#d(f, c || e, t.id, b === m.length - 1, o + 1, n && d))}`;
  }
  #n(t) {
    if (!(t.target instanceof HTMLElement) || t.target.classList.contains("toggle"))
      return;
    let e, r = t.target;
    do {
      if (e = r.dataset.guid, e)
        break;
      r = r.parentElement;
    } while (r);
    e && (this.selected = this.#t.get(e) || null);
  }
  #a(t) {
    t.target instanceof HTMLInputElement && (this.expandCollapseState.set(t.target.value, t.target.checked ? rt.EXPANDED : rt.COLLAPSED), this.requestUpdate());
  }
  #c(t) {
    let e;
    t.graphNodeData === null ? e = l`<span class="empty">(pending)</span>` : t.graphNodeData === void 0 ? e = l`<span class="empty">(none)</span>` : e = l`${ei(this.lastUpdate, l`<bb-json-tree
          .json=${t.graphNodeData}
          autoExpand="true"
        ></bb-json-tree>`)}`;
    const r = this.#r(t), s = this.#o(t);
    return l`<div id="selected">
      <section id="content">
        <header>
          <button
            @click=${() => this.selected = null}
            id="close"
            title="Close"
          >
            Close</button
          >${r} ${s ? l`(${s})` : g}
        </header>

        <div id="data">${e}</div>
      </section>
    </div>`;
  }
  connectedCallback() {
    super.connectedCallback(), window.addEventListener("keydown", this.#i);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), window.removeEventListener("keydown", this.#i);
  }
  #u(t) {
    return {
      ...t,
      graphNodeData: (() => {
        if (bt(t)) {
          if (ii(t) && typeof t.state == "object") {
            const r = bt(t) ? t.data.node.id : "", s = sr(t.state);
            if (!s)
              return null;
            const o = s.state.state.get(r);
            if (!o)
              return null;
            const n = {};
            for (const [a, d] of o.entries())
              n[a] = d;
            return { inputs: n, outputs: {} };
          }
          return;
        }
        return { inputs: t.data, outputs: {} };
      })(),
      id: bt(t) ? X(t.data.path, t.type) : "",
      guid: globalThis.crypto.randomUUID(),
      children: []
    };
  }
  #h(t, e, r) {
    let s = r;
    for (let o = 0; o < t.length - 1; o++) {
      const n = X(t.slice(0, o + 1), e), a = s.findIndex((d) => d.id === n);
      if (a === -1)
        return console.warn(`Unable to find ID "${n}"`), r;
      s = s[a].children;
    }
    return s;
  }
  #l(t, e) {
    const r = X(t.data.path, t.type), o = this.#h(t.data.path, t.type, e).find((a) => a.id === r);
    if (!o) {
      console.warn(`Unable to find ID "${r}"`);
      return;
    }
    o.type === j.NODESTART && t.type === j.NODEEND && (o.type = t.type, o.graphNodeData && "outputs" in t.data && (o.graphNodeData.outputs = t.data.outputs), o.graphNodeData === null && (o.graphNodeData = void 0));
  }
  render() {
    if (this.messages === null)
      return l`There are no history entries yet.`;
    this.#t.clear();
    const t = [];
    for (let e = 0; e <= this.messagePosition; e++) {
      const r = this.messages[e];
      if (!r || !si(r))
        continue;
      if (r.type === "nodeend") {
        this.#l(r, t);
        continue;
      }
      const s = this.#u(r);
      if (bt(r)) {
        let o = this.#h(r.data.path, r.type, t);
        const n = o.find((a) => a.id === X(r.data.path, r.type));
        n && (r.data.path.push(n.children.length), s.id = X(r.data.path, r.type), o = n.children), o.push(s);
      } else
        t.push(s);
    }
    return l`<div id="history-list">
      <table cellspacing="0" cellpadding="0">
        <thead>
          <tr>
            <td>Type</td>
            <td class="id">ID</td>
            <td class="initiator">Initiator</td>
            <td class="value">Value</td>
          </tr>
        </thead>
        <tbody>
          ${t.length === 0 ? l`<tr data-parent="">
                <td colspan="4">No entries</td>
              </tr>` : t.map((e) => this.#d(e))}
        </tbody>
      </table>
      <div>
        ${this.selected ? this.#c(this.selected) : g}
      </div>
    </div>`;
  }
};
F([
  p({ reflect: !1 })
], L.prototype, "messages", void 0);
F([
  p({ reflect: !0 })
], L.prototype, "messagePosition", void 0);
F([
  p()
], L.prototype, "lastUpdate", void 0);
F([
  P()
], L.prototype, "expandCollapseState", void 0);
F([
  p({ reflect: !1 })
], L.prototype, "selected", void 0);
L = F([
  $("bb-history-tree")
], L);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class oi {
  #t(t) {
    return Object.values(t).map((e) => e.title).join("#");
  }
  rememberSaving(t) {
    globalThis.sessionStorage.setItem(this.#t(t), "yes");
  }
  didSave(t) {
    return !!globalThis.sessionStorage.getItem(this.#t(t));
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function ni(i) {
  return i.format == "multiline";
}
function ai(i) {
  return i.enum && i.enum.length > 0;
}
function di(i) {
  return i.type == "boolean";
}
function be(i) {
  return typeof i.type == "string" && i.type.startsWith("image");
}
function li(i) {
  return i.type === "object" && i.format?.startsWith("text");
}
function ci(i) {
  return i.format === "webcam";
}
function hi(i) {
  return i.format === "drawable";
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var Zt = function(i, t, e, r) {
  var s = arguments.length, o = s < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, n;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(i, t, e, r);
  else
    for (var a = i.length - 1; a >= 0; a--)
      (n = i[a]) && (o = (s < 3 ? n(o) : s > 3 ? n(t, e, o) : n(t, e)) || o);
  return s > 3 && o && Object.defineProperty(t, e, o), o;
};
let at = class extends y {
  static {
    this.styles = w`
    :host {
      --default-bb-box-shadow: 0 6px 9px 0 rgba(0, 0, 0, 0.12),
        0 2px 3px 0 rgba(0, 0, 0, 0.23);
      --default-bb-border-radius: 8px;
      --default-bb-input-background-color: #fff;

      display: block;
      width: 100%;
      background-color: var(
        --bb-input-background-color,
        var(--default-bb-input-background-color)
      );
      box-shadow: var(--bb-box-shadow, var(--default-bb-box-shadow));
      border-radius: var(--bb-border-radius, var(--default-bb-border-radius));
      aspect-ratio: 4/3;
    }

    canvas {
      display: block;
      width: 100%;
      opacity: 0;
      border-radius: var(--bb-border-radius, var(--default-bb-border-radius));
    }

    canvas.active {
      animation: fadeIn 0.3s cubic-bezier(0, 0, 0.3, 1) both;
      animation-delay: 0.3s;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }
  `;
  }
  #t;
  #e;
  #i;
  #s;
  constructor() {
    super(), this.type = "image/png", this.error = "", this.#e = N(), this.#i = document.createElement("video"), this.#s = !1, this.#i.autoplay = !0, this.#i.addEventListener("loadeddata", () => {
      const t = this.#e.value;
      t && (t.width = this.#i.videoWidth, t.height = this.#i.videoHeight);
    });
  }
  connectedCallback() {
    super.connectedCallback(), navigator.mediaDevices.getUserMedia({
      audio: !1,
      video: !0
    }).then((t) => {
      this.#t = t, this.#i.srcObject = this.#t, this.#s = !0, this.#e.value && this.#e.value.classList.add("active"), this.#r();
    }, () => {
      this.error = "Unable to access webcam - is there one attached?";
    });
  }
  get value() {
    const t = { inline_data: { data: "", mime_type: this.type } }, e = this.#e.value?.toDataURL(this.type, 80);
    if (!e)
      return t;
    const r = `data:${this.type};base64,`;
    return t.inline_data.data = e.substring(r.length), t;
  }
  set value(t) {
    console.warn("Value set on webcam, but values are not supported");
  }
  disconnectedCallback() {
    if (this.#t) {
      for (const t of this.#t.getTracks())
        t.stop(), this.#t.removeTrack(t);
      this.#e.value && this.#e.value.classList.remove("active"), this.#s = !1;
    }
  }
  render() {
    return this.error ? l`${this.error}` : l`<canvas ${z(this.#e)}></canvas>`;
  }
  #r() {
    if (!this.#s || !this.#e.value)
      return;
    const t = this.#e.value.getContext("2d");
    t && (t.drawImage(this.#i, 0, 0), requestAnimationFrame(() => {
      this.requestUpdate(), this.#r();
    }));
  }
};
Zt([
  p()
], at.prototype, "type", void 0);
Zt([
  P()
], at.prototype, "error", void 0);
at = Zt([
  $("bb-webcam-input")
], at);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var pt = function(i, t, e, r) {
  var s = arguments.length, o = s < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, n;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(i, t, e, r);
  else
    for (var a = i.length - 1; a >= 0; a--)
      (n = i[a]) && (o = (s < 3 ? n(o) : s > 3 ? n(t, e, o) : n(t, e)) || o);
  return s > 3 && o && Object.defineProperty(t, e, o), o;
};
const ui = (i, t) => {
  if (i === "boolean")
    return t.checked;
  const e = t.value;
  if (i === "string")
    return e;
  try {
    return JSON.parse(e);
  } catch {
    return e;
  }
};
let q = class extends y {
  constructor() {
    super(...arguments), this.remember = !1, this.secret = !1, this.configuration = null, this.processedValues = null, this.#t = new oi(), this.#e = N();
  }
  #t;
  #e;
  static {
    this.styles = w`
    :host {
      display: flex;
      flex-direction: row;
      width: 100%;
    }

    * {
      box-sizing: border-box;
      font-size: var(--bb-input-font-size, var(--bb-text-nano));
    }

    bb-json-tree {
      width: 100%;
    }

    form,
    #choice-container {
      flex: 1;
    }

    fieldset {
      display: grid;
      justify-items: start;
      grid-template-columns: 1fr 1fr 1fr 1fr;
      row-gap: calc(var(--bb-grid-size) * 2);
      flex: 1;
      margin: calc(var(--bb-grid-size) * 2) 0;
      border: var(--bb-input-fieldset-border, 1px solid rgb(200, 200, 200));
      border-radius: var(--bb-grid-size);
      position: relative;
      padding-bottom: calc(var(--bb-grid-size) * 3);
    }

    legend {
      display: var(--bb-input-legend-display, block);
      padding: 0 calc(var(--bb-grid-size) * 2);
    }

    label {
      grid-column: 1/3;
      font-family: var(--bb-font-family);
      font-size: var(--bb-text-small);
      padding: calc(var(--bb-grid-size) * 2) calc(var(--bb-grid-size) * 2) 0 0;
    }

    #choice-container label:not(:first-of-type) {
      padding-top: calc(var(--bb-grid-size) * 2);
    }

    label.first-of-type {
      grid-column: 1 / 5;
    }

    #input {
      position: relative;
      flex: 1;
    }

    .multiline {
      grid-column: 1 / 5;
      flex: 1;
      width: 100%;
      overflow: hidden;
      border-radius: var(
        --bb-input-border-radius,
        calc(var(--bb-grid-size) * 3)
      );
      border: 1px solid rgb(209, 209, 209);
      min-height: calc(var(--bb-grid-size) * 50);
    }

    input[type="text"],
    input[type="password"],
    bb-drawable-input,
    bb-webcam-input,
    textarea,
    .parsed-value {
      grid-column: 1 / 5;
      border-radius: var(
        --bb-input-border-radius,
        calc(var(--bb-grid-size) * 3)
      );
      background: rgb(255, 255, 255);
      padding: var(--bb-input-padding, calc(var(--bb-grid-size) * 2));
      width: 100%;
      border: 1px solid rgb(209, 209, 209);
    }

    bb-multipart-input {
      grid-column: 1 / 5;
    }

    textarea {
      resize: none;
      font-size: var(--bb-text-small);
      padding-top: calc(var(--bb-grid-size) * 2);
      padding-bottom: calc(var(--bb-grid-size) * 2);
      line-height: 1.4;
      border: none;
      height: 100%;
    }

    #choice-container img,
    bb-drawable-input,
    bb-webcam-input {
      display: block;
      border-radius: calc(var(--bb-grid-size) * 2);
      border: 1px solid rgb(209, 209, 209);
      padding: 0;
      --bb-box-shadow: none;
    }

    div#input {
      min-height: calc(var(--bb-grid-size) * 12);
    }

    input[type="text"]::placeholder,
    input[type="password"]::placeholder {
      font-size: var(--bb-text-medium);
    }

    #choice-container label {
      grid-column: 1 / 5;
    }

    .parsed-value {
      background: rgb(250, 250, 250);
      color: var(--bb-font-color-faded);
      display: flex;
      align-items: center;
      font-size: var(--bb-text-nano);
      height: auto;
    }

    input[type="submit"] {
      font-size: 0;
      width: calc(var(--bb-grid-size) * 8);
      height: calc(var(--bb-grid-size) * 8);
      position: absolute;
      right: calc(var(--bb-grid-size) * 1.5);
      top: calc(var(--bb-grid-size) * 0.5);
      border-radius: 50%;
      background: var(--bb-icon-start) center center no-repeat;
      border: none;
    }

    input[type="submit"][disabled] {
      opacity: 50%;
    }

    .parsed-value img {
      width: 100%;
      border-radius: calc(var(--bb-grid-size) * 6);
      object-fit: cover;
      aspect-ratio: auto;
    }
  `;
  }
  #i() {
    return `bb-remember-${this.id}`;
  }
  #s() {
    if (!this.remember)
      return {};
    const t = this.#i(), e = localStorage.getItem(t);
    if (e)
      try {
        return JSON.parse(e);
      } catch {
        console.warn(`Unable to parse remembered values for ${t}`);
      }
    return {};
  }
  #r(t) {
    if (!this.remember)
      return;
    const e = this.#i(), r = JSON.stringify(t);
    localStorage.setItem(e, r);
  }
  async processInput() {
    this.#e.value && this.#e.value.reportValidity() && this.#e.value.dispatchEvent(new SubmitEvent("submit"));
  }
  async #o(t) {
    if (t.preventDefault(), !(t.target instanceof HTMLFormElement)) {
      console.warn("Unable to process form - event fired from non-form element");
      return;
    }
    if (!this.configuration || !this.configuration.schema || !this.configuration.schema.properties) {
      console.warn("Unable to process form: no input Schema detected");
      return;
    }
    const { schema: e } = this.configuration, { properties: r } = e, s = t.target;
    if (!r)
      return l`Unable to render: no input Schema detected`;
    const o = {};
    for (const [n, a] of Object.entries(r))
      if (le(a)) {
        const d = await Fr(s, n);
        o[n] = d.value;
      } else {
        const d = s[n];
        if (d && d.value) {
          const h = ui(a.type, d);
          o[n] = h;
        } else {
          const h = s.querySelector(`#${n}`);
          if (!h) {
            console.warn(`Unable to find element for key ${n}`);
            continue;
          }
          if (h instanceof at || h instanceof V) {
            const c = h.value;
            o[n] = c;
          }
        }
      }
    this.#r(o), this.remember && this.#t.rememberSaving(r), this.dispatchEvent(new yt(this.id, o));
  }
  render() {
    if (!this.configuration || !this.configuration.schema)
      return l`Unable to render: no input Schema detected`;
    const { schema: t } = this.configuration, { properties: e } = t, r = this.#s();
    if (!e)
      return l`Unable to render: no input Schema detected`;
    if (this.remember && this.#t.didSave(e)) {
      this.dispatchEvent(new yt(this.id, r));
      return;
    }
    return this.processedValues ? this.#d(e, this.processedValues) : this.#n(e, r);
  }
  #d(t, e) {
    if (!this.processedValues)
      return;
    const r = (s, o, n) => {
      if (Array.isArray(o.items)) {
        const a = o.items, d = n;
        return l`${a.map((h, u) => r(s, h, d[u]))}`;
      }
      if (be(o)) {
        const a = n, d = `data:${a.inline_data.mime_type};base64,${a.inline_data.data}`;
        return l`<div class="parsed-value">
          <img src="${d}" />
        </div>`;
      } else
        return li(o) ? l`<div class="parsed-value">
          ${n.text}
        </div>` : typeof n == "object" ? l`<div class="parsed-value">
          <bb-json-tree .json=${n}></bb-json-tree>
        </div>` : l`<div class="parsed-value">${n}</div>`;
    };
    return l`<form id="choice-container">
      <fieldset>
        <legend>${this.id}</legend>
        ${Object.entries(t).map(([s, o]) => {
      const n = l`<label for="${s}">${o.title}</label>`, a = r(s, o, e[s]);
      return l`${n}${a}`;
    })}
      </fieldset>
    </form>`;
  }
  #n(t, e) {
    return l`<div id="input">
      <form ${z(this.#e)} @submit=${this.#o}>
        <fieldset>
          <legend>${this.id}</legend>
          ${Object.entries(t).map(([r, s]) => {
      const o = l`<label for="${r}">${s.title}</label>`;
      let n;
      if (be(s))
        ci(s) ? n = l`<bb-webcam-input id="${r}"></bb-webcam-input>` : hi(s) ? n = l`<bb-drawable-input
                  id="${r}"
                ></bb-drawable-input>` : n = l`Image type not supported yet.`;
      else if (ai(s)) {
        const a = s.enum || [];
        n = l`<select name="${r}" id="${r}">
                ${a.map((d) => {
          const h = d === s.default;
          return l`<option ?selected=${h} value=${d}>
                    ${d}
                  </option>`;
        })}
              </select>`;
      } else if (di(s)) {
        const a = !!e[r];
        n = l`<input
                name="${r}"
                id="${r}"
                type="checkbox"
                checked="${a}"
              />`;
      } else if (le(s)) {
        const a = Yr(s, r);
        n = l`${a}`;
      } else {
        const a = e[r] ?? s.examples ?? s.default ?? "";
        ni(s) ? n = l`<div class="multiline">
                  <textarea
                    name="${r}"
                    id="${r}"
                    placeholder="${s.description || ""}"
                    .value=${a}
                  ></textarea>
                </div>` : n = l`<input
                  name="${r}"
                  id="${r}"
                  required="true"
                  type="${this.secret ? "password" : "text"}"
                  autocomplete="${this.secret ? "off" : "on"}"
                  placeholder="${s.description || ""}"
                  autofocus="true"
                  value="${a}"
                />`;
      }
      return l`${o}${n}`;
    })}
        </fieldset>
      </form>
    </div>`;
  }
};
pt([
  p({ reflect: !1 })
], q.prototype, "remember", void 0);
pt([
  p({ reflect: !1 })
], q.prototype, "secret", void 0);
pt([
  p({ reflect: !1 })
], q.prototype, "configuration", void 0);
pt([
  p({ reflect: !1 })
], q.prototype, "processedValues", void 0);
q = pt([
  $("bb-input")
], q);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var pi = function(i, t, e, r) {
  var s = arguments.length, o = s < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, n;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(i, t, e, r);
  else
    for (var a = i.length - 1; a >= 0; a--)
      (n = i[a]) && (o = (s < 3 ? n(o) : s > 3 ? n(t, e, o) : n(t, e)) || o);
  return s > 3 && o && Object.defineProperty(t, e, o), o;
};
let fe = class extends y {
  static {
    this.styles = w`
    :host {
      display: block;
      padding: calc(var(--bb-grid-size) * 2);
    }
  `;
  }
  render() {
    return l`<slot></slot>`;
  }
  clearContents() {
    const t = Array.from(this.querySelectorAll("*"));
    for (const e of t)
      e.remove();
  }
};
fe = pi([
  $("bb-input-container")
], fe);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var Nt = function(i, t, e, r) {
  var s = arguments.length, o = s < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, n;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(i, t, e, r);
  else
    for (var a = i.length - 1; a >= 0; a--)
      (n = i[a]) && (o = (s < 3 ? n(o) : s > 3 ? n(t, e, o) : n(t, e)) || o);
  return s > 3 && o && Object.defineProperty(t, e, o), o;
};
let dt = class extends y {
  constructor() {
    super(...arguments), this.messages = null, this.messagePosition = 0, this.lastUpdate = Number.NaN, this.#t = N();
  }
  #t;
  static {
    this.styles = w`
    :host {
      display: block;
    }
  `;
  }
  #e(t, e, r) {
    for (let s = e; s < this.messagePosition; s++) {
      const o = r[s];
      if (o.type === "nodeend" && o.data.node.id === t)
        return o.data.outputs;
    }
    return null;
  }
  captureNewestInput() {
    this.#t.value && this.#t.value.processInput();
  }
  render() {
    if (!this.messages)
      return;
    const t = [];
    for (let e = this.messagePosition; e >= 0; e--) {
      const r = this.messages[e];
      if (!r || r.type !== "input" && r.type !== "secret")
        continue;
      const s = e === this.messages.length - 1;
      if (r.type === "secret" && s) {
        for (const n of r.data.keys)
          t.push({
            id: n,
            configuration: {
              schema: {
                properties: {
                  secret: {
                    title: n,
                    description: `Enter ${n}`,
                    type: "string"
                  }
                }
              }
            },
            remember: !0,
            secret: !0,
            processedValues: null
          });
        continue;
      }
      if (r.type !== "input")
        continue;
      const o = this.#e(r.data.node.id, e, this.messages);
      t.push({
        id: r.data.node.id,
        configuration: r.data.inputArguments,
        remember: !1,
        secret: !1,
        processedValues: o
      });
    }
    return t.length ? l` ${t.map(({ id: e, secret: r, remember: s, configuration: o, processedValues: n }, a) => this.messages ? l`<bb-input
          id="${e}"
          ${a === 0 ? z(this.#t) : void 0}
          .secret=${r}
          .remember=${s}
          .configuration=${o}
          .processedValues=${n}
        ></bb-input>` : g)}` : l`There are no inputs yet.`;
  }
};
Nt([
  p({ reflect: !1 })
], dt.prototype, "messages", void 0);
Nt([
  p({ reflect: !0 })
], dt.prototype, "messagePosition", void 0);
Nt([
  p()
], dt.prototype, "lastUpdate", void 0);
dt = Nt([
  $("bb-input-list")
], dt);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var Kt = function(i, t, e, r) {
  var s = arguments.length, o = s < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, n;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(i, t, e, r);
  else
    for (var a = i.length - 1; a >= 0; a--)
      (n = i[a]) && (o = (s < 3 ? n(o) : s > 3 ? n(t, e, o) : n(t, e)) || o);
  return s > 3 && o && Object.defineProperty(t, e, o), o;
};
let xt = class extends y {
  constructor() {
    super(...arguments), this.json = null, this.autoExpand = !1, this.#t = !1;
  }
  #t;
  static {
    this.styles = w`
    :host {
      font-family: var(--bb-font-family-mono, monospace);
      font-size: var(--bb-text-nano, 11px);
      cursor: default;
      --bb-grid-size: 4px;
      position: relative;
      display: block;
    }

    #top-level {
      width: calc(100% - 32px);
    }

    #copy-to-clipboard {
      width: 24px;
      height: 24px;
      font-size: 0;
      background: var(--bb-icon-copy-to-clipboard) center center no-repeat;
      vertical-align: middle;
      border: none;
      cursor: pointer;
      transition: opacity var(--bb-easing-duration-out) var(--bb-easing);
      opacity: 0.5;
      position: absolute;
      top: 0;
      right: 0;
      border-radius: 50%;
    }

    #copy-to-clipboard:hover {
      background-color: #ffffffcc;
      transition: opacity var(--bb-easing-duration-in) var(--bb-easing),
        background-color var(--bb-easing-duration-in) var(--bb-easing);
      opacity: 1;
    }

    :host(:hover) #copy-to-clipboard {
      display: block;
    }

    summary,
    .preview,
    .key {
      margin-left: 0;
    }

    details[open] > summary .preview {
      display: none;
    }

    .number {
      color: rgb(0, 0, 255);
    }

    .string {
      color: rgb(0, 118, 15);
    }

    .boolean {
      color: rgb(33, 200, 210);
    }

    .key {
      color: var(--bb-font-color, rgb(68, 61, 116));
      font-weight: bold;
    }

    .empty {
      font-style: italic;
    }

    * > * {
      margin: calc(var(--bb-grid-size) * 0.5) 0 0 calc(var(--bb-grid-size) * 4);
    }
  `;
  }
  #e(t) {
    return Array.isArray(t) ? t.length > 0 ? "[...]" : "[]" : typeof t == "object" ? Object.keys(t).length > 0 ? "{...}" : "{}" : t;
  }
  #i(t) {
    return typeof t == "string" ? `"${t}"` : t;
  }
  async #s(t) {
    this.#t || !this.json || (t.stopImmediatePropagation(), t.preventDefault(), this.#t = !0, await navigator.clipboard.writeText(JSON.stringify(this.json, null, 2)), this.dispatchEvent(new ut("JSON copied to clipboard", B.INFORMATION)), this.#t = !1);
  }
  #r(t) {
    const e = Object.entries(t);
    return e.length === 0 ? Array.isArray(t) ? l`<div class="empty">length: 0</div>` : l`<div class="empty">{}</div>` : l`${e.map(([r, s]) => {
      const o = typeof s, n = this.#e(s);
      return o === "object" ? l`<details ?open=${this.autoExpand}>
          <summary>
            <span class="key">${r}: </span>
            <span class="preview">${n}</span>
          </summary>
          ${this.#r(s)}
        </details>` : l`<div class="${o}">
        <span class="key">${r}: </span>${this.#i(s)}
      </div>`;
    })}`;
  }
  render() {
    return this.json === null ? g : l`{
      <div id="top-level">${this.#r(this.json)}</div>
      }
      <button
        id="copy-to-clipboard"
        @click=${this.#s}
        title="Copy JSON to Clipboard"
      >
        Copy
      </button>`;
  }
};
Kt([
  p({ reflect: !1 })
], xt.prototype, "json", void 0);
Kt([
  p({ reflect: !0 })
], xt.prototype, "autoExpand", void 0);
xt = Kt([
  $("bb-json-tree")
], xt);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var bi = function(i, t, e, r) {
  var s = arguments.length, o = s < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, n;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(i, t, e, r);
  else
    for (var a = i.length - 1; a >= 0; a--)
      (n = i[a]) && (o = (s < 3 ? n(o) : s > 3 ? n(t, e, o) : n(t, e)) || o);
  return s > 3 && o && Object.defineProperty(t, e, o), o;
};
let It = class extends y {
  #t;
  static {
    this.styles = w`
    :host {
      display: block;
      padding: calc(var(--bb-grid-size) * 2) 0;
    }
  `;
  }
  constructor(t) {
    super(), this.#t = this.#e(t);
  }
  async #e(t) {
    let e = {};
    const r = t.schema;
    return !r || !r.properties ? e = t : await Promise.all(Object.entries(r.properties).map(async ([s, o], n) => {
      if (o.type === "object" && o.format === "stream") {
        let a = "";
        await or(t[s]).pipeTo(new WritableStream({
          write(d) {
            a += d.chunk;
          }
        })), e[s] = a;
        return;
      }
      e[o.title || `Untitled property (${n})`] = t[s];
    })), l`<bb-json-tree .json=${e} autoExpand="true"></bb-json-tree>`;
  }
  render() {
    return l`${Ft(this.#t, l`Processing output...`)}`;
  }
};
It = bi([
  $("bb-output")
], It);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var He = function(i, t, e, r) {
  var s = arguments.length, o = s < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, n;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(i, t, e, r);
  else
    for (var a = i.length - 1; a >= 0; a--)
      (n = i[a]) && (o = (s < 3 ? n(o) : s > 3 ? n(t, e, o) : n(t, e)) || o);
  return s > 3 && o && Object.defineProperty(t, e, o), o;
};
let _t = class extends y {
  constructor() {
    super(...arguments), this.message = null;
  }
  static {
    this.styles = w`
    :host {
      display: block;
      font-family: var(--bb-font-family-mono, monospace);
      font-size: var(--bb-text-nano, 11px);
      padding: calc(var(--bb-grid-size) * 2) 0;
      color: var(--bb-error-color);
    }
  `;
  }
  render() {
    return typeof this.message == "string" ? l`${this.message}` : l`<div id="error">
        ${JSON.stringify(this.message?.error, null, 2)}
      </div>
      <div id="descriptor">in: "${this.message?.descriptor.id}"</div>`;
  }
};
He([
  p()
], _t.prototype, "message", void 0);
_t = He([
  $("bb-error")
], _t);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var Gt = function(i, t, e, r) {
  var s = arguments.length, o = s < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, n;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(i, t, e, r);
  else
    for (var a = i.length - 1; a >= 0; a--)
      (n = i[a]) && (o = (s < 3 ? n(o) : s > 3 ? n(t, e, o) : n(t, e)) || o);
  return s > 3 && o && Object.defineProperty(t, e, o), o;
};
let kt = class extends y {
  constructor() {
    super(...arguments), this.messages = null, this.messagePosition = 0;
  }
  static {
    this.styles = w`
    :host {
      display: block;
    }
  `;
  }
  render() {
    if (!this.messages)
      return;
    const t = [];
    for (let e = 0; e <= this.messagePosition; e++) {
      const r = this.messages[e];
      if (!r || r.type !== "output" && r.type !== "error")
        continue;
      let s;
      if (r.type === "output")
        s = new It(r.data.outputs);
      else if (s = new _t(), typeof r.data.error == "string")
        s.message = r.data.error.toString();
      else {
        let o = "", n = r.data.error;
        for (; typeof n == "object"; )
          n && "message" in n && (o += `${n.message}
`), n = n.error;
        s.message = o;
      }
      t.unshift(s);
    }
    return t.length ? l`${t}` : l`There are no outputs yet.`;
  }
};
Gt([
  p({ reflect: !1 })
], kt.prototype, "messages", void 0);
Gt([
  p({ reflect: !0 })
], kt.prototype, "messagePosition", void 0);
kt = Gt([
  $("bb-output-list")
], kt);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var Pt = function(i, t, e, r) {
  var s = arguments.length, o = s < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, n;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(i, t, e, r);
  else
    for (var a = i.length - 1; a >= 0; a--)
      (n = i[a]) && (o = (s < 3 ? n(o) : s > 3 ? n(t, e, o) : n(t, e)) || o);
  return s > 3 && o && Object.defineProperty(t, e, o), o;
};
let lt = class extends y {
  constructor() {
    super(...arguments), this.type = B.INFORMATION, this.message = "", this.timeout = 8e3;
  }
  static {
    this.styles = w`
    :host {
      --bb-toast-icon: var(--bb-icon-info);

      position: fixed;
      bottom: calc(var(--bb-grid-size) * 10);
      right: calc(var(--bb-grid-size) * 10);
      display: block;
      background: rgb(255, 255, 255);
      border: 1px solid #ccc;
      box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.13),
        0 7px 9px 0 rgba(0, 0, 0, 0.16);
      border-radius: calc(var(--bb-grid-size) * 8);
      padding: calc(var(--bb-grid-size) * 5) calc(var(--bb-grid-size) * 8)
        calc(var(--bb-grid-size) * 5) calc(var(--bb-grid-size) * 12);

      animation: slideIn var(--bb-easing-duration-in) var(--bb-easing) forwards;
      max-width: min(360px, 80vw);
    }

    :host([type="warning"]) {
      --bb-toast-icon: var(--bb-icon-warning);
      color: var(--bb-warning-color);
    }

    :host([type="error"]) {
      --bb-toast-icon: var(--bb-icon-error);
      color: var(--bb-error-color);
    }

    :host(.toasted) {
      animation: slideOut var(--bb-easing-duration-out) var(--bb-easing)
        forwards;
    }

    :host::before {
      content: "";
      position: absolute;
      left: 16px;
      top: 17px;
      width: 24px;
      height: 24px;
      background: var(--bb-toast-icon) center center no-repeat;
    }

    @keyframes slideIn {
      from {
        transform: translateY(20px);
        opacity: 0;
      }

      to {
        transform: none;
        opacity: 1;
      }
    }

    @keyframes slideOut {
      from {
        transform: none;
        opacity: 1;
      }

      to {
        transform: translateY(-20px);
        opacity: 0;
      }
    }
  `;
  }
  connectedCallback() {
    super.connectedCallback(), setTimeout(() => {
      this.addEventListener("animationend", () => {
        this.remove();
      }, { once: !0 }), this.classList.add("toasted");
    }, this.timeout);
  }
  render() {
    return l`<div>${this.message}</div>`;
  }
};
Pt([
  p({ reflect: !0 })
], lt.prototype, "type", void 0);
Pt([
  p()
], lt.prototype, "message", void 0);
Pt([
  p()
], lt.prototype, "timeout", void 0);
lt = Pt([
  $("bb-toast")
], lt);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function* fi(i, t) {
  if (i !== void 0) {
    let e = 0;
    for (const r of i)
      yield t(r, e++);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Ve = "important", gi = " !" + Ve, Q = M(class extends Y {
  constructor(i) {
    if (super(i), i.type !== At.ATTRIBUTE || i.name !== "style" || i.strings?.length > 2)
      throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(i) {
    return Object.keys(i).reduce((t, e) => {
      const r = i[e];
      return r == null ? t : t + `${e = e.includes("-") ? e : e.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${r};`;
    }, "");
  }
  update(i, [t]) {
    const { style: e } = i.element;
    if (this.ft === void 0)
      return this.ft = new Set(Object.keys(t)), this.render(t);
    for (const r of this.ft)
      t[r] == null && (this.ft.delete(r), r.includes("-") ? e.removeProperty(r) : e[r] = null);
    for (const r in t) {
      const s = t[r];
      if (s != null) {
        this.ft.add(r);
        const o = typeof s == "string" && s.endsWith(gi);
        r.includes("-") || o ? e.setProperty(r, o ? s.slice(0, -11) : s, o ? Ve : "") : e[r] = s;
      }
    }
    return x;
  }
});
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ge = (i, t, e) => {
  const r = /* @__PURE__ */ new Map();
  for (let s = t; s <= e; s++)
    r.set(i[s], s);
  return r;
}, mi = M(class extends Y {
  constructor(i) {
    if (super(i), i.type !== At.CHILD)
      throw Error("repeat() can only be used in text expressions");
  }
  dt(i, t, e) {
    let r;
    e === void 0 ? e = t : t !== void 0 && (r = t);
    const s = [], o = [];
    let n = 0;
    for (const a of i)
      s[n] = r ? r(a, n) : n, o[n] = e(a, n), n++;
    return { values: o, keys: s };
  }
  render(i, t, e) {
    return this.dt(i, t, e).values;
  }
  update(i, [t, e, r]) {
    const s = zr(i), { values: o, keys: n } = this.dt(t, e, r);
    if (!Array.isArray(s))
      return this.ut = n, o;
    const a = this.ut ??= [], d = [];
    let h, u, c = 0, f = s.length - 1, b = 0, m = o.length - 1;
    for (; c <= f && b <= m; )
      if (s[c] === null)
        c++;
      else if (s[f] === null)
        f--;
      else if (a[c] === n[b])
        d[b] = R(s[c], o[b]), c++, b++;
      else if (a[f] === n[m])
        d[m] = R(s[f], o[m]), f--, m--;
      else if (a[c] === n[m])
        d[m] = R(s[c], o[m]), G(i, d[m + 1], s[c]), c++, m--;
      else if (a[f] === n[b])
        d[b] = R(s[f], o[b]), G(i, s[c], s[f]), f--, b++;
      else if (h === void 0 && (h = ge(n, b, m), u = ge(a, c, f)), h.has(a[c]))
        if (h.has(a[f])) {
          const _ = u.get(n[b]), k = _ !== void 0 ? s[_] : null;
          if (k === null) {
            const Z = G(i, s[c]);
            R(Z, o[b]), d[b] = Z;
          } else
            d[b] = R(k, o[b]), G(i, s[c], k), s[_] = null;
          b++;
        } else
          Rt(s[f]), f--;
      else
        Rt(s[c]), c++;
    for (; b <= m; ) {
      const _ = G(i, d[m + 1]);
      R(_, o[b]), d[b++] = _;
    }
    for (; c <= f; ) {
      const _ = s[c++];
      _ !== null && Rt(_);
    }
    return this.ut = n, Pe(i, d), x;
  }
});
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const vi = {}, Ut = M(class extends Y {
  constructor() {
    super(...arguments), this.ot = vi;
  }
  render(i, t) {
    return t();
  }
  update(i, [t, e]) {
    if (Array.isArray(t)) {
      if (Array.isArray(this.ot) && this.ot.length === t.length && t.every((r, s) => r === this.ot[s]))
        return x;
    } else if (this.ot === t)
      return x;
    return this.ot = Array.isArray(t) ? Array.from(t) : t, this.render(t, e);
  }
});
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var Tt = function(i, t, e, r) {
  var s = arguments.length, o = s < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, n;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(i, t, e, r);
  else
    for (var a = i.length - 1; a >= 0; a--)
      (n = i[a]) && (o = (s < 3 ? n(o) : s > 3 ? n(t, e, o) : n(t, e)) || o);
  return s > 3 && o && Object.defineProperty(t, e, o), o;
};
const yi = (i) => i.type === "nodestart" || i.type === "nodeend" || i.type === "graphstart" || i.type === "graphend", $i = (i) => i.length == 0 ? "root" : i.join("-");
let ct = class extends y {
  constructor() {
    super(...arguments), this.messages = null, this.messagePosition = 0, this.narrow = !1, this.#t = /* @__PURE__ */ new Map(), this.#e = this.#o.bind(this), this.#i = this.#d.bind(this), this.#s = this.#n.bind(this), this.#r = !1;
  }
  #t;
  #e;
  #i;
  #s;
  static {
    this.styles = w`
    :host {
      display: flex;
      width: 100%;
      height: 100%;
      overflow: auto;
      position: relative;
      user-select: none;
      --entry-padding-x: 3px;
      --entry-padding-y: 3px;
      --entry-width: 18px;
      --entry-height: 18px;
      --header-width: 120px;
      --entry-dot-size: 8px;
    }

    #tracks.narrow {
      --entry-padding-x: 1px;
      --entry-width: 6px;
      --entry-height: 18px;
      --entry-dot-size: 2px;
    }

    #tracks {
      min-width: 100%;
    }

    #marker {
      position: absolute;
      top: 0;
      left: calc(var(--header-width) + var(--x) * var(--entry-width));
      height: max(100%, calc(var(--rows) * var(--entry-height)));
      width: var(--entry-width);
      background: rgba(113, 106, 162, 0.08);
      z-index: 1;
    }

    :host::after {
      content: "";
      height: 100%;
      width: 1px;
      background: #f3f3f3;
      position: absolute;
      top: 0;
      left: calc(var(--header-width) - 1px);
      z-index: 3;
    }

    .filler,
    .track {
      height: calc(var(--entry-height) - 1px);
      font-size: var(--bb-text-pico);
      width: max(
        100%,
        calc(var(--header-width) + var(--count) * var(--entry-width))
      );
      border-bottom: 1px solid #f3f3f3;
    }

    .filler {
      height: calc(100% - var(--rows) * var(--entry-height) - 1px);
      border-bottom: none;
    }

    .header {
      position: sticky;
      width: var(--header-width);
      height: calc(100% + 1px);
      background: rgb(255, 255, 255);
      border-bottom: 1px solid #f3f3f3;
      border-right: 1px solid #f3f3f3;
      box-sizing: border-box;
      padding: 0 calc(var(--bb-grid-size) * 4);
      white-space: nowrap;
      display: flex;
      align-items: center;
      left: 0;
      z-index: 4;
    }

    .filler .header {
      border-bottom: none;
    }

    .entry {
      left: calc(var(--header-width) - 1px + var(--x) * var(--entry-width));
      top: calc(-1px + var(--y) * var(--entry-height));
      position: absolute;
      width: calc(var(--entry-width) + 1px);
      height: calc(var(--entry-height) + 1px);
      box-sizing: border-box;
      border: 1px solid transparent;

      --entry-background-height: calc(
        var(--entry-height) - var(--entry-padding-y) * 2
      );
      --entry-background-cap-width: calc(
        var(--entry-width) - var(--entry-padding-x)
      );
    }

    .entry.nodestart,
    .entry.graphend,
    .entry.graphstart,
    .entry.end {
      border-left: 1px solid #f3f3f3;
    }

    .entry.end {
      border-right: 1px solid #f3f3f3;
    }

    .entry.nodestart::before {
      content: "";
      width: var(--entry-background-cap-width);
      position: absolute;
      background: rgb(253 243 213);
      border-radius: 20px 0 0 20px;
      height: var(--entry-background-height);
      left: var(--entry-padding-x);
      top: 50%;
      translate: 0 -50%;
    }

    .entry.nodeend::before {
      content: "";
      width: calc(
        var(--backfill, 0) * var(--entry-width) +
          var(--entry-background-cap-width) - 1px
      );
      position: absolute;
      background: rgb(253 243 213);
      border-radius: 0 20px 20px 0;
      height: var(--entry-background-height);
      left: calc(var(--backfill, 0) * var(--entry-width) * -1);
      top: 50%;
      translate: 0 -50%;
    }

    .entry:not(.nodestart):not(.nodeend)::before {
      content: "";
      width: calc(100% + 1px);
      position: absolute;
      background: rgb(253 243 213);
      height: var(--entry-background-height);
      left: 0;
      top: 50%;
      translate: 0 -50%;
    }

    .entry.nodestart.input::before,
    .entry.nodeend.input::before,
    .entry:not(.nodestart):not(.nodeend).input::before {
      background: rgb(231 238 250);
    }

    .entry.nodestart.output::before,
    .entry.nodeend.output::before,
    .entry:not(.nodestart):not(.nodeend).output::before {
      background: rgb(228 243 221);
    }

    .entry.nodestart.secrets::before,
    .entry.nodeend.secrets::before,
    .entry:not(.nodestart):not(.nodeend).secrets::before {
      background: rgb(246 239 239);
    }

    .entry:not(.nodestart):not(.nodeend).graphstart::before,
    .entry:not(.nodestart):not(.nodeend).graphend::before,
    .entry:not(.nodestart):not(.nodeend).secrets::before,
    .entry:not(.nodestart):not(.nodeend).secret::before,
    .entry:not(.nodestart):not(.nodeend).end::before {
      background: none;
    }

    .entry::after {
      content: "";
      width: var(--entry-dot-size);
      height: var(--entry-dot-size);
      border: 1px solid #666;
      background: #eee;
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 50%;
      translate: -50% -50%;
      box-sizing: border-box;
    }

    .entry.nodestart::after,
    .entry.nodeend::after {
      border: 1px solid hsl(33.6, 100%, 52.5%);
      background: hsl(44.7, 100%, 80%);
    }

    .entry.graphstart::after,
    .entry.graphend::after {
      background: rgb(110, 84, 139);
      border: 1px solid rgb(90, 64, 119);
    }

    .entry.error::after {
      background: #cc0000;
      border: 1px solid #cc0000;
    }

    .entry.result::after {
      background: #ffa500;
      border: 1px solid #ffa500;
    }

    .entry.input::after {
      background: #c9daf8ff;
      border: 1px solid #3c78d8;
    }

    .entry.secret::after,
    .entry.secrets::after {
      background: #f4cccc;
      border: 1px solid #db4437;
    }

    .entry.output::after {
      background: #b6d7a8ff;
      border: 1px solid #38761d;
    }

    .entry.load::after,
    .entry.end::after {
      background: var(--bb-done-color);
      border: 1px solid var(--bb-done-color);
    }

    .drag-receiver {
      position: absolute;
      width: var(--entry-width);
      top: 0;
      left: calc(var(--header-width) + var(--x) * var(--entry-width));
      height: 100%;
      z-index: 5;
    }
  `;
  }
  connectedCallback() {
    super.connectedCallback(), this.addEventListener("pointerdown", this.#e), document.body.addEventListener("pointermove", this.#i), document.body.addEventListener("pointerup", this.#s);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.removeEventListener("pointerdown", this.#e), document.body.removeEventListener("pointermove", this.#i), document.body.removeEventListener("pointerup", this.#s);
  }
  #r;
  #o(t) {
    this.#r = !0, this.#a(t);
  }
  #d(t) {
    this.#r && this.#a(t);
  }
  #n() {
    this.#r = !1;
  }
  #a(t) {
    const [e] = t.composedPath();
    if (!(e instanceof HTMLElement))
      return;
    const { idx: r } = e.dataset;
    r && this.dispatchEvent(new Yt(parseInt(r, 10)));
  }
  render() {
    if (!this.messages)
      return g;
    this.#t.clear();
    let t = 0, e = 0, r = null, s = 0, o = this.messagePosition;
    o >= 0 && o >= this.messages.length && (o = this.messages.length - 1);
    for (let d = 0; d < this.messages.length; d++) {
      const h = this.messages[d];
      let u = null;
      if (yi(h) ? u = $i(h.data.path.slice(0, -1)) : u = r, !u)
        continue;
      h.type === "nodeend" ? r = null : r = u;
      let c = this.#t.get(u);
      c || (c = /* @__PURE__ */ new Map(), this.#t.set(u, c), e++), d === o && (s = t), c.set(t, d), t++;
    }
    const n = () => l` ${mi(this.#t.entries(), (d) => d, ([d, h], u) => {
      let c = "", f = "", b = 0;
      return l`<div class="track">
            <div class="header">
              ${d === "root" ? "Main Board" : `Sub Board (${d})`}
            </div>
            ${fi(h, ([m, _]) => {
        if (!this.messages)
          return g;
        const k = this.messages[_];
        k.type === "nodestart" && (c = k.data.node.type, b = m);
        const Z = { "--x": m, "--y": u };
        if (k.type === "nodeend" && f === "nodestart" && b !== m - 1) {
          const We = m - b - 1;
          Z["--backfill"] = We;
        }
        const qe = l`<div
                  class=${nt({
          entry: !0,
          [k.type]: !0,
          [c]: !0
        })}
                  style=${Q(Z)}
                ></div>
                <div
                  class="drag-receiver"
                  data-idx=${_}
                  style=${Q({ "--x": m })}
                  title="${"id" in k ? k.id : ""}"
                ></div>`;
        return k.type === "nodeend" && (c = ""), f = k.type, qe;
      })}
          </div>`;
    })}
      <div
        class="filler"
        style=${Q({
      "--rows": e
    })}
      >
        <div class="header"></div>
      </div>`, a = () => l`<div
      id="marker"
      style=${Q({
      "--x": s,
      "--rows": e
    })}
    ></div>`;
    return l`<div
      id="tracks"
      class=${nt({ narrow: this.narrow })}
      style=${Q({ "--count": t })}
    >
      ${Ut([this.messages.length], n)}
      ${Ut([this.messagePosition], a)};
    </div>`;
  }
};
Tt([
  p({ reflect: !1 })
], ct.prototype, "messages", void 0);
Tt([
  p({ reflect: !0 })
], ct.prototype, "messagePosition", void 0);
Tt([
  p({ reflect: !0 })
], ct.prototype, "narrow", void 0);
ct = Tt([
  $("bb-timeline-controls")
], ct);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const me = "bb-remember";
class wi {
  async store(t, e) {
    globalThis.localStorage && globalThis.localStorage.setItem(`${me}-${t}`, e);
  }
  async retrieve(t) {
    return globalThis.localStorage ? globalThis.localStorage.getItem(`${me}-${t}`) : null;
  }
}
const xi = new wi();
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const _i = w`
  * {
    box-sizing: border-box;
  }

  :host {
    display: grid;
    grid-template-columns: 1fr 1fr;
    column-gap: 8px;
    height: 100%;
    margin: 8px;
    --diagram-display: flex;
  }

  @media (orientation: portrait) {
    :host {
      grid-template-columns: initial;
      grid-template-rows: 0.4fr 0.6fr;
      row-gap: 8px;
    }
  }

  #diagram {
    width: 100%;
    height: 100%;
    overflow: auto;
    border: 1px solid rgb(227, 227, 227);
    border-radius: calc(var(--bb-grid-size) * 5);
    display: var(--diagram-display);
  }

  #rhs {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: var(--rhs-top) 8px var(--rhs-mid) 8px var(
        --rhs-bottom
      );
    column-gap: calc(var(--bb-grid-size) * 2);
    overflow: auto;
  }

  #controls {
    display: flex;
    align-items: center;
    justify-content: flex-end;
  }

  #run-status {
    font-size: var(--bb-text-pico);
    margin-left: calc(var(--bb-grid-size) * 2);
    text-transform: uppercase;
    text-align: center;
    background: #eee;
    border-radius: calc(var(--bb-grid-size) * 3);
    padding: var(--bb-grid-size);
    font-weight: bold;
    border: 1px solid rgb(230 230 230);
    margin-top: -3px;
    height: 22px;
  }

  #run-status {
    width: 70px;
  }

  #run-status.running {
    border: 1px solid rgb(174 206 161);
    color: rgb(31 56 21);
    background: rgb(223 239 216);
  }

  #run-status.paused {
    border: 1px solid rgb(248 193 122);
    color: rgb(192 116 19);
    background: rgb(255, 242, 204);
  }

  #inputs,
  #outputs,
  #timeline,
  #history {
    border: 1px solid rgb(227, 227, 227);
    border-radius: calc(var(--bb-grid-size) * 5);
    overflow: auto;
    background: rgb(255, 255, 255);
  }

  #timeline,
  #inputs,
  #outputs {
    display: flex;
    flex-direction: column;
  }

  #timeline {
    grid-column: 1 / 3;
  }

  #history {
    display: grid;
    grid-column: 1 / 3;
  }

  .drag-handle {
    cursor: ns-resize;
    grid-column: 1 / 3;
  }

  #timeline h1 {
    font-size: var(--bb-text-small);
    font-weight: bold;
    margin: 0;
  }

  #inputs header,
  #outputs h1,
  #history h1 {
    font-size: var(--bb-text-small);
    font-weight: bold;
    margin: 0;
    padding: calc(var(--bb-grid-size) * 2) calc(var(--bb-grid-size) * 4);
    border-bottom: 1px solid rgb(227, 227, 227);
    position: sticky;
    top: 0;
    background: rgb(255, 255, 255);
    z-index: 1;
    min-height: calc(var(--bb-grid-size) * 10);
    display: flex;
    align-items: center;
  }

  #inputs header {
    display: flex;
    align-items: center;
  }

  #timeline header {
    display: flex;
    padding: calc(var(--bb-grid-size) * 2) calc(var(--bb-grid-size) * 4);
    border-bottom: 1px solid rgb(227, 227, 227);
  }

  #timeline label[for="narrow"],
  #narrow {
    font-size: var(--bb-text-small);
    margin: 0 var(--bb-grid-size) * 2);
    align-self: center;
  }

  #timeline header h1,
  #inputs header h1 {
    font-size: var(--bb-text-small);
    font-weight: bold;
    margin: 0;
    flex: 1;
    align-self: center;
  }

  #inputs #input-options {
    display: flex;
  }

  #inputs #input-options input {
    margin: 0 var(--bb-grid-size);
  }

  #inputs-list,
  #outputs-list,
  #history-list {
    scrollbar-gutter: stable;
    overflow-y: auto;
    font-size: var(--bb-text-small);
  }

  #inputs-list,
  #outputs-list {
    padding: calc(var(--bb-grid-size) * 2) calc(var(--bb-grid-size) * 4);
  }

  #node-information {
    display: flex;
    flex-direction: column;
    position: absolute;
    bottom: 20px;
    left: 20px;
    max-width: calc(var(--bb-grid-size) * 90);
    max-height: 40%;
    border-radius: calc(var(--bb-grid-size) * 6);
    background: rgb(255, 255, 255);
    padding: calc(var(--bb-grid-size) * 4);
    border: 1px solid rgb(204, 204, 204);
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.13),
      0 7px 9px 0 rgba(0, 0, 0, 0.16);
    overflow-y: auto;
    scrollbar-gutter: stable;
  }

  #node-information h1 {
    font-size: var(--bb-text-medium);
    margin: 0;
    font-weight: 400;
    padding: 0 0 0 calc(var(--bb-grid-size) * 8);
    line-height: calc(var(--bb-grid-size) * 6);
    cursor: pointer;
    background: var(--bb-icon-info) 0 0 no-repeat;
  }

  #node-information dl {
    margin: calc(var(--bb-grid-size) * 2) 0;
    padding-right: calc(var(--bb-grid-size) * 5);
    display: grid;
    grid-template-columns: fit-content(50px) 1fr;
    column-gap: calc(var(--bb-grid-size) * 2);
    row-gap: calc(var(--bb-grid-size) * 1);
    font-size: var(--bb-text-nano);
    width: 100%;
    flex: 1;
    overflow: auto;
    scrollbar-gutter: stable;
  }

  #node-information dd {
    margin: 0;
    font-weight: bold;
  }

  #node-information pre {
    font-size: var(--bb-text-nano);
    white-space: pre-wrap;
    margin: 0;
  }

  #node-information #close {
    position: absolute;
    right: calc(var(--bb-grid-size) * 3);
    top: calc(var(--bb-grid-size) * 4);
    width: 24px;
    height: 24px;
    background: var(--bb-icon-close) center center no-repeat;
    border: none;
    font-size: 0;
    opacity: 0.5;
    cursor: pointer;
  }

  #node-information #close:hover {
    opacity: 1;
  }

  #value {
    min-width: 60px;
    display: flex;
    background: #d1cbff;
    border-radius: calc(var(--bb-grid-size) * 3);
    font-size: var(--bb-text-small);
    font-weight: bold;
    height: calc(var(--bb-grid-size) * 5);
    align-items: center;
    justify-content: center;
    margin-left: calc(var(--bb-grid-size) * 2);
    margin-top: calc(var(--bb-grid-size) * -0.5);
  }

  #max {
    font-size: var(--bb-text-pico);
    font-weight: normal;
  }

  #continue {
    background: rgb(209, 203, 255);
    border-radius: calc(var(--bb-grid-size) * 3);
    font-size: var(--bb-text-small);
    font-weight: bold;
    height: calc(var(--bb-grid-size) * 5);
    border: none;
  }
`;
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var E = function(i, t, e, r) {
  var s = arguments.length, o = s < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, n;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(i, t, e, r);
  else
    for (var a = i.length - 1; a >= 0; a--)
      (n = i[a]) && (o = (s < 3 ? n(o) : s > 3 ? n(t, e, o) : n(t, e)) || o);
  return s > 3 && o && Object.defineProperty(t, e, o), o;
};
const ki = (i) => typeof i == "object" && (i.type === "input" || i.type === "output" || i.type === "nodestart" || i.type === "nodeend"), ve = "ui-config", Ai = 60, Ei = "https://storage.googleapis.com/tfweb/visual-breadboard/visual_breadboard_20240118164814/visual_breadboard_bin.js";
let A = class extends y {
  #t;
  #e;
  #i;
  #s;
  #r;
  #o;
  #d;
  #n;
  #a;
  #c;
  #u;
  #h;
  #l;
  #g;
  #v;
  #f;
  #p;
  static {
    this.styles = _i;
  }
  constructor() {
    super(), this.loadInfo = null, this.bootWithUrl = null, this.url = "", this.status = $t.RUNNING, this.boards = [], this.visualizer = "mermaid", this.historyEntries = [], this.selectedNode = null, this.messages = [], this.config = {
      showNarrowTimeline: !1
    }, this.#t = N(), this.#e = /* @__PURE__ */ new Map(), this.#i = N(), this.#s = N(), this.#r = N(), this.#o = N(), this.#d = null, this.#n = null, this.#a = null, this.#c = /* @__PURE__ */ new Map(), this.#u = xi, this.#h = !1, this.#l = 0, this.#g = /* @__PURE__ */ new Map(), this.#v = 0, this.#f = !1, this.#p = !1, this.#u.retrieve(ve).then((t) => {
      t && (this.config = JSON.parse(t));
    });
  }
  async #m(t) {
    this.#h || (this.#h = !0, this.config[t] = !this.config[t], await this.#u.store(ve, JSON.stringify(this.config)), this.#h = !1, this.requestUpdate());
  }
  async renderDiagram(t = "") {
    if (!(!this.loadInfo || !this.loadInfo.diagram || !this.#t.value) && "render" in this.#t.value)
      return this.#t.value.render(this.loadInfo, t);
  }
  unloadCurrentBoard() {
    this.url = null, this.bootWithUrl = null, this.loadInfo = null, this.messages.length = 0, this.#l = 0, this.#g.clear(), this.#e.clear(), this.#t.value && this.#t.value.reset();
  }
  firstUpdated() {
    this.visualizer === "mermaid" ? this.style.setProperty("--diagram-display", "flex") : this.style.setProperty("--diagram-display", "block");
    const t = globalThis.sessionStorage.getItem("rhs-top") || "10fr", e = globalThis.sessionStorage.getItem("rhs-mid") || "45fr", r = globalThis.sessionStorage.getItem("rhs-bottom") || "45fr";
    this.#b(t, e, r);
  }
  #b(t, e, r) {
    this.style.setProperty("--rhs-top", t), this.style.setProperty("--rhs-mid", e), this.style.setProperty("--rhs-bottom", r);
  }
  #y(t) {
    if (!(t.target instanceof HTMLElement) || (t.target.setPointerCapture(t.pointerId), this.#n = t.target.dataset.control || null, !(this.#n && this.#s.value && this.#o.value && this.#i.value)))
      return;
    const e = this.style.getPropertyValue("--rhs-top") || "10fr", r = this.style.getPropertyValue("--rhs-mid") || "45fr", s = this.style.getPropertyValue("--rhs-bottom") || "45fr";
    this.#d = [
      parseFloat(e),
      parseFloat(r),
      parseFloat(s)
    ];
    const o = this.#i.value.getBoundingClientRect(), n = this.#s.value.getBoundingClientRect(), a = this.#o.value.getBoundingClientRect();
    switch (this.#n) {
      case "upper":
        this.#a = new DOMRect(o.x, o.top, o.width, n.bottom - o.top);
        break;
      case "lower":
        this.#a = new DOMRect(n.x, n.top, a.width, a.bottom - n.top);
        break;
      default:
        console.warn(`Unexpected resize target: ${this.#n}`);
        break;
    }
  }
  #$(t) {
    if (this.#a === null || this.#n === null || this.#d === null)
      return;
    let e = (t.pageY - this.#a.top) / this.#a.height;
    e < 0.1 ? e = 0.1 : e > 0.9 && (e = 0.9);
    let r = this.#d[0], s = this.#d[1], o = this.#d[2];
    switch (this.#n) {
      case "upper": {
        const n = r + s;
        r = e * n, s = (1 - e) * n;
        break;
      }
      case "lower": {
        const n = s + o;
        s = e * n, o = (1 - e) * n;
        break;
      }
    }
    this.#b(`${r}fr`, `${s}fr`, `${o}fr`);
  }
  #x() {
    if (!this.#a)
      return;
    this.#a = null;
    const t = this.style.getPropertyValue("--rhs-top"), e = this.style.getPropertyValue("--rhs-mid"), r = this.style.getPropertyValue("--rhs-bottom");
    globalThis.sessionStorage.setItem("rhs-top", t), globalThis.sessionStorage.setItem("rhs-mid", e), globalThis.sessionStorage.setItem("rhs-bottom", r);
  }
  #_(t) {
    if (this.#e.clear(), !!t)
      for (const e of t)
        this.#e.set(e.id, {
          id: e.id,
          type: e.type,
          configuration: e.configuration
        });
  }
  async load(t) {
    this.loadInfo = t, this.#_(t.nodes);
  }
  async #k(t) {
    const e = this.#c.get(t);
    return e ? new Promise((r) => {
      e.push((s) => {
        r(s);
      });
    }) : Promise.reject(`Unable to set up handler for input ${t}`);
  }
  async #A(t) {
    const e = await Promise.all(t.map((r) => new Promise((s) => {
      const o = ({ secret: n }) => {
        s([r, n]);
      };
      this.#c.set(r, [o]);
    })));
    return Object.fromEntries(e);
  }
  async handleStateChange(t, e) {
    this.messages.push(t), this.status === $t.RUNNING && (this.#l = this.messages.length - 1), this.#g.set(t, e), this.requestUpdate();
    const { data: r, type: s } = t;
    switch (s) {
      case "nodestart": {
        console.log(`Initialize nodestart handlers for (id="${r.node.id}", type="${r.node.type}")`), this.#c.has(r.node.id) || this.#c.set(r.node.id, []);
        return;
      }
      case "nodeend": {
        console.log(`Clear nodestart handlers for input(id="${r.node.id}")`), this.#c.delete(r.node.id);
        return;
      }
      case "input":
        return console.log(`Input (id="${r.node.id}") requested`), this.#k(r.node.id);
      case "secret":
        return console.log(`Secrets (${r.keys.join(", ")}) requested`), this.#A(r.keys);
      case "error": {
        console.error("Error:", r.error);
        return;
      }
    }
  }
  #w() {
    clearTimeout(this.#v), this.#v = window.setTimeout(async () => {
      if (this.#f) {
        this.#w();
        return;
      }
      const t = this.messages[this.#l], e = ki(t) ? t.data.node.id : "";
      this.#f = !0, await this.renderDiagram(e), this.#f = !1;
    }, Ai);
  }
  #E(t) {
    this.#r.value && (t.preventDefault(), t.stopImmediatePropagation(), this.#r.value.captureNewestInput());
  }
  render() {
    if (!this.loadInfo)
      return l`Loading board...`;
    this.#w();
    const t = async () => (!this.#p && customElements.get("visual-breadboard") == null && (this.#p = !0, await zi(Ei), this.#w()), l`<visual-breadboard
        ${z(this.#t)}
      ></visual-breadboard>`), e = this.messages[this.messages.length - 1]?.type, r = this.#l < this.messages.length - 1 || e !== "input" && e !== "secret", s = l`<button
      id="continue"
      ?disabled=${r}
      @click=${this.#E}
    >
      Continue
    </button>`;
    return l`
      <div id="diagram">
        ${this.visualizer === "mermaid" ? l`<bb-diagram
                ${z(this.#t)}
                @breadboardnodeselect=${(o) => {
      this.selectedNode = this.#e.get(o.id) || null;
    }}
              ></bb-diagram>` : l`${Ut([this.#p], () => Ft(t(), l`Loading...`))}`}
        ${this.selectedNode ? l`<div id="node-information">
                <h1>Node Information</h1>
                <button id="close" @click=${() => this.selectedNode = null}>
                  Close
                </button>
                <dl>
                  <dd>ID</dd>
                  <dt>${this.selectedNode.id}</dt>
                  <dd>Type</dd>
                  <dt>${this.selectedNode.type}</dt>
                  <dd>Configuration</dd>
                  <dt>
                    <bb-json-tree
                      .json=${this.selectedNode.configuration}
                      autoExpand="true"
                    ></bb-json-tree>
                  </dt>
                </dl>
              </div>` : g}
      </div>
      <div id="rhs">
        <section id="timeline" ${z(this.#i)}>
          <header>
            <h1>Events</h1>
            <label for="narrow">Narrow</label>
            <input
              name="narrow"
              id="narrow"
              type="checkbox"
              ?checked=${this.config.showNarrowTimeline}
              @input=${() => this.#m("showNarrowTimeline")}/>
            <div id="value">${Math.min(this.messages.length, this.#l + 1)} /
            <span id="max">&nbsp;${this.messages.length}</span></div>
            <div id="run-status" class=${nt({ [this.status]: !0 })}>
              ${this.status}
            </div>
          </header>
          <bb-timeline-controls
            .messages=${this.messages}
            .messagePosition=${this.#l}
            .messageDurations=${this.#g}
            .narrow=${this.config.showNarrowTimeline}
            @breadboardmessagetraversal=${(o) => {
      o.index < 0 || o.index > this.messages.length || (this.#l = o.index, this.requestUpdate());
    }}
          ></bb-timeline-controls>
        </section>
        <div
          class="drag-handle"
          data-control="upper"
          @pointerdown=${this.#y}
          @pointermove=${this.#$}
          @pointerup=${this.#x}
        ></div>
        <section id="inputs" ${z(this.#s)}>
            <header>
              <h1>Inputs</h1>
              ${s}
            </header>
            <div id="inputs-list">
              <bb-input-list
                ${z(this.#r)}
                .messages=${this.messages}
                .messagePosition=${this.#l}
                @breadboardinputenter=${(o) => {
      if (this.#l < this.messages.length - 1) {
        this.dispatchEvent(new ut("Unable to submit: board evaluation has already passed this point", B.ERROR));
        return;
      }
      const n = o.data, a = this.#c.get(o.id) || [];
      a.length === 0 && console.warn(`Received event for input(id="${o.id}") but no handlers were found`);
      for (const d of a)
        d.call(null, n);
    }}
              ></bb-input-list>
            </div>
          </section>
          <section id="outputs">
            <h1>Outputs</h1>
            <div id="outputs-list">
              <bb-output-list
                .messages=${this.messages}
                .messagePosition=${this.#l}
              ></bb-output-list>
            </div>
          </section>
          <div
            class="drag-handle"
            data-control="lower"
            @pointerdown=${this.#y}
            @pointermove=${this.#$}
            @pointerup=${this.#x}
          ></div>
          <div id="history" ${z(this.#o)}>
            <bb-history-tree
              .messages=${this.messages}
              .messagePosition=${this.#l}
            ></bb-history-tree>
          </div>
        </section>
      </div>`;
  }
};
E([
  p()
], A.prototype, "loadInfo", void 0);
E([
  p({ reflect: !0 })
], A.prototype, "bootWithUrl", void 0);
E([
  p({ reflect: !0 })
], A.prototype, "url", void 0);
E([
  p({ reflect: !0 })
], A.prototype, "status", void 0);
E([
  p()
], A.prototype, "boards", void 0);
E([
  p()
], A.prototype, "visualizer", void 0);
E([
  P()
], A.prototype, "historyEntries", void 0);
E([
  P()
], A.prototype, "selectedNode", void 0);
E([
  P()
], A.prototype, "messages", void 0);
E([
  P()
], A.prototype, "config", void 0);
A = E([
  $("bb-ui-controller")
], A);
function zi(i) {
  return new Promise((t, e) => {
    const r = document.createElement("script");
    r.src = i, r.onload = () => {
      t();
    }, r.onerror = e, document.head.appendChild(r);
  });
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const rs = () => {
  customElements.define("bb-diagram", Jr), customElements.define("bb-multipart-input", Ie), customElements.define("bb-multipart-input-image", Le), customElements.define("bb-multipart-input-text", Me);
};
export {
  $t as S,
  g as T,
  Ti as a,
  Ri as b,
  rs as c,
  w as d,
  M as e,
  P as f,
  N as g,
  z as h,
  Y as i,
  xr as j,
  Ni as k,
  Ci as l,
  Pe as m,
  p as n,
  nt as o,
  zr as p,
  Ft as q,
  G as r,
  y as s,
  $ as t,
  l as x
};
