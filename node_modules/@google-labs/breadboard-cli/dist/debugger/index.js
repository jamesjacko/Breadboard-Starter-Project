import { e as F, i as G, a as z, p as R, j as H, T as M, m as B, r as E, b as q, l as J, c as K, d as Q, n as U, f as k, s as X, g as D, S as p, x as f, h as L, t as Y, k as Z } from "./index-GydqL_St.js";
import { B as ee, c as te } from "./config-QQQDC_TM.js";
import ae from "./boards.js";
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const S = (a) => J(a) ? a._$litType$.h : a.strings, re = F(class extends G {
  constructor(a) {
    super(a), this.et = /* @__PURE__ */ new WeakMap();
  }
  render(a) {
    return [a];
  }
  update(a, [e]) {
    const t = z(this.it) ? S(this.it) : null, r = z(e) ? S(e) : null;
    if (t !== null && (r === null || t !== r)) {
      const i = R(a).pop();
      let o = this.et.get(t);
      if (o === void 0) {
        const n = document.createDocumentFragment();
        o = H(M, n), o.setConnected(!1), this.et.set(t, o);
      }
      B(o, [i]), E(o, void 0, i);
    }
    if (r !== null) {
      if (t === null || t !== r) {
        const i = this.et.get(r);
        if (i !== void 0) {
          const o = R(i).pop();
          q(a), E(a, void 0, o), B(a, [o]);
        }
      }
      this.it = e;
    } else
      this.it = void 0;
    return this.render(e);
  }
});
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var w = function(a, e, t, r) {
  var i = arguments.length, o = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, n;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(a, e, t, r);
  else
    for (var d = a.length - 1; d >= 0; d--)
      (n = a[d]) && (o = (i < 3 ? n(o) : i > 3 ? n(e, t, o) : n(e, t)) || o);
  return i > 3 && o && Object.defineProperty(e, t, o), o;
}, g = function(a, e, t, r, i) {
  if (r === "m")
    throw new TypeError("Private method is not writable");
  if (r === "a" && !i)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? a !== e || !i : !e.has(a))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return r === "a" ? i.call(a, t) : i ? i.value = t : e.set(a, t), t;
}, s = function(a, e, t, r) {
  if (t === "a" && !r)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? a !== e || !r : !e.has(a))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return t === "m" ? r : t === "a" ? r.call(a) : r ? r.value : e.get(a);
}, u, b, _, m, y, x, I, v, $, T, W, N, P, j, A, C, O;
const ie = async (a) => {
  const e = await ee.load(a, { base: new URL(window.location.href) }), { title: t, description: r, version: i } = e, o = e.mermaid("TD", !0, !0), n = e.nodes;
  return { title: t, description: r, version: i, diagram: o, url: a, graphDescriptor: e, nodes: n };
};
var l;
(function(a) {
  a.BUILD = "build", a.PREVIEW = "preview";
})(l || (l = {}));
K();
let h = class extends X {
  constructor(e) {
    super(), u.add(this), this.url = null, this.loadInfo = null, this.mode = l.BUILD, this.embed = !1, this.toasts = [], b.set(this, D()), _.set(this, D()), m.set(this, 0), y.set(this, 0), x.set(this, p.STOPPED), I.set(this, []), v.set(this, null), $.set(this, "mermaid"), e.boards = e.boards.filter((n) => n.version), e.boards.sort((n, d) => n.title.localeCompare(d.title)), this.config = e;
    const t = new URL(window.location.href), r = t.searchParams.get("board"), i = t.searchParams.get("mode");
    this.embed = t.searchParams.get("embed") !== null, r && g(this, v, r, "f");
    const o = t.searchParams.get("visualizer");
    if ((o === "mermaid" || o === "visualblocks") && g(this, $, o, "f"), i)
      switch (i) {
        case "build":
          this.mode = l.BUILD;
          break;
        case "preview":
          this.mode = l.PREVIEW;
          break;
      }
  }
  get status() {
    return s(this, x, "f");
  }
  set status(e) {
    g(this, x, e, "f"), this.requestUpdate();
  }
  async updated(e) {
    !e.has("mode") && !e.has("url") || (e.has("mode") && s(this, u, "m", j).call(this, this.mode), this.url && (this.loadInfo = await ie(this.url), this.mode === l.BUILD && await s(this, u, "m", W).call(this)));
  }
  toast(e, t) {
    this.toasts.push({ message: e, type: t }), this.requestUpdate();
  }
  render() {
    const e = f`${this.toasts.map(({ message: r, type: i }) => f`<bb-toast .message=${r} .type=${i}></bb-toast>`)}`;
    let t = M;
    if (this.url) {
      let r = M;
      switch (this.mode) {
        case l.BUILD: {
          r = f`<bb-ui-controller
            ${L(s(this, b, "f"))}
            .url=${this.url}
            .loadInfo=${this.loadInfo}
            .status=${this.status}
            .bootWithUrl=${s(this, v, "f")}
            .visualizer=${s(this, $, "f")}
            @breadboardmessagetraversal=${() => {
            this.status === p.RUNNING && (this.status = p.PAUSED, this.toast("Board paused", "information"));
          }}
            @breadboardtoast=${(i) => {
            s(this, b, "f").value && this.toast(i.message, i.toastType);
          }}
            @breadboarddelay=${(i) => {
            g(this, y, i.duration, "f");
          }}
            .boards=${this.config.boards}
          ></bb-ui-controller>`;
          break;
        }
        case l.PREVIEW: {
          r = f`<button
              id="reload"
              @click=${() => {
            s(this, _, "f").value && (s(this, _, "f").value.src = `/preview.html?board=${this.url}`);
          }}
            >
              Reload
            </button>
            <iframe
              ${L(s(this, _, "f"))}
              src="/preview.html?board=${this.url}"
            ></iframe>`;
          break;
        }
        default:
          return f`Unknown mode`;
      }
      t = f`<div id="header-bar">
          <a id="back" href="/" @click=${s(this, u, "m", C)}
            >Back to list</a
          >
          <h1>${this.loadInfo?.title || "Loading board"}</h1>
          <a id="download" @click=${s(this, u, "m", O)}>Download log</a>
        </div>
        <div id="side-bar">
          <button
            id="select-build"
            ?active=${this.mode === l.BUILD}
            @click=${() => this.mode = l.BUILD}
          >
            Build
          </button>
          <button
            id="select-preview"
            ?active=${this.mode === l.PREVIEW}
            @click=${() => this.mode = l.PREVIEW}
          >
            Preview
          </button>
        </div>
        <div id="content" class="${this.mode}">${re(r)}</div>`, this.embed && (t = f`<main id="embed">
          <header>
            <button
              @click=${() => {
        s(this, u, "m", A).call(this, null), this.embed = !1;
      }}
            >
              View in Debugger
            </button>
          </header>
          <iframe src="/preview.html?board=${this.url}&embed=true"></iframe>
        </main>`);
    } else
      t = f`<header>
          <a href="/"><h1 id="title">Breadboard Playground</h1></a>
        </header>
        <bb-board-list
          @breadboardstart=${s(this, u, "m", T)}
          .boards=${this.config.boards}
          .bootWithUrl=${s(this, v, "f")}
        ></bb-board-list>`;
    return f`${t} ${e}`;
  }
};
b = /* @__PURE__ */ new WeakMap();
_ = /* @__PURE__ */ new WeakMap();
m = /* @__PURE__ */ new WeakMap();
y = /* @__PURE__ */ new WeakMap();
x = /* @__PURE__ */ new WeakMap();
I = /* @__PURE__ */ new WeakMap();
v = /* @__PURE__ */ new WeakMap();
$ = /* @__PURE__ */ new WeakMap();
u = /* @__PURE__ */ new WeakSet();
T = async function(e) {
  var t;
  g(this, m, (t = s(this, m, "f"), t++, t), "f"), s(this, u, "m", P).call(this, e.url), this.url = e.url, this.status = p.RUNNING;
};
W = async function() {
  if (!(this.url && s(this, b, "f").value && this.loadInfo))
    return;
  const e = s(this, b, "f").value;
  e.url = this.url, e.load(this.loadInfo);
  const t = s(this, m, "f");
  let r = globalThis.performance.now();
  for await (const i of Z(te(this.url))) {
    const o = i.data.timestamp - r;
    if (s(this, y, "f") !== 0 && await new Promise((d) => setTimeout(d, s(this, y, "f"))), t !== s(this, m, "f"))
      return;
    const n = await e.handleStateChange(i, o);
    await s(this, u, "m", N).call(this, n), r = globalThis.performance.now(), n && await i.reply({ inputs: n });
  }
  this.status = p.STOPPED;
};
N = function(e) {
  return typeof e < "u" && this.status === p.PAUSED && confirm("Are you sure you wish to resume?") && (this.status = p.RUNNING), this.status !== p.PAUSED ? Promise.resolve() : new Promise((r) => {
    s(this, I, "f").push((i) => {
      i === p.RUNNING && r();
    });
  });
};
P = function(e) {
  const t = new URL(window.location.href);
  e === null ? t.searchParams.delete("board") : t.searchParams.set("board", e), window.history.replaceState(null, "", t);
};
j = function(e) {
  const t = new URL(window.location.href);
  e === null ? t.searchParams.delete("mode") : t.searchParams.set("mode", e), window.history.replaceState(null, "", t);
};
A = function(e) {
  const t = new URL(window.location.href);
  e === null || e === !1 ? t.searchParams.delete("embed") : t.searchParams.set("embed", `${e}`), window.history.replaceState(null, "", t);
};
C = function(e) {
  var t;
  e.preventDefault(), confirm("Are you sure you want to change boards?") && (this.url = null, this.loadInfo = null, g(this, v, null, "f"), s(this, u, "m", P).call(this, null), g(this, m, (t = s(this, m, "f"), t++, t), "f"), s(this, b, "f").value && s(this, b, "f").value.unloadCurrentBoard());
};
O = function(e) {
  if (!(e.target instanceof HTMLAnchorElement && s(this, b, "f").value))
    return;
  e.target.href && URL.revokeObjectURL(e.target.href);
  const t = s(this, b, "f").value.messages, r = [], i = [], o = [], n = [];
  for (const c of t)
    if (c.type === "error" && n.push(c), c.type === "output" && o.push(c), c.type === "nodeend")
      switch (c.data.node.type) {
        case "secrets": {
          r.push(...Object.values(c.data.outputs));
          break;
        }
        case "input": {
          i.push(c);
          break;
        }
        case "output": {
          o.push(c);
          break;
        }
      }
  let d = JSON.stringify({ board: this.loadInfo, inputs: i, outputs: o, errors: n, history: t }, null, 2);
  for (const c of r) {
    const V = new RegExp(`\\b${c}\\b`, "gim");
    d = d.replaceAll(V, "SECRET");
  }
  e.target.download = `${(/* @__PURE__ */ new Date()).toISOString()}.json`, e.target.href = URL.createObjectURL(new Blob([d], { type: "application/json" }));
};
h.styles = Q`
    :host {
      flex: 1 0 auto;
      display: grid;
      grid-template-rows: calc(var(--bb-grid-size) * 11) auto;
      grid-template-columns: calc(var(--bb-grid-size) * 16) auto;

      --rhs-top: 10fr;
      --rhs-mid: 45fr;
      --rhs-bottom: 45fr;
    }

    bb-toast {
      z-index: 100;
    }

    :host > header {
      padding: calc(var(--bb-grid-size) * 6) calc(var(--bb-grid-size) * 8)
        calc(var(--bb-grid-size) * 0) calc(var(--bb-grid-size) * 8);
      font-size: var(--bb-text-default);
      grid-column: 1 / 3;
    }

    :host > header a {
      text-decoration: none;
    }

    #header-bar {
      background: rgb(113, 106, 162);
      display: flex;
      align-items: center;
      color: rgb(255, 255, 255);
      box-shadow: 0 0 3px 0 rgba(0, 0, 0, 0.24);
      grid-column: 1 / 3;
      z-index: 1;
    }

    bb-board-list {
      grid-column: 1 / 3;
    }

    #header-bar a#back {
      font-size: 0;
      display: block;
      width: 16px;
      height: 16px;
      background: var(--bb-icon-arrow-back-white) center center no-repeat;
      margin: 0 calc(var(--bb-grid-size) * 5);
    }

    #download {
      font-size: var(--bb-text-pico);
      padding: 4px 8px 4px 24px;
      border-radius: 32px;
      background: #fff var(--bb-icon-download) 4px 2px no-repeat;
      background-size: 16px 16px;
      color: #333;
      margin-right: 8px;
      cursor: default;
      transition: opacity var(--bb-easing-duration-out) var(--bb-easing);
      opacity: 0.8;
      text-decoration: none;
    }

    #download:hover {
      transition: opacity var(--bb-easing-duration-in) var(--bb-easing);
      opacity: 1;
    }

    #header-bar h1 {
      font-size: var(--bb-text-default);
      font-weight: normal;
      flex: 1;
    }

    #title {
      font: var(--bb-text-baseline) var(--bb-font-family-header);
      color: rgb(90, 64, 119);
      margin: 0;
      display: inline;
    }

    #side-bar {
      background: rgb(255, 255, 255);
      box-shadow: 0 0 3px 0 rgba(0, 0, 0, 0.24);
      align-items: center;
      display: flex;
      flex-direction: column;
      padding: calc(var(--bb-grid-size) * 2);
    }

    #side-bar button {
      width: 100%;
      font-size: var(--bb-text-small);
      color: rgb(57, 57, 57);
      text-align: center;
      background: none;
      cursor: pointer;
      margin: calc(var(--bb-grid-size) * 2) 0;
      padding-top: 32px;
      border: none;
      opacity: 0.5;
      position: relative;
    }

    #side-bar button:hover,
    #side-bar button[active] {
      opacity: 1;
    }

    #side-bar button[active] {
      pointer-events: none;
    }

    #side-bar button::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 30px;
      border-radius: 14px;
      background-position: center center;
      background-repeat: no-repeat;
    }

    #side-bar #select-build::before {
      background-image: var(--bb-icon-board);
    }

    #side-bar #select-preview::before {
      background-image: var(--bb-icon-preview);
    }

    #side-bar button[active]::before {
      background-color: rgb(240, 231, 249);
    }

    #content {
      height: calc(100vh - var(--bb-grid-size) * 15);
      display: flex;
      flex-direction: column;
    }

    #reload {
      height: 32px;
      width: 100px;
      margin: calc(var(--bb-grid-size) * 2);
      align-self: flex-end;
      background: #fff var(--bb-icon-frame-reload) 9px 3px no-repeat;
      border-radius: calc(var(--bb-grid-size) * 4);
      border: 1px solid rgb(204, 204, 204);
      padding: 0 8px 0 32px;
    }

    iframe {
      flex: 1 0 auto;
      margin: 0 calc(var(--bb-grid-size) * 2);
      border-radius: calc(var(--bb-grid-size) * 5);
      border: 1px solid rgb(227, 227, 227);
    }

    #embed {
      display: grid;
      grid-template-rows: calc(var(--bb-grid-size) * 10) auto;
      grid-column: 1/3;
      grid-row: 1/3;
    }

    #embed iframe {
      margin: 0;
      width: 100%;
      height: 100%;
      border: none;
      border-radius: 0;
    }

    #embed header {
      display: flex;
      padding: 0 calc(var(--bb-grid-size) * 9);
      align-items: center;
    }
  `;
w([
  U({ reflect: !1 })
], h.prototype, "config", void 0);
w([
  U({ reflect: !0 })
], h.prototype, "url", void 0);
w([
  U({ reflect: !1 })
], h.prototype, "loadInfo", void 0);
w([
  k()
], h.prototype, "mode", void 0);
w([
  k()
], h.prototype, "embed", void 0);
w([
  k()
], h.prototype, "toasts", void 0);
h = w([
  Y("bb-main")
], h);
const se = ae.Boards, oe = {
  boards: [...se]
}, ne = new h(oe);
document.body.appendChild(ne);
